//
//  This file is part of a concatenation of the CwlSignal framework with internal
//  interfaces for direct inclusion in projects instead of library inclusion).
//  For details, visit: https://github.com/mattgallagher/CwlSignal
//
//  Copyright © 2015-2019 Matt Gallagher ( https://www.cocoawithlove.com ). All rights reserved.
//
//  Permission to use, copy, modify, and/or distribute this software for any
//  purpose with or without fee is hereby granted, provided that the above
//  copyright notice and this permission notice appear in all copies.
//
//  THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
//  WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
//  MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
//  SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
//  WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN
//  ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR
//  IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.
//
//  This file was generated by the CwlConcat tool on 2019-04-19 12:09:45 +0000 from the following files:
//   CwlSignal.swift
//   CwlSignalChannel.swift
//   CwlSignalCocoa.swift
//   CwlSignalExtensions.swift
//   CwlSignalReactive.swift

import Foundation

#if SWIFT_PACKAGE
	import CwlUtils
#endif

/// This protocol allows transformations that apply to `Signal` types to be applied to a type that exposes a signal.
protocol SignalInterface {
	associatedtype OutputValue
	var signal: Signal<OutputValue> { get }
}

/// This protocol allows transformations that apply to `Signal` types to be applied to a type that exposes a signal.
protocol SignalInputInterface {
	associatedtype InputValue
	var input: SignalInput<InputValue> { get }
}

/// A composable, one-way, potentially asynchronous, FIFO communication channel that delivers a sequence of `Result<OutputValue, SignalEnd>`.
///
/// In conjunction with various transformation functions, this class forms the core of a reactive programming system. Try the playgrounds for a better walkthrough of concepts and usage.
///
/// # Terminology
///
/// The word "signal" may be used in a number of ways, so keep in mind:
///	- `Signal`: refers to this class
///	- signal graph: one or more `Signal` instances, connected together, from `SignalInput` to `SignalOutput`
///	- signal: the sequence of `Result` instances, from activation to close, that pass through a signal graph
class Signal<OutputValue>: SignalInterface {
	typealias Result = Swift.Result<OutputValue, SignalEnd>
	enum Next {
		case none
		case single(Result)
		case array(Array<Result>)
	}
	
	// # GOALS
	//
	// The primary design goals for this implementation are:
	//	1. All possible actions on `Signal` itself are threadsafe (no possible action results in undefined or corrupt memory behavior for internal data)
	// 2. Deadlocks on internally created mutexes will never occur.
	//	3. Values will never be delivered out-of-order.
	//	4. After a disconnection and reconnection, only values from the latest connection will be delivered.
	//	5. Loopback (sending to an antecedent input from a subsequent signal handler) and attempts at re-entrancy to any closure in the graph are permitted. Attempted re-entrancy delivery is simply queued to be delivered after any in-flight behavior completes.
	//
	// That's quite a list of goals but it's largely covered by two ideas:
	//	1. No user code is ever invoked inside a `Signal` internal mutex
	//	2. Delivery to a `Signal` includes the "predecessor" and the "activationCount". If either fail to match the internal state of the `Signal`, then the delivery is out-of-date and can be discarded.
	//
	// The first of these points is ensured through the use of `itemProcessing`, `holdCount` and `DeferredWork`. The `itemProcessing` and `holdCount` block a queue while out-of-mutex work is performed. The `DeferredWork` defers work to be performed later, once the stack has unwound and no mutexes are held.
	// This ensures that no problematic work is performed inside a mutex but it means that we often have "in-flight" work occurring outside a mutex that might no longer be valid. So we need to combine this work identifiers that allow us to reject out-of-date work. That's where the second point becomes important.
	// The "activationCount" for an `Signal` changes any time a manual input control is generated (`SignalInput`/`SignalMergedInput`), any time a first predecessor is added or any time there are predecessors connected and the `delivery` state changes to or from `.disabled`. Combined with the fact that it is not possible to disconnect and re-add the same predecessor to a multi-input Signal (SignalMergedInput or SignalCombiner) this guarantees any messages from out-of-date but still in-flight deliveries are ignored.
	//
	// # LIMITS TO THREADSAFETY
	//
	// While all actions on `Signal` are threadsafe, there are some points to keep in mind:
	//   1. Threadsafe means that the internal members of the `Signal` class will remain threadsafe and your own closures will always be serially and non-reentrantly invoked on the provided `Exec` context. However, this doesn't mean that work you perform in processing closures is always threadsafe; shared references or mutable captures in your closures will still require mutual exclusion.
	//   2. Delivery of signal values is guaranteed to be in-order and within appropriate mutexes but is not guaranteed to be executed on the sending thread. If subsequent results are sent to a `Signal` from a second thread while the `Signal` is processing a previous result from a first thread the subsequent result will be *queued* and handled on the *first* thread once it completes processing the earlier values.
	//   3. Handlers, captured values and state values will be released *outside* all contexts or mutexes. If you capture an object with `deinit` behavior in a processing closure, you must apply any synchronization context yourself.
	
	// MARK: - Signal static construction functions
	
	/// Create a manual input/output pair where values sent to the `SignalInput` are passed through the `Signal` output.
	///
	/// - returns: a (`SignalInput`, `Signal`) tuple being the input and output for this stage in the signal pipeline.
	static func create() -> (input: SignalInput<OutputValue>, signal: Signal<OutputValue>) {
		let s = Signal<OutputValue>()
		s.activationCount = 1
		return (SignalInput(signal: s, activationCount: s.activationCount), s)
	}
	
	/// A version of created that creates a `SignalMultiInput` instead of a `SignalInput`.
	///
	/// - Returns: the (input, signal)
	static func createMultiInput() -> (input: SignalMultiInput<OutputValue>, signal: Signal<OutputValue>) {
		let s = Signal<OutputValue>()
		var dw = DeferredWork()
		s.mutex.sync { s.updateActivationInternal(andInvalidateAllPrevious: true, dw: &dw) }
		dw.runWork()
		return (SignalMultiInput(signal: s), s)
	}
	
	/// A version of created that creates a `SignalMergedInput` instead of a `SignalInput`.
	///
	/// - Returns: the (input, signal)
	static func createMergedInput(onLastInputClosed: SignalEnd? = nil, onDeinit: SignalEnd = .cancelled) -> (input: SignalMergedInput<OutputValue>, signal: Signal<OutputValue>) {
		let s = Signal<OutputValue>()
		var dw = DeferredWork()
		s.mutex.sync { s.updateActivationInternal(andInvalidateAllPrevious: true, dw: &dw) }
		dw.runWork()
		return (SignalMergedInput(signal: s, onLastInputClosed: onLastInputClosed, onDeinit: onDeinit), s)
	}
	
	/// Similar to `create`, in that it creates a "head" for the graph but rather than immediately providing a `SignalInput`, this function calls the `activationChange` function when the signal graph is activated and provides the newly created `SignalInput` at that time. When the graph deactivates, `nil` is sent to the `activationChange` function. If a subsequent reactivation occurs, the new `SignalInput` for the re-activation is provided.
	///
	/// - Parameters:
	///   - context: the `activationChange` will be invoked in this context
	///   - activationChange: receives inputs on activation and nil on each deactivation
	/// - Returns: the constructed `Signal`
	static func generate(context: Exec = .direct, _ activationChange: @escaping (_ input: SignalInput<OutputValue>?) -> Void) -> Signal<OutputValue> {
		let s = Signal<OutputValue>()
		let nis = Signal<Any?>()
		s.newInputSignal = (nis, nis.subscribe(context: context) { r in
			if case .success(let v) = r {
				activationChange(v as? SignalInput<OutputValue>)
			}
		})
		return s
	}
	
	/// Constructs a `SignalMulti` with an array of "activation" values and a closing error.
	///
	/// - Parameters:
	///   - values: an array of values
	///   - end: the closing condition for the `Signal`
	/// - Returns: a `SignalMulti`
	static func preclosed<S: Sequence>(sequence: S, end: SignalEnd = .complete) -> SignalMulti<OutputValue> where S.Iterator.Element == OutputValue {
		return SignalMulti<OutputValue>(processor: Signal<OutputValue>().attach { (s, dw) in
			SignalMultiProcessor(signal: s, values: (Array(sequence), end), userUpdated: false, activeWithoutOutputs: .always, dw: &dw, context: .direct, updater: { a, p, r in ([], nil) })
		})
	}
	
	/// Constructs a `SignalMulti` with a single activation value and a closing error.
	///
	/// - Parameters:
	///   - value: a single value
	///   - end: the closing condition for the `Signal`
	/// - Returns: a `SignalMulti`
	static func preclosed(_ values: OutputValue..., end: SignalEnd = .complete) -> SignalMulti<OutputValue> {
		return preclosed(sequence: values, end: end)
	}
	
	/// Constructs a `SignalMulti` that is already closed with an error.
	///
	/// - Parameter end: the closing condition for the `Signal`
	/// - Returns: a `SignalMulti`
	static func preclosed(end: SignalEnd = .complete) -> SignalMulti<OutputValue> {
		return SignalMulti<OutputValue>(processor: Signal<OutputValue>().attach { (s, dw) in
			SignalMultiProcessor(signal: s, values: ([], end), userUpdated: false, activeWithoutOutputs: .always, dw: &dw, context: .direct, updater: { a, p, r in ([], nil) })
		})
	}
	
	// MARK: - Signal transformation functions
	
	var signal: Signal<OutputValue> { return self }
	
	/// Appends a `SignalOutput` listener to the value emitted from this `Signal`. The output will "activate" this `Signal` and all direct antecedents in the graph (which may start lazy operations deferred until activation).
	///
	/// - Parameters:
	///   - context: context: the `Exec` context used to invoke the `handler`
	///   - handler: the function invoked for each received `Result`
	/// - Returns: the created `SignalOutput` (if released, the subscription will be cancelled).
	final func subscribe(context: Exec = .direct, _ handler: @escaping (Result) -> Void) -> SignalOutput<OutputValue> {
		return attach { (s, dw) in
			SignalOutput<OutputValue>(signal: s, dw: &dw, context: context, handler: handler)
		}
	}
	
	/// A version of `subscribe` that retains the `SignalOutput` internally, keeping the signal graph alive. The `SignalOutput` is cancelled and released if the signal closes or if the handler returns `false` after any signal.
	///
	/// NOTE: this subscriber deliberately creates a reference counted loop. If the signal is never closed and the handler never returns false, it will result in a memory leak. This function should be used only when `self` is guaranteed to close or the handler `false` condition is guaranteed.
	///
	/// - Parameters:
	///   - context: the execution context where the `processor` will be invoked
	///   - handler: will be invoked with each value received and if returns `false`, the output will be cancelled and released
	final func subscribeWhile(context: Exec = .direct, _ handler: @escaping (Result) -> Bool) {
		_ = attach { (s, dw) in
			var handlerRetainedOutput: SignalOutput<OutputValue>? = nil
			let output = SignalOutput<OutputValue>(signal: s, dw: &dw, context: context, handler: { r in
				withExtendedLifetime(handlerRetainedOutput) {}
				if !handler(r) || r.isFailure {
					handlerRetainedOutput?.cancel()
					handlerRetainedOutput = nil
				}
			})
			handlerRetainedOutput = output
			return output
		}
	}
	
	/// Appends a disconnected `SignalJunction` to this `Signal` so outputs can be repeatedly joined and disconnected from this graph in the future.
	///
	/// - Returns: the `SignalJunction<OutputValue>`
	final func junction() -> SignalJunction<OutputValue> {
		return attach { (s, dw) -> SignalJunction<OutputValue> in
			return SignalJunction<OutputValue>(signal: s, dw: &dw)
		}
	}
	
	/// Appends an immediately activated handler that captures any activation values from this `Signal`. The captured values can be accessed from the `SignalCapture<OutputValue>` using the `activation()` function. The `SignalCapture<OutputValue>` can then be joined to further `Signal`s using the `bind(to:)` function on the `SignalCapture<OutputValue>`.
	///
	/// - Returns: the handler than can be used to obtain activation values and bind to subsequent nodes.
	final func capture() -> SignalCapture<OutputValue> {
		return attach { (s, dw) -> SignalCapture<OutputValue> in
			SignalCapture<OutputValue>(signal: s, dw: &dw)
		}
	}
	
	/// Appends a handler function that transforms the value emitted from this `Signal` into a new `Signal`.
	///
	/// - Parameters:
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: the function invoked for each received `Result`
	/// - Returns: the created `Signal`
	final func transform<U>(context: Exec = .direct, _ processor: @escaping (Result) -> Signal<U>.Next) -> Signal<U> {
		return Signal<U>(processor: attach { (s, dw) in
			SignalTransformer<OutputValue, U>(signal: s, dw: &dw, context: context, processor)
		}).returnToGlobalIfNeeded(context: context)
	}
	
	/// Appends a handler function that transforms the value emitted from this `Signal` into a new `Signal`.
	///
	/// - Parameters:
	///   - initialState: the initial value for a state value associated with the handler. This value is retained and if the signal graph is deactivated, the state value is reset to this value.
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: the function invoked for each received `Result`
	/// - Returns: the transformed output `Signal`
	final func transform<S, U>(initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, Result) -> Signal<U>.Next) -> Signal<U> {
		return Signal<U>(processor: attach { (s, dw) in
			SignalTransformerWithState<OutputValue, U, S>(signal: s, initialState: initialState, dw: &dw, context: context, processor)
		}).returnToGlobalIfNeeded(context: context)
	}
	
	/// Appends a handler function that receives inputs from this and another `Signal<U>`. The `handler` function applies any transformation it wishes an emits a (potentially) third `Signal` type.
	///
	/// - Parameters:
	///   - second:   the other `Signal` that is, along with `self` used as input to the `handler`
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: processes inputs from either `self` or `second` as `EitherResult2<OutputValue, U>` (an enum which may contain either `.result1` or `.result2` corresponding to `self` or `second`) and sends results to an `SignalNext<V>`.
	/// - Returns: an `Signal<V>` which is the result stream from the `SignalNext<V>` passed to the `handler`.
	final func combine<U: SignalInterface, V>(_ second: U, context: Exec = .direct, _ processor: @escaping (EitherResult2<OutputValue, U.OutputValue>) -> Signal<V>.Next) -> Signal<V> {
		return Signal<EitherResult2<OutputValue, U.OutputValue>>(processor: self.attach { (s1, dw) -> SignalCombiner<OutputValue, EitherResult2<OutputValue, U.OutputValue>> in
			SignalCombiner(signal: s1, dw: &dw, context: .direct, processor: EitherResult2<OutputValue, U.OutputValue>.result1)
		}).addPreceeding(processor: second.signal.attach { (s2, dw) -> SignalCombiner<U.OutputValue, EitherResult2<OutputValue, U.OutputValue>> in
			SignalCombiner(signal: s2, dw: &dw, context: .direct, processor: EitherResult2<OutputValue, U.OutputValue>.result2)
		}).transform(context: context, Signal.successProcessor(processor)).returnToGlobalIfNeeded(context: context)
	}
	
	/// Appends a handler function that receives inputs from this and two other `Signal`s. The `handler` function applies any transformation it wishes an emits a (potentially) fourth `Signal` type.
	///
	/// - Parameters:
	///   - second: the second `Signal`, after `self` used as input to the `handler`
	///   - third: the third `Signal`, after `self` and `second`, used as input to the `handler`
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: processes inputs from either `self`, `second` or `third` as `EitherResult3<OutputValue, U, V>` (an enum which may contain either `.result1`, `.result2` or `.result3` corresponding to `self`, `second` or `third`) and sends results to an `SignalNext<W>`.
	/// - Returns: an `Signal<W>` which is the result stream from the `SignalNext<W>` passed to the `handler`.
	final func combine<U: SignalInterface, V: SignalInterface, W>(_ second: U, _ third: V, context: Exec = .direct, _ processor: @escaping (EitherResult3<OutputValue, U.OutputValue, V.OutputValue>) -> Signal<W>.Next) -> Signal<W> {
		return Signal<EitherResult3<OutputValue, U.OutputValue, V.OutputValue>>(processor: self.attach { (s1, dw) -> SignalCombiner<OutputValue, EitherResult3<OutputValue, U.OutputValue, V.OutputValue>> in
			SignalCombiner(signal: s1, dw: &dw, context: .direct, processor: EitherResult3<OutputValue, U.OutputValue, V.OutputValue>.result1)
		}).addPreceeding(processor: second.signal.attach { (s2, dw) -> SignalCombiner<U.OutputValue, EitherResult3<OutputValue, U.OutputValue, V.OutputValue>> in
			SignalCombiner(signal: s2, dw: &dw, context: .direct, processor: EitherResult3<OutputValue, U.OutputValue, V.OutputValue>.result2)
		}).addPreceeding(processor: third.signal.attach { (s3, dw) -> SignalCombiner<V.OutputValue, EitherResult3<OutputValue, U.OutputValue, V.OutputValue>> in
			SignalCombiner(signal: s3, dw: &dw, context: .direct, processor: EitherResult3<OutputValue, U.OutputValue, V.OutputValue>.result3)
		}).transform(context: context, Signal.successProcessor(processor)).returnToGlobalIfNeeded(context: context)
	}
	
	/// Appends a handler function that receives inputs from this and three other `Signal`s. The `handler` function applies any transformation it wishes an emits a (potentially) fifth `Signal` type.
	///
	/// - Parameters:
	///   - second: the second `Signal`, after `self` used as input to the `handler`
	///   - third: the third `Signal`, after `self` and `second`, used as input to the `handler`
	///   - fourth: the fourth `Signal`, after `self`, `second` and `third`, used as input to the `handler`
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: processes inputs from either `self`, `second`, `third` or `fourth` as `EitherResult4<OutputValue, U, V, W>` (an enum which may contain either `.result1`, `.result2`, `.result3` or `.result4` corresponding to `self`, `second`, `third` or `fourth`) and sends results to an `SignalNext<X>`.
	/// - Returns: an `Signal<X>` which is the result stream from the `SignalNext<X>` passed to the `handler`.
	final func combine<U: SignalInterface, V: SignalInterface, W: SignalInterface, X>(_ second: U, _ third: V, _ fourth: W, context: Exec = .direct, _ processor: @escaping (EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>) -> Signal<X>.Next) -> Signal<X> {
		return Signal<EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>>(processor: self.attach { (s1, dw) -> SignalCombiner<OutputValue, EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>> in
			SignalCombiner(signal: s1, dw: &dw, context: .direct, processor: EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>.result1)
		}).addPreceeding(processor: second.signal.attach { (s2, dw) -> SignalCombiner<U.OutputValue, EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>> in
			SignalCombiner(signal: s2, dw: &dw, context: .direct, processor: EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>.result2)
		}).addPreceeding(processor: third.signal.attach { (s3, dw) -> SignalCombiner<V.OutputValue, EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>> in
			SignalCombiner(signal: s3, dw: &dw, context: .direct, processor: EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>.result3)
		}).addPreceeding(processor: fourth.signal.attach { (s4, dw) -> SignalCombiner<W.OutputValue, EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>> in
			SignalCombiner(signal: s4, dw: &dw, context: .direct, processor: EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>.result4)
		}).transform(context: context, Signal.successProcessor(processor)).returnToGlobalIfNeeded(context: context)
	}
	
	/// Appends a handler function that receives inputs from this and four other `Signal`s. The `handler` function applies any transformation it wishes an emits a (potentially) sixth `Signal` type.
	///
	/// - Parameters:
	///   - second: the second `Signal`, after `self` used as input to the `handler`
	///   - third: the third `Signal`, after `self` and `second`, used as input to the `handler`
	///   - fourth: the fourth `Signal`, after `self`, `second` and `third`, used as input to the `handler`
	///   - fifth: the fifth `Signal`, after `self`, `second`, `third` and `fourth`, used as input to the `handler`
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: processes inputs from either `self`, `second`, `third`, `fourth` or `fifth` as `EitherResult5<OutputValue, U, V, W, X>` (an enum which may contain either `.result1`, `.result2`, `.result3`, `.result4` or  `.result5` corresponding to `self`, `second`, `third`, `fourth` or `fifth`) and sends results to an `SignalNext<Y>`.
	/// - Returns: an `Signal<Y>` which is the result stream from the `SignalNext<Y>` passed to the `handler`.
	final func combine<U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y>(_ second: U, _ third: V, _ fourth: W, _ fifth: X, context: Exec = .direct, _ processor: @escaping (EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>) -> Signal<Y>.Next) -> Signal<Y> {
		return Signal<EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>>(processor: self.attach { (s1, dw) -> SignalCombiner<OutputValue, EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>> in
			SignalCombiner(signal: s1, dw: &dw, context: .direct, processor: EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>.result1)
		}).addPreceeding(processor: second.signal.attach { (s2, dw) -> SignalCombiner<U.OutputValue, EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>> in
			SignalCombiner(signal: s2, dw: &dw, context: .direct, processor: EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>.result2)
		}).addPreceeding(processor: third.signal.attach { (s3, dw) -> SignalCombiner<V.OutputValue, EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>> in
			SignalCombiner(signal: s3, dw: &dw, context: .direct, processor: EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>.result3)
		}).addPreceeding(processor: fourth.signal.attach { (s4, dw) -> SignalCombiner<W.OutputValue, EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>> in
			SignalCombiner(signal: s4, dw: &dw, context: .direct, processor: EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>.result4)
		}).addPreceeding(processor: fifth.signal.attach { (s5, dw) -> SignalCombiner<X.OutputValue, EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>> in
			SignalCombiner(signal: s5, dw: &dw, context: .direct, processor: EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>.result5)
		}).transform(context: context, Signal.successProcessor(processor)).returnToGlobalIfNeeded(context: context)
	}
	
	/// Similar to `combine(second:context:handler:)` with an additional "state" value.
	///
	/// - Parameters:
	///   - initialState: the initial value of a "state" value passed into the closure on each invocation. The "state" will be reset to this value if the `Signal` deactivates.
	///   - second:   the other `Signal` that is, along with `self` used as input to the `handler`
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: processes inputs from either `self` or `second` as `EitherResult2<OutputValue, U>` (an enum which may contain either `.result1` or `.result2` corresponding to `self` or `second`) and sends results to an `SignalNext<V>`.
	/// - Returns: an `Signal<V>` which is the result stream from the `SignalNext<V>` passed to the `handler`.
	final func combine<S, U: SignalInterface, V>(_ second: U, initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult2<OutputValue, U.OutputValue>) -> Signal<V>.Next) -> Signal<V> {
		return Signal<EitherResult2<OutputValue, U.OutputValue>>(processor: self.attach { (s1, dw) -> SignalCombiner<OutputValue, EitherResult2<OutputValue, U.OutputValue>> in
			SignalCombiner(signal: s1, dw: &dw, context: .direct, processor: EitherResult2<OutputValue, U.OutputValue>.result1)
		}).addPreceeding(processor: second.signal.attach { (s2, dw) -> SignalCombiner<U.OutputValue, EitherResult2<OutputValue, U.OutputValue>> in
			SignalCombiner(signal: s2, dw: &dw, context: .direct, processor: EitherResult2<OutputValue, U.OutputValue>.result2)
		}).transform(initialState: initialState, context: context, Signal.successProcessorWithState(processor)).returnToGlobalIfNeeded(context: context)
	}
	
	/// Similar to `combine(second:third:context:handler:)` with an additional "state" value.
	///
	/// - Parameters:
	///   - initialState: the initial value of a "state" value passed into the closure on each invocation. The "state" will be reset to this value if the `Signal` deactivates.
	///   - second: the second `Signal`, after `self` used as input to the `handler`
	///   - third: the third `Signal`, after `self` and `second`, used as input to the `handler`
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: processes inputs from either `self`, `second` or `third` as `EitherResult3<OutputValue, U, V>` (an enum which may contain either `.result1`, `.result2` or `.result3` corresponding to `self`, `second` or `third`) and sends results to an `SignalNext<W>`.
	/// - Returns: an `Signal<W>` which is the result stream from the `SignalNext<W>` passed to the `handler`.
	final func combine<S, U: SignalInterface, V: SignalInterface, W>(_ second: U, _ third: V, initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult3<OutputValue, U.OutputValue, V.OutputValue>) -> Signal<W>.Next) -> Signal<W> {
		return Signal<EitherResult3<OutputValue, U.OutputValue, V.OutputValue>>(processor: self.attach { (s1, dw) -> SignalCombiner<OutputValue, EitherResult3<OutputValue, U.OutputValue, V.OutputValue>> in
			SignalCombiner(signal: s1, dw: &dw, context: .direct, processor: EitherResult3<OutputValue, U.OutputValue, V.OutputValue>.result1)
		}).addPreceeding(processor: second.signal.attach { (s2, dw) -> SignalCombiner<U.OutputValue, EitherResult3<OutputValue, U.OutputValue, V.OutputValue>> in
			SignalCombiner(signal: s2, dw: &dw, context: .direct, processor: EitherResult3<OutputValue, U.OutputValue, V.OutputValue>.result2)
		}).addPreceeding(processor: third.signal.attach { (s3, dw) -> SignalCombiner<V.OutputValue, EitherResult3<OutputValue, U.OutputValue, V.OutputValue>> in
			SignalCombiner(signal: s3, dw: &dw, context: .direct, processor: EitherResult3<OutputValue, U.OutputValue, V.OutputValue>.result3)
		}).transform(initialState: initialState, context: context, Signal.successProcessorWithState(processor)).returnToGlobalIfNeeded(context: context)
	}
	
	/// Similar to `combine(second:third:fourth:context:handler:)` with an additional "state" value.
	///
	/// - Parameters:
	///   - initialState: the initial value of a "state" value passed into the closure on each invocation. The "state" will be reset to this value if the `Signal` deactivates.
	///   - second: the second `Signal`, after `self` used as input to the `handler`
	///   - third: the third `Signal`, after `self` and `second`, used as input to the `handler`
	///   - fourth: the fourth `Signal`, after `self`, `second` and `third`, used as input to the `handler`
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: processes inputs from either `self`, `second`, `third` or `fourth` as `EitherResult4<OutputValue, U, V, W>` (an enum which may contain either `.result1`, `.result2`, `.result3` or `.result4` corresponding to `self`, `second`, `third` or `fourth`) and sends results to an `SignalNext<X>`.
	/// - Returns: an `Signal<X>` which is the result stream from the `SignalNext<X>` passed to the `handler`.
	final func combine<S, U: SignalInterface, V: SignalInterface, W: SignalInterface, X>(_ second: U, _ third: V, _ fourth: W, initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>) -> Signal<X>.Next) -> Signal<X> {
		return Signal<EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>>(processor: self.attach { (s1, dw) -> SignalCombiner<OutputValue, EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>> in
			SignalCombiner(signal: s1, dw: &dw, context: .direct, processor: EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>.result1)
		}).addPreceeding(processor: second.signal.attach { (s2, dw) -> SignalCombiner<U.OutputValue, EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>> in
			SignalCombiner(signal: s2, dw: &dw, context: .direct, processor: EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>.result2)
		}).addPreceeding(processor: third.signal.attach { (s3, dw) -> SignalCombiner<V.OutputValue, EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>> in
			SignalCombiner(signal: s3, dw: &dw, context: .direct, processor: EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>.result3)
		}).addPreceeding(processor: fourth.signal.attach { (s4, dw) -> SignalCombiner<W.OutputValue, EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>> in
			SignalCombiner(signal: s4, dw: &dw, context: .direct, processor: EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>.result4)
		}).transform(initialState: initialState, context: context, Signal.successProcessorWithState(processor)).returnToGlobalIfNeeded(context: context)
	}
	
	/// Similar to `combine(second:third:fourth:fifthcontext:handler:)` with an additional "state" value.
	///
	/// - Parameters:
	///   - initialState: the initial value of a "state" value passed into the closure on each invocation. The "state" will be reset to this value if the `Signal` deactivates.
	///   - second: the second `Signal`, after `self` used as input to the `handler`
	///   - third: the third `Signal`, after `self` and `second`, used as input to the `handler`
	///   - fourth: the fourth `Signal`, after `self`, `second` and `third`, used as input to the `handler`
	///   - fifth: the fifth `Signal`, after `self`, `second`, `third` and `fourth`, used as input to the `handler`
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: processes inputs from either `self`, `second`, `third`, `fourth` or `fifth` as `EitherResult5<OutputValue, U, V, W, X>` (an enum which may contain either `.result1`, `.result2`, `.result3`, `.result4` or  `.result5` corresponding to `self`, `second`, `third`, `fourth` or `fifth`) and sends results to an `SignalNext<Y>`.
	/// - Returns: an `Signal<Y>` which is the result stream from the `SignalNext<Y>` passed to the `handler`.
	final func combine<S, U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y>(_ second: U, _ third: V, _ fourth: W, _ fifth: X, initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>) -> Signal<Y>.Next) -> Signal<Y> {
		return Signal<EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>>(processor: self.attach { (s1, dw) -> SignalCombiner<OutputValue, EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>> in
			SignalCombiner(signal: s1, dw: &dw, context: .direct, processor: EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>.result1)
		}).addPreceeding(processor: second.signal.attach { (s2, dw) -> SignalCombiner<U.OutputValue, EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>> in
			SignalCombiner(signal: s2, dw: &dw, context: .direct, processor: EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>.result2)
		}).addPreceeding(processor: third.signal.attach { (s3, dw) -> SignalCombiner<V.OutputValue, EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>> in
			SignalCombiner(signal: s3, dw: &dw, context: .direct, processor: EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>.result3)
		}).addPreceeding(processor: fourth.signal.attach { (s4, dw) -> SignalCombiner<W.OutputValue, EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>> in
			SignalCombiner(signal: s4, dw: &dw, context: .direct, processor: EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>.result4)
		}).addPreceeding(processor: fifth.signal.attach { (s5, dw) -> SignalCombiner<X.OutputValue, EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>> in
			SignalCombiner(signal: s5, dw: &dw, context: .direct, processor: EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>.result5)
		}).transform(initialState: initialState, context: context, Signal.successProcessorWithState(processor)).returnToGlobalIfNeeded(context: context)
	}
	
	/// Appends a new `SignalMulti` to this `Signal`. The new `SignalMulti` immediately activates its antecedents and is "continuous" (multiple listeners can be attached to the `SignalMulti` and each new listener immediately receives the most recently sent value on "activation").
	///
	/// NOTE: this is the canonical "shared value" signal
	///
	/// - parameter initialValues: the immediate value sent to any listeners that connect *before* the first value is sent through this `Signal`
	/// - returns: a continuous `SignalMulti`
	final func continuous(initialValue: OutputValue) -> SignalMulti<OutputValue> {
		return SignalMulti<OutputValue>(processor: attach { (s, dw) in
			SignalMultiProcessor(signal: s, values: ([initialValue], nil), userUpdated: false, activeWithoutOutputs: .always, dw: &dw, context: .direct, updater: { a, p, r -> (Array<OutputValue>, SignalEnd?) in
				let previous: (Array<OutputValue>, SignalEnd?) = (a, p)
				switch r {
				case .success(let v): a = [v]
				case .failure(let e): a = []; p = e
				}
				return previous
			})
		})
	}
	
	/// Appends a new `SignalMulti` to this `Signal`. The new `SignalMulti` immediately activates its antecedents and is "continuous" (multiple listeners can be attached to the `SignalMulti` and each new listener immediately receives the most recently sent value on "activation"). Any listeners that connect before the first signal is received will receive no value on "activation".
	///
	/// NOTE: this is the canonical "shared results" signal
	///
	/// - returns: a continuous `SignalMulti`
	final func continuous() -> SignalMulti<OutputValue> {
		return SignalMulti<OutputValue>(processor: attach { (s, dw) in
			SignalMultiProcessor(signal: s, values: ([], nil), userUpdated: false, activeWithoutOutputs: .always, dw: &dw, context: .direct, updater: { a, p, r -> (Array<OutputValue>, SignalEnd?) in
				let previous: (Array<OutputValue>, SignalEnd?) = (a, p)
				switch r {
				case .success(let v): a = [v]; p = nil
				case .failure(let e): a = []; p = e
				}
				return previous
			})
		})
	}
	
	/// Appends a new `SignalMulti` to this `Signal`. The new `SignalMulti` does not immediately activate (it waits until an output activates it normally). The first activator receives no cached values but does start the signal. If a value is received, subsequent activators will receive the most recent value. Depending on the `discardOnDeactivate` behavior, the cached value may be discarded (resetting the entire signal to its deactivated state) or the cached value might be retained for delivery to any future listeners.
	///
	/// NOTE: this signal is intended for lazily loaded, shared resources.
	///
	/// - returns: a continuous `SignalMulti`
	final func continuousWhileActive(discardOnDeactivate: Bool = true) -> SignalMulti<OutputValue> {
		return SignalMulti<OutputValue>(processor: attach { (s, dw) in
			SignalMultiProcessor(signal: s, values: ([], nil), userUpdated: false, activeWithoutOutputs: discardOnDeactivate ? .never : .ifNonEmpty, dw: &dw, context: .direct, updater: { a, p, r -> (Array<OutputValue>, SignalEnd?) in
				let previous: (Array<OutputValue>, SignalEnd?) = (a, p)
				switch r {
				case .success(let v): a = [v]; p = nil
				case .failure(let e): a = []; p = e
				}
				return previous
			})
		})
	}
	
	/// Appends a new `SignalMulti` to this `Signal`. The new `SignalMulti` immediately activates its antecedents and offers full "playback" (multiple listeners can be attached to the `SignalMulti` and each new listener receives the entire history of values previously sent through this `Signal` upon "activation").
	///
	/// - returns: a playback `SignalMulti`
	final func playback() -> SignalMulti<OutputValue> {
		return SignalMulti<OutputValue>(processor: attach { (s, dw) in
			SignalMultiProcessor(signal: s, values: ([], nil), userUpdated: false, activeWithoutOutputs: .always, dw: &dw, context: .direct, updater: { a, p, r -> (Array<OutputValue>, SignalEnd?) in
				switch r {
				case .success(let v): a.append(v)
				case .failure(let e): p = e
				}
				return ([], nil)
			})
		})
	}
	
	/// Appends a new `Signal` to this `Signal`. The new `Signal` immediately activates its antecedents and caches any values it receives until this the new `Signal` itself is activated – at which point it sends all prior values upon "activation" and subsequently reverts to passthough.
	///
	/// NOTE: this is intended for greedily started signals that might start emitting before the listeners connect.
	///
	/// - Parameter precached: start the cache with some initial values to which subsequent values will be added (default: nil)
	/// - Returns: a "cache until active" `Signal`.
	final func cacheUntilActive(precached: [OutputValue]? = nil) -> Signal<OutputValue> {
		return Signal<OutputValue>(processor: attach { (s, dw) in
			SignalCacheUntilActive(signal: s, precached: precached, dw: &dw)
		})
	}
	
	/// Appends a new `SignalMulti` to this `Signal`. While multiple listeners are permitted, there is no caching, activation signal or other changes inherent in this new `Signal` – newly connected listeners will receive only those values sent after they connect.
	///
	/// NOTE: this is intended for shared signals where new values are important but previous values are not
	///
	/// - returns: a "multicast" `SignalMulti`.
	final func multicast() -> SignalMulti<OutputValue> {
		return SignalMulti<OutputValue>(processor: attach { (s, dw) in
			SignalMultiProcessor(signal: s, values: ([], nil), userUpdated: false, activeWithoutOutputs: .never, dw: &dw, context: .direct, updater: nil)
		})
	}
	
	/// Appends a new `SignalMulti` to this `Signal`. The new `SignalMulti` immediately activates its antecedents. Every time a value is received, it is passed to an "updater" which creates an array of activation values and an error that will be used for any new listeners.
	/// Consider this as an operator that allows the creation of a custom "bring-up-to-speed" value for new listeners.
	///
	/// - Parameters:
	///   - initialValues: activation values used when *before* any incoming value is received (if you wan't to specify closed as well, use `preclosed` instead)
	///   - context: the execution context where the `updater` will run
	///   - updater: run for each incoming `Result` to update the buffered activation values
	/// - Returns: a `SignalMulti` with custom activation
	final func customActivation(initialValues: Array<OutputValue> = [], context: Exec = .direct, _ updater: @escaping (_ cachedValues: inout Array<OutputValue>, _ cachedError: inout SignalEnd?, _ incoming: Result) -> Void) -> SignalMulti<OutputValue> {
		return SignalMulti<OutputValue>(processor: attach { (s, dw) in
			SignalMultiProcessor(signal: s, values: (initialValues, nil), userUpdated: true, activeWithoutOutputs: .always, dw: &dw, context: context) { (bufferedValues: inout Array<OutputValue>, bufferedError: inout SignalEnd?, incoming: Result) -> (Array<OutputValue>, SignalEnd?) in
				let oldActivationValues = bufferedValues
				let oldError = bufferedError
				updater(&bufferedValues, &bufferedError, incoming)
				return (oldActivationValues, oldError)
			}
		})
	}
	
	/// This operator applies a reducing function to the stream of incoming values, reducing down to a single, internal `State` value.
	///
	/// A value of the same `State` type is emitted on each iteration, although it is not required to be the same value. Having the return value be potentially different to the internal state isn't standard "reduction semantics" but it enables differential notifications, rather than whole state notifications.
	///
	/// This operator combines aspects of `transform` and `customActivation` into a single operation, transforming the incoming message into state values by combining with a cached state value (that also serves as the activation value).
	///
	/// - Parameters:
	///   - initialState: initial activation value for the stream and internal state for the reducer
	///   - context: execution context where `reducer` will run
	///   - reducer: the function that combines the state with incoming values and emits differential updates
	/// - Returns: a `SignalMulti<State>`
	final func reduce<State>(initialState: State, context: Exec = .direct, _ reducer: @escaping (_ state: State, _ message: OutputValue) throws -> State) -> SignalMulti<State> {
		return SignalMulti<State>(processor: attach { (s, dw) in
			return SignalReducer<OutputValue, State>(signal: s, state: initialState, end: nil, dw: &dw, context: context) { (state: State, message: Signal<OutputValue>.Result) -> Signal<State>.Result in
				switch message {
				case .success(let m): return Swift.Result { try reducer(state, m) }.mapError(SignalEnd.other)
				case .failure(let e): return .failure(e)
				}
			}
		})
	}
	
	/// This operator applies a reducing function to the stream of incoming values, reducing down to a single, internal `State` value.
	///
	/// A value of the same `State` type is emitted on each iteration, although it is not required to be the same value. Having the return value be potentially different to the internal state isn't standard "reduction semantics" but it enables differential notifications, rather than whole state notifications.
	///
	/// This operator combines aspects of `transform` and `customActivation` into a single operation, transforming the incoming message into state values by combining with a cached state value (that also serves as the activation value).
	///
	/// - Parameters:
	///   - initialState: initial activation value for the stream and internal state for the reducer
	///   - context: execution context where `reducer` will run
	///   - reducer: the function that combines the state with incoming values and emits differential updates
	/// - Returns: a `SignalMulti<State>`
	final func reduce<State>(context: Exec = .direct, initializer: @escaping (_ message: OutputValue) throws -> State?, _ reducer: @escaping (_ state: State, _ message: OutputValue) throws -> State) -> SignalMulti<State> {
		return SignalMulti<State>(processor: attach { (s, dw) in
			let ini: SignalReducer<OutputValue, State>.Initializer = { message in
				switch message {
				case .success(let m): return Swift.Result { try initializer(m) }.mapError(SignalEnd.other)
				case .failure(let e): return .failure(e)
				}
			}
			return SignalReducer<OutputValue, State>(signal: s, initializer: ini, end: nil, dw: &dw, context: context) { (state: State, message: Signal<OutputValue>.Result) -> Signal<State>.Result in
				switch message {
				case .success(let m): return Swift.Result { try reducer(state, m) }.mapError(SignalEnd.other)
				case .failure(let e): return .failure(e)
				}
			}
		})
	}
	
	// MARK: - Signal private properties
	
	// A struct that stores data associated with the current handler. Under the `Signal` mutex, if the `itemProcessing` flag is acquired, the fields of this struct are filled in using `Signal` and `SignalHandler` data and the contents of the struct can be used by the current thread *outside* the mutex.
	private struct ItemContext<OutputValue> {
		let context: Exec
		let synchronous: Bool
		let handler: (Result) -> Void
		let activationCount: Int
		
		init(context: Exec, synchronous: Bool, handler: @escaping (Result) -> Void, activationCount: Int) {
			self.activationCount = activationCount
			self.context = context
			self.synchronous = synchronous
			self.handler = handler
		}
	}
	
	// Protection for all mutable members on this class and any attached `signalHandler`.
	// NOTE 1: This mutex may be shared between synchronous serially connected `Signal`s (for memory and performance efficiency).
	// NOTE 2: It is noted that a `DispatchQueue` mutex would be preferrable since it respects libdispatch's QoS, however, it is not possible (as of Swift 4) to use `DispatchQueue` as a mutex without incurring a heap allocated closure capture so `PThreadMutex` is used instead to avoid a factor of 10 performance loss.
	fileprivate final var mutex: PThreadMutex
	
	// The graph can be disconnected and reconnected and various actions may occur outside locks, it's helpful to determine which actions are no longer relevant. The `Signal` controls this through `delivery` and `activationCount`. The `delivery` controls the basic lifecycle of a simple connected graph through 4 phases: `.disabled` (pre-connection) -> `.sychronous` (connecting) -> `.normal` (connected) -> `.disabled` (disconnected).
	fileprivate final var delivery = SignalDelivery.disabled { didSet { handlerContextNeedsRefresh = true } }
	
	// The graph can be disconnected and reconnected and various actions may occur outside locks, it's helpful to determine which actions are no longer relevant because they are associated with a phase of a previous connection.
	// When connected to a preceeding `SignalPredecessor`, `activationCount` is incremented on each connection and disconnection to ensure that actions associated with a previous phase of a previous connection are rejected. 
	// When connected to a preceeding `SignalInput`, `activationCount` is incremented solely when a new `SignalInput` is attached or the current input is invalidated (joined using an `SignalJunction`).
	fileprivate final var activationCount: Int = 0 { didSet { handlerContextNeedsRefresh = true } }
	
	// If there is a preceeding `Signal` in the graph, its `SignalProcessor` is stored in this variable. Note that `SignalPredecessor` is always an instance of `SignalProcessor`.
	/// If Swift gains an `OrderedSet` type, it should be used here in place of this `Set` and the `sortedPreceeding` accessor, below.
	fileprivate final var preceeding: Set<OrderedSignalPredecessor>
	
	// The destination of this `Signal`. This value is `nil` on construction.
	fileprivate final weak var signalHandler: SignalHandler<OutputValue>? = nil { didSet { handlerContextNeedsRefresh = true } }
	
	fileprivate final var handlerContextNeedsRefresh = true
	
	// Queue of values pending dispatch (NOTE: the current `item` is not stored in the queue)
	// Normally the queue is FIFO but when an `Signal` has multiple inputs, the "activation" from each input will be considered before any post-activation inputs.
	private final var queue = Deque<Result>()
	
	// A `holdCount` may indefinitely block the queue for one of two reasons:
	// 1. a `SignalNext` is retained outside its handler function for asynchronous processing of an item
	// 2. a `SignalCapture` handler has captured the activation but a `Signal` to receive the remainder is not currently connected
	// Accordingly, the `holdCount` should only have a value in the range [0, 2]
	private final var holdCount: UInt8 = 0
	
	// When a `Result` is popped from the queue and the handler is being invoked, the `itemProcessing` is set to `true`. The effect is equivalent to `holdCount`.
	private final var itemProcessing: Bool = false
	
	// Notifications for the inverse of `delivery == .disabled`, accessed exclusively through the `generate` constructor. Can be used for lazy construction/commencement, resetting to initial state on graph disconnect and reconnect or cleanup after graph deletion.
	// A signal is used here instead of a simple function callback since re-entrancy-safe queueing and context delivery are needed.
	// WARNING: this is actually a (Signal<SignalInput<OutputValue>?>, SignalEndpont<SignalInput<OutputValue>?>)? but we use `Any` to avoid huge optimization overheads.
	private final var newInputSignal: (Signal<Any?>, SignalOutput<Any?>)? = nil
	
	// A monotonically increasing counter that is incremented every time the set of connected, preceeding handlers changes. This value is used to reject predecessors that are not up-to-date with the latest graph structure (i.e. have been asynchronously removed or invalidated).
	private final var preceedingCount: Int = 0
	
	// This is a cache of values that can be read outside the lock by the current owner of the `itemProcessing` flag.
	private final var handlerContext = ItemContext<OutputValue>(context: .direct, synchronous: false, handler: { _ in }, activationCount: 0)
	
	// MARK: - Signal private functions

	// Invokes `removeAllPreceedingInternal` if and only if the `forDisconnector` matches the current `preceeding.first`
	//
	// - Parameter forDisconnector: the disconnector requesting this change
	// - Returns: if the predecessor matched, then a new `SignalInput<OutputValue>` for this `Signal`, otherwise `nil`.
	fileprivate final func newInput(forDisconnector: SignalProcessor<OutputValue, OutputValue>) -> SignalInput<OutputValue>? {
		var dw = DeferredWork()
		let result = mutex.sync { () -> SignalInput<OutputValue>? in
			if preceeding.count == 1, let p = preceeding.first?.base, p === forDisconnector {
				removeAllPreceedingInternal(dw: &dw)
				return SignalInput(signal: self, activationCount: activationCount)
			} else {
				return nil
			}
		}
		dw.runWork()
		return result
	}
	
	/// If this `Signal` can attach a new handler, this function runs the provided closure (which is expected to construct and set the new handler) and returns the handler. If this `Signal` can't attach a new handler, returns the result of running the closure inside the mutex of a separate preclosed `Signal`.
	///
	/// This method serves three purposes:
	///	1) It enforces the idea that the `signalHandler` should be constructed under this `Signal`'s mutex, providing the `DeferredWork` required by the `signalHandler` constructor interface.
	///	2) It enforces the rule that multiple listen attempts should be immediately closed with a `.duplicate` error
	///	3) It allows abstraction over the actual `Signal` used for attachment (self for single listener and a newly created `Signal` for multi listener).
	///
	/// - Parameter constructor: the handler constructor function
	/// - Returns: the result from the constructor (typically an SignalHandler)
	fileprivate func attach<R>(constructor: (Signal<OutputValue>, inout DeferredWork) -> R) -> R where R: SignalHandler<OutputValue> {
		var dw = DeferredWork()
		let result: R? = mutex.sync {
			self.signalHandler == nil ? constructor(self, &dw) : nil
		}
		dw.runWork()
		if let r = result {
			return r
		} else {
			preconditionFailure("Multiple outputs added to single listener Signal.")
		}
	}
	
	/// Avoids complications with non-reentrant 
	///
	/// - Parameter context: the context upon which `asyncRelativeContext` will be called
	/// - Returns: possibly `self`, possibly `self` a transform that shifts to the `asyncRelativeContext`.
	fileprivate func returnToGlobalIfNeeded(context: Exec) -> Signal<OutputValue> {
		if context.type.isImmediateAlways || context.type.isReentrant {
			return self
		} else {
			return self.transform(context: context.relativeAsync(), { .single($0) })
		}
	}
	
	/// Constructor for a `Signal` that is the output for a `SignalProcessor`.
	///
	/// - Parameter processor: input source for this `Signal`
	fileprivate init<U>(processor: SignalProcessor<U, OutputValue>) {
		preceedingCount += 1
		preceeding = [processor.wrappedWithOrder(preceedingCount)]
		
		if processor.successorsShareMutex {
			mutex = processor.signal.mutex
		} else {
			mutex = PThreadMutex()
		}
		if !(self is SignalMulti<OutputValue>) {
			var dw = DeferredWork()
			mutex.sync {
				// Since this function must be used only in cases where the processor is *also* new, this can't be `duplicate` or `loop`
				try! processor.outputAddedSuccessorInternal(self, param: nil, activationCount: nil, dw: &dw)
			}
			dw.runWork()
		}
	}
	
	// Connects this `Signal` to a preceeding SignalPredecessor. Other connection functions must go through this.
	//
	// - Parameters:
	//   - newPreceeding: the preceeding SignalPredecessor to add
	//   - param: this function may invoke `outputAddedSuccessorInternal` internally. If it does this `param` will be passed as the `param` for that function.
	//   - dw: required
	// - Throws: any error from `outputAddedSuccessorInternal` invoked on `newPreceeding`
	fileprivate final func addPreceedingInternal(_ newPreceeding: SignalPredecessor, param: Any?, dw: inout DeferredWork) throws {
		preceedingCount += 1
		let wrapped = newPreceeding.wrappedWithOrder(preceedingCount)
		preceeding.insert(wrapped)
		
		do {
			try newPreceeding.outputAddedSuccessorInternal(self, param: param, activationCount: (delivery.isDisabled || preceeding.count == 1) ? Optional<Int>.none : Optional<Int>(activationCount), dw: &dw)
			if !delivery.isDisabled, preceeding.count == 1 {
				updateActivationInternal(andInvalidateAllPrevious: true, dw: &dw)
				if !delivery.isSynchronous {
					let ac = activationCount
					dw.append {
						var dw = DeferredWork()
						self.mutex.sync {
							if ac == self.activationCount {
								newPreceeding.outputCompletedActivationSuccessorInternal(self, dw: &dw)
							}
						}
						dw.runWork()
					}
				}
			}
		} catch {
			preceeding.remove(wrapped)
			throw error
		}
	}
	
	// Removes a (potentially) non-unique predecessor. Used only from `SignalMergeSet` and `SignalMergeProcessor`. This is one of two, independent, functions for removing preceeding. The other being `removeAllPreceedingInternal`.
	//
	// - Parameters:
	//   - oldPreceeding: the predecessor to remove
	//   - dw: required
	fileprivate final func removePreceedingWithoutInterruptionInternal(_ oldPreceeding: SignalPredecessor, dw: inout DeferredWork) -> Bool {
		if preceeding.remove(oldPreceeding.wrappedWithOrder(0)) != nil {
			oldPreceeding.outputRemovedSuccessorInternal(self, dw: &dw)
			return true
		}
		return false
	}
	
	// Removes all predecessors and invalidate all previous inputs. This is one of two, independent, functions for removing preceeding. The other being `removePreceedingWithoutInterruptionInternal`.
	//
	// - Parameters:
	//   - oldPreceeding: the predecessor to remove
	//   - dw: required
	fileprivate final func removeAllPreceedingInternal(dw: inout DeferredWork) {
		if preceeding.count > 0 {
			dw.append { [preceeding] in withExtendedLifetime(preceeding) {} }
			
			// Careful to use *sorted* preceeding to propagate graph changes deterministically
			sortedPreceedingInternal.forEach { $0.base.outputRemovedSuccessorInternal(self, dw: &dw) }
			preceeding = []
		}
		updateActivationInternal(andInvalidateAllPrevious: true, dw: &dw)
	}
	
	// The primary `send` function (although the `push` functions do also send).
	// Sends `result`, assuming `fromInput` matches the current `self.input` and `self.delivery` is enabled
	//
	// - Parameters:
	//   - result: the value or error to pass to any attached handler
	//   - predecessor: the `SignalInput` or `SignalNext` delivering the handler
	//   - activationCount: the activation count from the predecessor to match against internal value
	//   - activated: whether the predecessor is already in `normal` delivery mode
	// - Returns: `nil` on success. Non-`nil` values include `SignalSendError.disconnected` if the `predecessor` or `activationCount` fail to match, `SignalSendError.inactive` if the current `delivery` state is `.disabled`.
	@discardableResult fileprivate final func send(result: Result, predecessor: Unmanaged<AnyObject>?, activationCount: Int, activated: Bool) -> SignalSendError? {
		mutex.unbalancedLock()
		
		guard isCurrent(predecessor, activationCount) else {
			mutex.unbalancedUnlock()
			
			// Retain the result past the end of the lock
			withExtendedLifetime(result) {}
			return SignalSendError.disconnected
		}
		
		switch delivery {
		case .normal:
			if holdCount == 0 && itemProcessing == false {
				assert(queue.isEmpty)
				break
			} else {
				queue.append(result)
				mutex.unbalancedUnlock()
				return nil
			}
		case .synchronous(let count):
			if activated {
				queue.append(result)
				mutex.unbalancedUnlock()
				return nil
			} else if count == 0, holdCount == 0, itemProcessing == false {
				break
			} else {
				queue.insert(result, at: count)
				delivery = .synchronous(count + 1)
				mutex.unbalancedUnlock()
				return nil
			}
		case .disabled:
			mutex.unbalancedUnlock()
			
			// Retain the result past the end of the lock
			withExtendedLifetime(result) {}
			return SignalSendError.inactive
		}
		
		assert(holdCount == 0 && itemProcessing == false)
		
		if handlerContextNeedsRefresh {
			var dw = DeferredWork()
			let hasHandler = refreshItemContextInternal(&dw)
			if hasHandler {
				itemProcessing = true
			}
			mutex.unbalancedUnlock()
			
			// We need to be extremely careful that any previous handlers, replaced in the `refreshItemContextInternal` function are released *here* if we're going to re-enter the lock and that we've *already* acquired the `itemProcessing` Bool. There's a little bit of dancing around in this `if handlerContextNeedsRefresh` block to ensure these two things are true.
			dw.runWork()
			
			if !hasHandler {
				return SignalSendError.inactive
			}
		} else {
			itemProcessing = true
			mutex.unbalancedUnlock()
		}
		
		if case .direct = handlerContext.context, case .success = result {
			handlerContext.handler(result)
			specializedSyncPop()
			return nil
		} else {
			dispatch(result)
			return nil
		}
	}
	
	// A secondary send function used to push values and possibly and end-of-stream error onto the `newInputSignal`. The push is not handled immediately but is deferred until the `DeferredWork` runs. Since values are *always* queued, this is less efficient than `send` but it avoids re-entrancy into self if the `newInputSignal` immediately tries to send values back to us.
	//
	// - Parameters:
	//   - values: pushed onto this `Signal`'s queue
	//   - end: pushed onto this `Signal`'s queue
	//   - activationCount: activationCount of the sender (must match the internal value)
	//   - dw: used to dispatch the signal safely outside the parent's mutex
	fileprivate final func push(values: Array<OutputValue>, end: SignalEnd?, activationCount: Int, activated: Bool, dw: inout DeferredWork) {
		mutex.sync {
			guard self.activationCount == activationCount else { return }
			pushInternal(values: values, end: end, activated: activated, dw: &dw)
		}
	}
	
	// A secondary send function used to push activation values and activation errors. Since values are *always* queued, this is less efficient than `send` but it can safely be invoked inside mutexes.
	//
	// - Parameters:
	//   - values: pushed onto this `Signal`'s queue
	//   - end: pushed onto this `Signal`'s queue
	//   - dw: used to dispatch the signal safely outside the parent's mutex
	fileprivate final func pushInternal(values: Array<OutputValue>, end: SignalEnd?, activated: Bool, dw: inout DeferredWork) {
		assert(mutex.unbalancedTryLock() == false)
		
		guard values.count > 0 || end != nil else {
			dw.append {
				withExtendedLifetime(values) {}
				withExtendedLifetime(end) {}
			}
			return
		}
		
		if !activated, case .synchronous(let count) = delivery {
			assert(count == 0)
			delivery = .synchronous(values.count + (end != nil ? 1 : 0))
		}
		
		for v in values {
			queue.append(.success(v))
		}
		if let e = end {
			queue.append(.failure(e))
		}
		
		resumeIfPossibleInternal(dw: &dw)
	}
	
	// Used in SignalCapture.handleSynchronousToNormalInternal to handle a situation where a deactivation and reactivation occurs *while* `itemProcessing` so the next capture is in the queue instead of being captured. This function extracts the queued value for capture before transition to normal.
	//
	// - Returns: the queued items under the synchronous count.
	fileprivate final func pullQueuedSynchronousInternal() -> (values: Array<OutputValue>, end: SignalEnd?) {
		if case .synchronous(let count) = delivery, count > 0 {
			var values = Array<OutputValue>()
			var end: SignalEnd? = nil
			for _ in 0..<count {
				switch queue.removeFirst() {
				case .success(let v): values.append(v)
				case .failure(let e): end = e
				}
			}
			delivery = .synchronous(0)
			return (values, end)
		}
		return ([], nil)
	}
	
	// Increment the `holdCount`
	fileprivate final func blockInternal() {
		assert(mutex.unbalancedTryLock() == false)
		assert(holdCount <= 1)
		holdCount += 1
	}
	
	// Increment the `holdCount`.
	///
	/// - Parameter activationCount: must match the internal value or the block request will be ignored
	fileprivate final func block(activationCount: Int) {
		mutex.sync {
			guard activationCount == self.activationCount else { return }
			blockInternal()
		}
	}
	
	// Decrement the `holdCount`, if the `activationCountAtBlock` provided matches `self.activationCount`
	//
	// NOTE: the caller must resume processing if holdCount reaches zero and there are queued items.
	///
	/// - Parameter activationCountAtBlock: must match the internal value or the block request will be ignored
	fileprivate final func unblockInternal(activationCountAtBlock: Int) {
		guard self.activationCount == activationCountAtBlock else { return }
		assert(mutex.unbalancedTryLock() == false)
		assert(holdCount >= 1 && holdCount <= 2)
		holdCount -= 1
	}
	
	// If the holdCount is zero and there are queued items, increments the hold count immediately and starts processing in the deferred work.
	///
	/// - Parameter dw: required
	fileprivate final func resumeIfPossibleInternal(dw: inout DeferredWork) {
		if holdCount == 0, itemProcessing == false, !queue.isEmpty {
			if !refreshItemContextInternal(&dw) {
				// The weakly held handler has asynchronously released.
				return
			}
			itemProcessing = true
			dw.append {
				if let r = self.pop() {
					self.dispatch(r)
				}
			}
		}
	}
	
	// Decrement the `holdCount`, if the `activationCount` provided matches `self.activationCount` and resume processing if the `holdCount` reaches zero and there are items in the queue.
	///
	/// - Parameter activationCount: must match the internal value or the block request will be ignored
	fileprivate final func unblock(activationCountAtBlock: Int) {
		var dw = DeferredWork()
		mutex.sync {
			unblockInternal(activationCountAtBlock: activationCountAtBlock)
			resumeIfPossibleInternal(dw: &dw)
		}
		dw.runWork()
	}
	
	// Changes the value of the `self.delivery` instance variable and handles associated lifecycle updates (like incrementing the activation count).
	//
	/// - Parameters:
	///   - newDelivery: new value for `self.delivery`
	///   - dw: required
	fileprivate final func changeDeliveryInternal(newDelivery: SignalDelivery, dw: inout DeferredWork) {
		assert(mutex.unbalancedTryLock() == false)
		assert(newDelivery.isDisabled != delivery.isDisabled || newDelivery.isSynchronous != delivery.isSynchronous)
		
		let oldDelivery = delivery
		delivery = newDelivery
		switch delivery {
		case .normal:
			if oldDelivery.isSynchronous {
				// Careful to use *sorted* preceeding to propagate graph changes deterministically
				for p in sortedPreceedingInternal {
					p.base.outputCompletedActivationSuccessorInternal(self, dw: &dw)
				}
			}
			resumeIfPossibleInternal(dw: &dw)
			newInputSignal?.0.push(values: [SignalInput(signal: self, activationCount: activationCount)], end: nil, activationCount: 0, activated: true, dw: &dw)
		case .synchronous:
			if preceeding.count > 0 {
				updateActivationInternal(andInvalidateAllPrevious: false, dw: &dw)
			}
		case .disabled:
			updateActivationInternal(andInvalidateAllPrevious: true, dw: &dw)
			_ = newInputSignal?.0.push(values: [Optional<SignalInput<OutputValue>>.none], end: nil, activationCount: 0, activated: true, dw: &dw)
		}
	}
	
	/// Constructor for signal graph head. Called from `create`.
	private init() {
		mutex = PThreadMutex()
		preceeding = []
	}
	
	// Need to close the `newInputSignal` and detach from all predecessors on deinit.
	deinit {
		newInputSignal?.0.send(result: .failure(.cancelled), predecessor: nil, activationCount: 0, activated: true)
		
		var dw = DeferredWork()
		mutex.sync {
			removeAllPreceedingInternal(dw: &dw)
		}
		dw.runWork()
	}
	
	// Internal wrapper used by the `combine` functions to ignore error `Results` (which would only be due to graph changes between internal nodes) and process the values with the user handler.
	//
	// - Parameter handler: the user handler
	@discardableResult private static func successProcessor<U, V>(_ processor: @escaping (U) -> Signal<V>.Next) -> (Signal<U>.Result) -> Signal<V>.Next {
		return { (r: Signal<U>.Result) in
			switch r {
			case .success(let v): return processor(v)
			case .failure(let e): return .single(.failure(e))
			}
		}
	}
	
	// Internal wrapper used by the `combine(initialState:...)` functions to ignore error `Results` (which would only be due to graph changes between internal nodes) and process the values with the user handler.
	//
	// - Parameter handler: the user handler
	@discardableResult private static func successProcessorWithState<S, U, V>(_ processor: @escaping (inout S, U) -> Signal<V>.Next) -> (inout S, Signal<U>.Result) -> Signal<V>.Next {
		return { (s: inout S, r: Signal<U>.Result) in
			switch r {
			case .success(let v): return processor(&s, v)
			case .failure(let e): return .single(.failure(e))
			}
		}
	}
	
	/// Returns a copy of the preceeding set, sorted by "order". This allows deterministic sending of results through the graph – older connections are prioritized over newer.
	private var sortedPreceedingInternal: Array<OrderedSignalPredecessor> {
		return preceeding.sorted(by: { (a, b) -> Bool in
			return a.order < b.order
		})
	}
	
	// A wrapper around addPreceedingInternal for use outside the mutex. Only used by the `combine` functions (which is why it returns `self` – it's a syntactic convenience in those methods).
	//
	// - Parameter processor: the preceeding SignalPredecessor to add
	// - Returns: self (for syntactic convenience in the `combine` methods)
	private final func addPreceeding(processor: SignalPredecessor) -> Signal<OutputValue> {
		var dw = DeferredWork()
		mutex.sync {
			// Since this is for use only by the `combine` functions, it cann't be `duplicate` or `loop`
			try! addPreceedingInternal(processor, param: nil, dw: &dw)
		}
		dw.runWork()
		return self
	}
	
	// Increment the activation count.
	//
	// - Parameters:
	//   - andInvalidateAllPrevious: if true, removes all items from the queue (should be false only when transitioning from synchronous to normal).
	//   - dw: required
	private final func updateActivationInternal(andInvalidateAllPrevious: Bool, dw: inout DeferredWork) {
		assert(mutex.unbalancedTryLock() == false)
		
		activationCount = activationCount &+ 1
		
		if andInvalidateAllPrevious {
			let oldItems = Array<Result>(queue)
			dw.append { withExtendedLifetime(oldItems) {} }
			queue.removeAll()
			holdCount = 0
		} else {
			assert(holdCount == 0)
		}
		
		switch delivery {
		case .synchronous:
			if andInvalidateAllPrevious, let h = signalHandler {
				// Any outstanding end activation won't resolve now so we need to apply it directly.
				h.endActivationInternal(dw: &dw)
				return
			}
			fallthrough
		case .normal:
			// Careful to use *sorted* preceeding to propagate graph changes deterministically
			for p in sortedPreceedingInternal {
				p.base.outputActivatedSuccessorInternal(self, activationCount: activationCount, dw: &dw)
			}
		case .disabled:
			// Careful to use *sorted* preceeding to propagate graph changes deterministically
			for p in sortedPreceedingInternal {
				p.base.outputDeactivatedSuccessorInternal(self, dw: &dw)
			}
		}
	}
	
	// Tests whether a `Result` from a `predecessor` with `activationCount` should be accepted or rejected.
	//
	// - Parameters:
	//   - predecessor: the source of the `Result`
	//   - activationCount: the `activationCount` when the source was connected
	// - Returns: true if `preceeding` contains `predecessor` and `self.activationCount` matches `activationCount`
	private final func isCurrent(_ predecessor: Unmanaged<AnyObject>?, _ activationCount: Int) -> Bool {
		if activationCount != self.activationCount {
			return false
		}
		if preceeding.count == 1, let expected = preceeding.first?.base {
			return predecessor?.takeUnretainedValue() === expected
		} else if preceeding.count == 0 {
			return predecessor == nil
		}
		
		guard let p = predecessor?.takeUnretainedValue() as? SignalPredecessor else { return false }
		return preceeding.contains(p.wrappedWithOrder(0))
	}
	
	// The `handlerContext` holds information uniquely used by the currently processing item so it can be read outside the mutex. This may only be called immediately before calling `blockInternal` to start a processing item (e.g. from `send` or `resume`.
	//
	// - Parameter dw: required
	// - Returns: false if the `signalHandler` was `nil`, true otherwise.
	private final func refreshItemContextInternal(_ dw: inout DeferredWork) -> Bool {
		assert(mutex.unbalancedTryLock() == false)
		assert(holdCount == 0 && itemProcessing == false)
		if handlerContextNeedsRefresh {
			if let h = signalHandler {
				dw.append { [handlerContext] in withExtendedLifetime(handlerContext) {} }
				handlerContext = ItemContext(context: h.context, synchronous: delivery.isSynchronous, handler: h.handler, activationCount: activationCount)
				handlerContextNeedsRefresh = false
			} else {
				return false
			}
		}
		return true
	}
	
	// Sets the `handlerContext` back to an "idle" state (releasing any handler closure and setting `activationCount` to zero.
	// This function may be called only from `specializedSyncPop` or `pop`.
	///
	/// - Returns: an empty/idle `ItemContext`
	private final func clearItemContextInternalToExternal(itemOnly: Bool) {
		assert(mutex.unbalancedTryLock() == false)
		itemProcessing = false
		
		if itemOnly {
			mutex.unbalancedUnlock()
		} else {
			var dw = DeferredWork()
			let oldContext = handlerContext
			handlerContext = ItemContext<OutputValue>(context: .direct, synchronous: false, handler: { _ in }, activationCount: 0)
			resumeIfPossibleInternal(dw: &dw)
			mutex.unbalancedUnlock()
			withExtendedLifetime(oldContext) {}
			dw.runWork()
		}
	}
	
	// Invoke the user handler and deactivates the `Signal` if `result` is a `failure`.
	//
	// - Parameter result: passed to the `handlerContext.handler`
	private final func invokeHandler(_ result: Result) {
		// It is subtle but it is more efficient to *repeat* the handler invocation for each case (rather than using a fallthrough or hoisting out of the `switch`), since Swift can handover ownership, rather than retaining.
		switch result {
		case .success:
			handlerContext.handler(result)
		case .failure:
			handlerContext.handler(result)
			var dw = DeferredWork()
			mutex.sync {
				if handlerContext.activationCount == activationCount, !delivery.isDisabled {
					signalHandler?.deactivateInternal(dueToLackOfOutputs: false, dw: &dw)
				}
			}
			dw.runWork()
		}
	}
	
	// Dispatches the `result` to the current handler in the appropriate context then pops the next `result` and attempts to invoke the handler with the next result (if any)
	//
	// - Parameter result: for sending to the handler
	private final func dispatch(_ result: Result) {
		if case .direct = handlerContext.context {
			invokeHandler(result)
			specializedSyncPop()
		} else if handlerContext.context.type.isImmediateInCurrentContext {
			for r in sequence(first: result, next: { _ in self.pop() }) {
				invokeHandler(r)
			}
		} else if handlerContext.synchronous {
			for r in sequence(first: result, next: { _ in self.pop() }) {
				handlerContext.context.invokeSync{ invokeHandler(r) }
			}
		} else {
			handlerContext.context.invoke {
				for r in sequence(first: result, next: { _ in self.pop() }) {
					self.invokeHandler(r)
				}
			}
		}
	}
	
	/// Gets the next item from the queue for processing and updates the `ItemContext`.
	///
	/// - Returns: the next result for processing, if any
	private final func pop() -> Result? {
		mutex.unbalancedLock()
		assert(itemProcessing == true)
		
		guard !handlerContextNeedsRefresh else {
			clearItemContextInternalToExternal(itemOnly: false)
			return nil
		}
		
		if !queue.isEmpty, holdCount == 0 {
			switch delivery {
			case .synchronous(let count) where count == 0: break
			case .synchronous(let count):
				delivery = .synchronous(count - 1)
				fallthrough
			default:
				let result = queue.removeFirst()
				mutex.unbalancedUnlock()
				return result
			}
		}
		
		clearItemContextInternalToExternal(itemOnly: true)
		return nil
	}
	
	/// An optimized version of `pop(_:)` used when context is .direct. The semantics are slightly different: this doesn't pop a result off the queue... rather, it looks to see if there's anything in the queue and handles it internally if there is. This allows optimization for the expected case where there's nothing in the queue.
	private final func specializedSyncPop() {
		mutex.unbalancedLock()
		assert(itemProcessing == true)
		
		if handlerContextNeedsRefresh {
			clearItemContextInternalToExternal(itemOnly: false)
		} else if !queue.isEmpty {
			mutex.unbalancedUnlock()
			while let r = pop() {
				invokeHandler(r)
			}
		} else {
			itemProcessing = false
			mutex.unbalancedUnlock()
		}
	}
}

/// `SignalMulti<OutputValue>` is the only subclass of `Signal<OutputValue>`. It represents a `Signal<OutputValue>` that allows attaching multiple listeners (a normal `Signal<OutputValue>` is "single owner" and will immediately close any subsequent listeners after the first with a `SignalBindError.duplicate` error).
/// This class is not constructed directly but is instead created from one of the `SignalMulti<OutputValue>` returning functions on `Signal<OutputValue>`, including `playback()`, `multicast()` and `continuous()`.
final class SignalMulti<OutputValue>: Signal<OutputValue> {
	private let spawnSingle: (SignalPredecessor) -> Signal<OutputValue>
	
	fileprivate override init<U>(processor: SignalProcessor<U, OutputValue>) {
		assert(processor.multipleOutputsPermitted, "Construction of SignalMulti from a single output processor is illegal.")
		spawnSingle = { proc in
			let p = proc as! SignalProcessor<U, OutputValue>
			return Signal<OutputValue>(processor: p).returnToGlobalIfNeeded(context: p.context)
		}
		super.init(processor: processor)
	}
	
	fileprivate override func attach<R>(constructor: (Signal<OutputValue>, inout DeferredWork) -> R) -> R where R: SignalHandler<OutputValue> {
		return spawnSingle(preceeding.first!.base).attach(constructor: constructor)
	}
}

/// An `SignalInput` is used to send values to the "head" `Signal`s in a signal graph. It is created using the `Signal<T>.create()` function.
class SignalInput<InputValue>: Lifetime, SignalInputInterface {
	fileprivate final weak var signal: Signal<InputValue>?
	fileprivate final let activationCount: Int
	
	var input: SignalInput<InputValue> { return self }
	
	// Create a new `SignalInput` (usually created by the `Signal<T>.create` function)
	//
	// - Parameters:
	//   - signal: the destination signal
	//   - activationCount: to be sent with each send to the signal
	fileprivate init(signal: Signal<InputValue>, activationCount: Int) {
		self.signal = signal
		self.activationCount = activationCount
	}
	
	/// The primary signal sending function
	///
	/// - Parameter result: the value or error to send, composed as a `Result`
	/// - Returns: `nil` on success. Non-`nil` values include `SignalSendError.disconnected` if the `predecessor` or `activationCount` fail to match, `SignalSendError.inactive` if the current `delivery` state is `.disabled`.
	@discardableResult
	func send(result: Result<InputValue, SignalEnd>) -> SignalSendError? {
		guard let s = signal else { return SignalSendError.disconnected }
		return s.send(result: result, predecessor: nil, activationCount: activationCount, activated: true)
	}
	
	/// The purpose for this method is to obtain a true `SignalInput` (instead of a `SignalMultiInput` or `SignalMergedInput`. A true `SignalInput` is faster for multiple send operations and is needed internally by the `bind` methods.
	/// The base `SignalInput` implementation returns `self`.
	func singleInput() -> SignalInput<InputValue> {
		return self
	}
	
	/// Implementation of `Lifetime` that sends a `SignalComplete.cancelled`. You wouldn't generally invoke this yourself; it's intended to be invoked if the `SignalInput` owner is released and the `SignalInput` is no longer retained.
	func cancel() {
		send(result: .failure(.cancelled))
	}
	
	fileprivate func cancelOnDeinit() {
		cancel()
	}

	deinit {
		cancelOnDeinit()
	}
}

// If `Signal<OutputValue>` is a delivery channel, then `SignalHandler` is the destination to which it delivers.
// While the base `SignalHandler<OutputValue>` is not "abstract" in any technical sense, it doesn't do anything by default and offers no members. Subclasses include `SignalOutput` (the user "exit" point for signal results), `SignalProcessor` (used for transforming signals between instances of `Signal<OutputValue>`), `SignalJunction` (for enabling dynamic graph connection and disconnections).
// `SignalHandler<OutputValue>` is never directly created or held by users of the CwlSignal library. It is implicitly created when one of the listening or transformation methods on `Signal<OutputValue>` are invoked.
class SignalHandler<OutputValue> {
	fileprivate final let signal: Signal<OutputValue>
	fileprivate final let context: Exec
	fileprivate final var handler: (Result<OutputValue, SignalEnd>) -> Void { didSet { signal.handlerContextNeedsRefresh = true } }
	
	// Base constructor sets the `signal`, `context` and `handler` and implicitly activates if required.
	//
	// - Parameters:
	//   - signal: a `SignalHandler` is attached to its predecessor `Signal` for its lifetime
	//   - dw: used for performing activation outside any enclosing mutex, if necessary
	//   - context: where the `handler` function should be invoked
	fileprivate init(signal: Signal<OutputValue>, dw: inout DeferredWork, context: Exec) {
		// Must be passed a `Signal` that does not already have a `signalHandler`
		assert(signal.signalHandler == nil && signal.mutex.unbalancedTryLock() == false)
		
		self.signal = signal
		self.context = context
		self.handler = { _ in }
		
		// Connect to the `Signal`
		signal.signalHandler = self
		
		// Set the initial handler
		self.handler = initialHandlerInternal()
		
		// Propagate immediately
		if activeWithoutOutputsInternal {
			if activateInternal(dw: &dw) {
				let count = self.signal.activationCount
				dw.append { self.endActivation(activationCount: count) }
			}
		}
	}
	
	// Default behavior does nothing prior to activation
	fileprivate func initialHandlerInternal() -> (Result<OutputValue, SignalEnd>) -> Void {
		assert(signal.mutex.unbalancedTryLock() == false)
		return { _ in }
	}
	
	// Convenience wrapper around the mutex from the `Signal` which is used to protect the handler
	//
	// - Parameter execute: the work to perform inside the mutex
	// - Returns: the result from the `execute closure
	// - Throws: basic rethrow from the `execute` closure
	fileprivate final func sync<OutputValue>(execute: () throws -> OutputValue) rethrows -> OutputValue {
		signal.mutex.unbalancedLock()
		defer { signal.mutex.unbalancedUnlock() }
		return try execute()
	}
	
	// True if this node activates predecessors even when it has no active successors
	fileprivate var activeWithoutOutputsInternal: Bool {
		assert(signal.mutex.unbalancedTryLock() == false)
		return false
	}
	
	deinit {
		var dw = DeferredWork()
		sync {
			if !signal.delivery.isDisabled {
				signal.changeDeliveryInternal(newDelivery: .disabled, dw: &dw)
			}
			signal.signalHandler = nil
		}
		dw.runWork()
	}
	
	// As an optimization, successive `Signal`s are placed under the *same* mutex as any preceeding `.sync` `SignalHandler`s
	// `SignalJunction`, `SignalCombiner`, `SignalCapture` and `SignalMultiInputProcessor` all returns `false` since they involve either changing connectivity or multiple connectivity.
	fileprivate var successorsShareMutex: Bool {
		if case .direct = context {
			return true
		} else {
			return false
		}
	}
	
	// Activation changes the delivery, based on whether there are preceeding `Signal`s.
	// If delivery is changed to synchronous, `endActivation` must be called in the deferred work.
	///
	/// - Parameter dw: required
	/// - Returns: true if a transition to `.synchronous` occurred
	fileprivate final func activateInternal(dw: inout DeferredWork) -> Bool {
		assert(signal.mutex.unbalancedTryLock() == false)
		if signal.delivery.isDisabled {
			signal.changeDeliveryInternal(newDelivery: .synchronous(0), dw: &dw)
			return true
		}
		return false
	}
	
	// Completes the transition to `.normal` delivery at the end of the `.synchronous` stage.
	///
	/// - Parameter dw: required
	fileprivate final func endActivationInternal(dw: inout DeferredWork) {
		if signal.delivery.isSynchronous {
			handleSynchronousToNormalInternal(dw: &dw)
			signal.changeDeliveryInternal(newDelivery: .normal, dw: &dw)
		}
	}
	
	// Completes the transition to `.normal` delivery at the end of the `.synchronous` stage.
	///
	/// - Parameter activationCount: must match the internal value or the attempt will be rejected
	fileprivate final func endActivation(activationCount: Int) {
		var dw = DeferredWork()
		sync {
			guard signal.activationCount == activationCount else { return }
			endActivationInternal(dw: &dw)
		}
		dw.runWork()
	}
	
	// If this property returns false, attempts to connect more than one output will be rejected. The rejection information is used primarily by SignalJunction which performs disconnect and bind as two separate steps so it needs the rejection to ensure two threads haven't tried to bind simultaneously.
	fileprivate var multipleOutputsPermitted: Bool {
		return false
	}
	
	// Override point invoked from `endActivationInternal` used in `SignalCapture`
	// - Parameter dw: required
	fileprivate func handleSynchronousToNormalInternal(dw: inout DeferredWork) {
	}
	
	// Changes delivery to disabled *and* resets the handler to the initial handler.
	// - Parameter dw: required
	fileprivate final func deactivateInternal(dueToLackOfOutputs: Bool, dw: inout DeferredWork) {
		assert(signal.mutex.unbalancedTryLock() == false)
		if !activeWithoutOutputsInternal || !dueToLackOfOutputs {
			signal.changeDeliveryInternal(newDelivery: .disabled, dw: &dw)
			dw.append { [handler] in
				withExtendedLifetime(handler) {}
				
				// Outputs may release themselves on deactivation so we need to keep ourselves alive until outside the lock
				withExtendedLifetime(self) {}
			}
			if !activeWithoutOutputsInternal {
				handler = initialHandlerInternal()
			} else {
				handler = { _ in }
			}
		}
	}
}

// A hashable wrapper around an SignalPredecessor existential that also embeds an order value to allow ordering
// NOTE 1: the order is *not* part of the equality or hashValue so a wrapper can be created with an arbitrary order to test for the presence of a given SignalPredecessor.
// NOTE 2: if Swift gains an OrderedSet, it might be possible to replace this with `Hashable` conformance on `SignalPredecessor`.
fileprivate struct OrderedSignalPredecessor: Hashable {
	let base: SignalPredecessor
	let order: Int
	init(base: SignalPredecessor, order: Int) {
		self.base = base
		self.order = order
	}
	
	func hash(into hasher: inout Hasher) {
		hasher.combine(Int(bitPattern: Unmanaged<AnyObject>.passUnretained(base).toOpaque()))
	}
	
	static func ==(lhs: OrderedSignalPredecessor, rhs: OrderedSignalPredecessor) -> Bool {
		return lhs.base === rhs.base
	}
}

// A protocol used for communicating from successor `Signal`s to predecessor `SignalProcessor`s in the signal graph.
// Used for connectivity and activation.
fileprivate protocol SignalPredecessor: class {
	func outputActivatedSuccessorInternal(_ successor: AnyObject, activationCount: Int, dw: inout DeferredWork)
	func outputCompletedActivationSuccessorInternal(_ successor: AnyObject, dw: inout DeferredWork)
	func outputDeactivatedSuccessorInternal(_ successor: AnyObject, dw: inout DeferredWork)
	func outputAddedSuccessorInternal(_ successor: AnyObject, param: Any?, activationCount: Int?, dw: inout DeferredWork) throws
	func outputRemovedSuccessorInternal(_ successor: AnyObject, dw: inout DeferredWork)
	func predecessorsSuccessorInternal(loopCheck: AnyObject) -> Bool
	func outputSignals<U>(ofType: U.Type) -> [Signal<U>]
	var loopCheckValue: AnyObject { get }
	func wrappedWithOrder(_ order: Int) -> OrderedSignalPredecessor
}

// Easy construction of a hashable wrapper around an SignalPredecessor existential
extension SignalPredecessor {
	func wrappedWithOrder(_ order: Int) -> OrderedSignalPredecessor {
		return OrderedSignalPredecessor(base: self, order: order)
	}
}

// All `Signal`s, except those with output handlers, are fed to another `Signal`. A `SignalProcessor` is how this is done. This is the abstract base for all handlers that connect to another `Signal`. The default implementation can only connect to a single output (concrete subclass `SignalMultiprocessor` is used for multiple outputs) but a majority of the architecture for any number of outputs is contained in this class.
// This class allows its outputs to have a different value type compared to the Signal for this class, although only SignalTransformer, SignalTransformerWithState and SignalCombiner take advantage – all other subclasses derive from SignalProcessor<OutputValue, OutputValue>.
class SignalProcessor<OutputValue, U>: SignalHandler<OutputValue>, SignalPredecessor {
	typealias OutputsArray = Array<(destination: Weak<Signal<U>>, activationCount: Int?)>
	var outputs = OutputsArray()
	
	// Common implementation for a nextHandlerInternal. Currently used only from SignalCacheUntilActive and SignalCombiner
	//
	// - Parameters:
	//   - processor: the `SignalProcessor` instance
	//   - transform: the transformation applied from input to output
	// - Returns: a function usable as the return value to `nextHandlerInternal`
	fileprivate static func simpleNext(processor: SignalProcessor<OutputValue, U>, transform: @escaping (Result<OutputValue, SignalEnd>) -> Result<U, SignalEnd>) -> (Result<OutputValue, SignalEnd>) -> Void {
		assert(processor.signal.mutex.unbalancedTryLock() == false)
		guard let output = processor.outputs.first, let outputSignal = output.destination.value, let ac = output.activationCount else { return processor.initialHandlerInternal() }
		let activated = processor.signal.delivery.isNormal
		let predecessor: Unmanaged<AnyObject>? = Unmanaged.passUnretained(processor)
		return { [weak outputSignal] r in
			outputSignal?.send(result: transform(r), predecessor: predecessor, activationCount: ac, activated: activated)
		}
	}
	
	// Determines if a `Signal` is one of the current outputs.
	//
	// - Parameter signal: possible output
	// - Returns: true if `signal` is contained in the outputs
	fileprivate final func isOutputInternal(_ signal: Signal<U>) -> Int? {
		assert(signal.mutex.unbalancedTryLock() == false)
		for (i, o) in outputs.enumerated() {
			if let d = o.destination.value, d === signal {
				return i
			}
		}
		return nil
	}
	
	/// Identity used for checking loops (needs to be the mutex since the mutex is shared vertically through the graph, any traversal looking for potential loops could deadlock before noticing a loop with any other value)
	fileprivate final var loopCheckValue: AnyObject { return signal.mutex }
	
	// Performs a depth-first graph traversal looking for the specified `SignalPredecessor`
	//
	// - Parameter contains: the search value
	// - Returns: true if `contains` was found, false otherwise
	func predecessorsSuccessorInternal(loopCheck: AnyObject) -> Bool {
		// Only check the value when successors don't share the mutex (i.e. when we have a boundary of some kind).
		if !successorsShareMutex && loopCheck === self.loopCheckValue {
			return true
		}
		var result = false
		runSuccesorAction {
			// Don't need to traverse sortedPreceeding (unsorted is fine for an ancestor check)
			for p in signal.preceeding {
				if p.base.predecessorsSuccessorInternal(loopCheck: loopCheck) {
					result = true
					return
				}
			}
		}
		return result
	}
	
	/// Returns the list of outputs, assuming they match the provided type. This method is used when attempting to remove a SignalMulti from the list of inputs to a SignalInputMulti since the whole list of outputs may need to be searched to find one that's actually connected to the SignalInputMulti.
	///
	/// - Parameter ofType: specifies the input type of the SignalInputMulti (it will always match but we follow the type system, rather than force matching.
	/// - Returns: a strong array of outputs
	func outputSignals<U>(ofType: U.Type) -> [Signal<U>] {
		return sync {
			return outputs.compactMap { $0.destination.value as? Signal<U> }
		}
	}

	
	// Pushes activation values to newly joined outputs. By default, there is no activation so this function is intended to be overridden. Currently overridden by `SignalMultiProcessor` and `SignalCacheUntilActive`.
	//
	// - Parameters:
	//   - index: identifies the output
	//   - dw: required by pushInternal
	fileprivate func sendActivationToOutputInternal(index: Int, dw: inout DeferredWork) {
	}
	
	// When an output changes activation, this function is called.
	//
	// - Parameters:
	//   - index: index of the activation changed output
	//   - activationCount: new count received
	//   - dw: required
	// - Returns: any response from `activateInternal` (true if started activating)
	fileprivate final func updateOutputInternal(index: Int, activationCount: Int?, dw: inout DeferredWork) -> Bool {
		assert(signal.mutex.unbalancedTryLock() == false)
		assert(outputs[index].activationCount != activationCount)
		
		let previous = anyActiveOutputsInternal
		
		outputs[index].activationCount = activationCount
		dw.append { [handler] in withExtendedLifetime(handler) {} }
		handler = nextHandlerInternal()
		
		var result = false
		if activationCount != nil {
			sendActivationToOutputInternal(index: index, dw: &dw)
			result = activateInternal(dw: &dw)
		} else if activationCount == nil && !signal.delivery.isDisabled && !activeWithoutOutputsInternal {
			var anyStillActive = false
			for o in outputs {
				if o.activationCount != nil {
					anyStillActive = true
					break
				}
			}
			if !anyStillActive {
				deactivateInternal(dueToLackOfOutputs: true, dw: &dw)
			}
		}
		
		if activationCount != nil, !previous {
			firstOutputActivatedInternal(dw: &dw)
		} else if activationCount == nil, !anyActiveOutputsInternal {
			lastOutputDeactivatedInternal(dw: &dw)
		}
		return result
	}
	
	// Helper function that applies the mutex around the supplied function, if needed.
	//
	// - parameter action: function to be run inside the mutex
	private final func runSuccesorAction(action: () -> Void) {
		if successorsShareMutex {
			action()
		} else {
			sync { action() }
		}
	}
	
	/// Helper function used before and after activation to determine if this handler should activate or deactivated.
	private final var anyActiveOutputsInternal: Bool {
		assert(signal.mutex.unbalancedTryLock() == false)
		for o in outputs {
			if o.destination.value != nil && o.activationCount != nil {
				return true
			}
		}
		return false
	}
	
	/// Overrideable function to attach behaviors to activation by an output
	///
	/// - parameter dw: required
	fileprivate func firstOutputActivatedInternal(dw: inout DeferredWork) {
	}
	
	/// Overrideable function to attach behaviors to deactivation by an output
	///
	/// - parameter dw: required
	fileprivate func lastOutputDeactivatedInternal(dw: inout DeferredWork) {
	}
	
	/// Overrideable function to attach behaviors to output removal
	///
	/// - parameter dw: required
	fileprivate func lastOutputRemovedInternal(dw: inout DeferredWork) {
	}
	
	// Invoked from successor `Signal`s when they activate
	//
	// - Parameters:
	//   - successor: a `Signal` (must be a Signal<U>)
	//   - activationCount: new activation count value for the `Signal`
	//   - dw: required
	fileprivate final func outputActivatedSuccessorInternal(_ successor: AnyObject, activationCount: Int, dw: inout DeferredWork) {
		runSuccesorAction {
			guard let sccr = successor as? Signal<U> else { fatalError() }
			if let i = isOutputInternal(sccr) {
				_ = updateOutputInternal(index: i, activationCount: activationCount, dw: &dw)
			}
		}
	}
	
	// Invoked from successor when it completes activation and transitions to `.normal` delivery
	//
	// - Parameters:
	//   - successor: the successor whose activation status has changed (must be a Signal<U>)
	//   - dw: required
	func outputCompletedActivationSuccessorInternal(_ successor: AnyObject, dw: inout DeferredWork) {
		runSuccesorAction {
			guard let sccr = successor as? Signal<U> else { fatalError() }
			if let _ = isOutputInternal(sccr), case .synchronous = signal.delivery {
				endActivationInternal(dw: &dw)
			}
		}
	}
	
	// Invoked from successor `Signal`s when they deactivate
	//
	// - Parameters:
	//   - successor: must be a Signal<U>
	//   - dw: required
	fileprivate final func outputDeactivatedSuccessorInternal(_ successor: AnyObject, dw: inout DeferredWork) {
		runSuccesorAction {
			guard let sccr = successor as? Signal<U> else { fatalError() }
			if let i = self.isOutputInternal(sccr) {
				_ = updateOutputInternal(index: i, activationCount: nil, dw: &dw)
			}
		}
	}
	
	// Overrideable function to receive additional information when a successor attaches. Used by SignalJunction and SignalCapture to pass "onEnd" closures via the successor into the mutex. It shouldn't be possible to pass a parameter unless one is expected, so the default implementation is a `fatalError`.
	//
	// - parameter param: usually a closure.
	fileprivate func handleParamFromSuccessor(param: Any) {
		fatalError()
	}
	
	// Typical processors *don't* need to check their predecessors for a loop (only junctions do)
	fileprivate var needsPredecessorCheck: Bool {
		return false
	}
	
	// A successor connected
	//
	// - Parameters:
	//   - successor: must be a Signal<U>
	//   - param: see `handleParamFromSuccessor`
	//   - activationCount: initial activation count to use
	//   - dw: required
	// - Throws: a possible SignalBindError if there's a connection failure.
	fileprivate final func outputAddedSuccessorInternal(_ successor: AnyObject, param: Any?, activationCount: Int?, dw: inout DeferredWork) throws {
		var error: SignalBindError<OutputValue>? = nil
		runSuccesorAction {
			guard outputs.isEmpty || multipleOutputsPermitted else {
				error = SignalBindError<OutputValue>.duplicate(nil)
				return
			}
			guard let sccr = successor as? Signal<U> else { fatalError() }
			
			if needsPredecessorCheck, let predecessor = sccr.signalHandler as? SignalPredecessor {
				// Don't need to traverse sortedPreceeding (unsorted is fine for an ancestor check)
				for p in signal.preceeding {
					if p.base.predecessorsSuccessorInternal(loopCheck: predecessor.loopCheckValue) {
						// Throw an error here and trigger the preconditionFailure outside the lock (otherwise precondition catching tests may deadlock).
						error = SignalBindError<OutputValue>.loop
						dw.append { preconditionFailure("Signals must not be joined in a loop.") }
						return
					}
				}
			}
			
			outputs.append((destination: Weak(sccr), activationCount: nil))
			if let p = param {
				handleParamFromSuccessor(param: p)
			}
			
			if let ac = activationCount {
				if updateOutputInternal(index: outputs.count - 1, activationCount: ac, dw: &dw) {
					let count = self.signal.activationCount
					dw.append { self.endActivation(activationCount: count) }
				}
			}
		}
		if let e = error {
			throw e
		}
	}
	
	// Called when a successor is removed
	//
	// - Parameters:
	//   - successor: must be a Signal<U>
	//   - dw: required
	fileprivate final func outputRemovedSuccessorInternal(_ successor: AnyObject, dw: inout DeferredWork) {
		runSuccesorAction {
			guard let sccr = successor as? Signal<U> else { fatalError() }
			for i in outputs.indices.reversed() {
				let match: Bool
				if let d = outputs[i].destination.value, d === sccr {
					match = true
				} else {
					match = false
				}
				if match || outputs[i].destination.value == nil {
					if outputs[i].activationCount != nil {
						_ = updateOutputInternal(index: i, activationCount: nil, dw: &dw)
					}
					outputs.remove(at: i)
					
					if outputs.isEmpty {
						lastOutputRemovedInternal(dw: &dw)
					}
				}
			}
		}
	}
	
	/// Default handler should not be used
	fileprivate func nextHandlerInternal() -> (Result<OutputValue, SignalEnd>) -> Void {
		preconditionFailure()
	}
}

private extension Exec {
	var isImmediateNonDirect: Bool {
		if case .direct = self {
			return false
		}
		return type.isImmediateAlways
	}
}

private enum ActiveWithoutOutputs {
	case always
	case never
	case ifNonEmpty
	
	func active(valuesIsEmpty: Bool) -> Bool {
		switch self {
		case .always: return true
		case .never: return false
		case .ifNonEmpty where valuesIsEmpty: return false
		case .ifNonEmpty: return true
		}
	}
}

// Implementation of a processor that can output to multiple `Signal`s. Used by `continuous(initial:)`, `continuous`, `continuousWhileActive`, `playback`, `multicast`, `customActivation` and `preclosed`.
fileprivate final class SignalMultiProcessor<OutputValue>: SignalProcessor<OutputValue, OutputValue> {
	typealias Updater = (_ activationValues: inout Array<OutputValue>, _ preclosed: inout SignalEnd?, _ result: Result<OutputValue, SignalEnd>) -> (Array<OutputValue>, SignalEnd?)
	let updater: Updater?
	var activationValues: Array<OutputValue>
	var preclosed: SignalEnd?
	let userUpdated: Bool
	let activeWithoutOutputs: ActiveWithoutOutputs
	
	// Rather than using different subclasses for each of the "multi" `Signal`s, this one subclass is used for all. However, that requires a few different parameters to enable different behaviors.
	//
	// - Parameters:
	//   - signal: the predecessor signal
	//   - values: the initial activation values and error
	//   - userUpdated: whether the `updater` is user-supplied and needs value-copying to ensure thread-safety
	//   - activeWithoutOutputs: whether the handler should immediately activate
	//   - dw: required
	//   - context: where the `updater` will be run
	//   - updater: when a new signal is received, updates the cached activation values and error
	init(signal: Signal<OutputValue>, values: (Array<OutputValue>, SignalEnd?), userUpdated: Bool, activeWithoutOutputs: ActiveWithoutOutputs, dw: inout DeferredWork, context: Exec, updater: Updater?) {
		precondition((values.1 == nil && values.0.isEmpty) || updater != nil, "Non empty activation values requires always active.")
		self.updater = (userUpdated && context.isImmediateNonDirect) ? updater.map { u in { a, b, c in context.invokeSync { u(&a, &b, c) } } } : updater
		self.activationValues = values.0
		self.preclosed = values.1
		self.userUpdated = userUpdated
		self.activeWithoutOutputs = activeWithoutOutputs
		super.init(signal: signal, dw: &dw, context: context)
	}
	
	// Multicast and continuousWhileActive are not preactivated but all others are not.
	fileprivate override var activeWithoutOutputsInternal: Bool {
		assert(signal.mutex.unbalancedTryLock() == false)
		return activeWithoutOutputs.active(valuesIsEmpty: activationValues.isEmpty) && preclosed == nil
	}
	
	// Multiprocessor can handle multiple outputs
	fileprivate override var multipleOutputsPermitted: Bool {
		return true
	}
	
	// Any values or errors are sent on activation.
	//
	// - Parameters:
	//   - index: identifies the output
	//   - dw: required
	fileprivate final override func sendActivationToOutputInternal(index: Int, dw: inout DeferredWork) {
		guard !activationValues.isEmpty || preclosed != nil else { return }
		
		// Push as *not* activated (i.e. this is the activation)
		outputs[index].destination.value?.pushInternal(values: activationValues, end: preclosed, activated: false, dw: &dw)
	}
	
	// Multiprocessors are (usually – not multicast) preactivated and may cache the values or errors
	// - Returns: a function to use as the handler prior to activation
	fileprivate override func initialHandlerInternal() -> (Result<OutputValue, SignalEnd>) -> Void {
		assert(signal.mutex.unbalancedTryLock() == false)
		return { [weak self] r in
			guard let self = self else { return }
			_ = self.updater?(&self.activationValues, &self.preclosed, r)
		}
	}
	
	// On result, update any activation values.
	// - Returns: a function to use as the handler after activation
	fileprivate override func nextHandlerInternal() -> (Result<OutputValue, SignalEnd>) -> Void {
		assert(signal.mutex.unbalancedTryLock() == false)
		
		// There's a tricky point here: for multicast, we only want to send to outputs that were connected *before* we started sending this value; otherwise values could be sent to the wrong outputs following asychronous graph manipulations.
		// HOWEVER, when activation values exist, we must ensure that any output that was sent the *old* activation values will receive this new value *regardless* of when it connects.
		// To balance these needs, the outputs array is copied here for "multicast" but isn't copied until immediately after updating the `activationValues` in all other cases
		// There's an additional assumption: (updater == nil) is only possible for "multicast"
		var outs: OutputsArray? = updater != nil ? nil : outputs
		
		let activated = signal.delivery.isNormal
		
		// NOTE: the output signals in the `outs` array are already weakly retained
		return { [weak self] r in
			guard let self = self else { return }
			
			if let u = self.updater {
				if self.userUpdated {
					var values = [OutputValue]()
					var error: SignalEnd?
					
					// Mutably copy the activation values and error
					self.sync {
						values = self.activationValues
						error = self.preclosed
					}
					
					// Perform the update on the copies
					let expired = u(&values, &error, r)
					
					// Change the authoritative activation values and error
					self.sync {
						self.activationValues = values
						self.preclosed = error
						
						if outs == nil {
							outs = self.outputs
						}
					}
					
					// Make sure any reference to the originals is released *outside* the mutex
					withExtendedLifetime(expired) {}
				} else {
					var expired: (Array<OutputValue>, SignalEnd?)? = nil
					
					// Perform the update on the copies
					self.sync {
						expired = u(&self.activationValues, &self.preclosed, r)
						
						if outs == nil {
							outs = self.outputs
						}
					}
					
					// Make sure any expired content is released *outside* the mutex
					withExtendedLifetime(expired) {}
				}
			}
			
			// Send the result *before* changing the authoritative activation values and error
			let predecessor: Unmanaged<AnyObject>? = Unmanaged.passUnretained(self)
			for o in outs ?? [] {
				if let d = o.destination.value, let ac = o.activationCount {
					d.send(result: r, predecessor: predecessor, activationCount: ac, activated: activated)
				}
			}
		}
	}
}

// Implementation of a processor that combines SignalTransformerWithState and SignalMultiProcessor functionality into a single processor (avoiding the need for a clumsy state sharing arrangement if the two are separate).
fileprivate final class SignalReducer<OutputValue, State>: SignalProcessor<OutputValue, State> {
	typealias Initializer = (_ message: Result<OutputValue, SignalEnd>) -> Result<State?, SignalEnd>
	typealias Reducer = (_ state: State, _ message: Result<OutputValue, SignalEnd>) -> Result<State, SignalEnd>
	enum StateOrInitializer {
		case state(State)
		case initializer(Initializer)
	}
	let reducer: Reducer
	var stateOrInitializer: StateOrInitializer
	var end: SignalEnd?
	
	init(signal: Signal<OutputValue>, state: State, end: SignalEnd?, dw: inout DeferredWork, context: Exec, reducer: @escaping Reducer) {
		self.reducer = context.isImmediateNonDirect ? { a, b in context.invokeSync { reducer(a, b) } } : reducer
		self.end = end
		self.stateOrInitializer = .state(state)
		super.init(signal: signal, dw: &dw, context: context)
	}
	
	init(signal: Signal<OutputValue>, initializer: @escaping Initializer, end: SignalEnd?, dw: inout DeferredWork, context: Exec, reducer: @escaping Reducer) {
		self.reducer = context.isImmediateNonDirect ? { a, b in context.invokeSync { reducer(a, b) } } : reducer
		self.end = end
		self.stateOrInitializer = .initializer(initializer)
		super.init(signal: signal, dw: &dw, context: context)
	}
	
	fileprivate override var activeWithoutOutputsInternal: Bool {
		assert(signal.mutex.unbalancedTryLock() == false)
		return end == nil
	}
	
	fileprivate override var multipleOutputsPermitted: Bool {
		return true
	}
	
	fileprivate final override func sendActivationToOutputInternal(index: Int, dw: inout DeferredWork) {
		guard case .state(let state) = stateOrInitializer else { return }
		
		// Push as *not* activated (i.e. this is the activation)
		outputs[index].destination.value?.pushInternal(values: [state], end: end, activated: false, dw: &dw)
	}
	
	// Multiprocessors are (usually – not multicast) preactivated and may cache the values or errors
	// - Returns: a function to use as the handler prior to activation
	override func initialHandlerInternal() -> (Result<OutputValue, SignalEnd>) -> Void {
		assert(signal.mutex.unbalancedTryLock() == false)
		return { [weak self] r in
			guard let self = self else { return }
			
			// Copy the state under the mutex
			let stateOrInitializer = self.sync { self.stateOrInitializer }
			
			let next: Result<State, SignalEnd>
			switch stateOrInitializer {
			case .state(let state): next = self.reducer(state, r)
			case .initializer(let initializer):
				switch initializer(r) {
				case .success(nil): return
				case .success(let s?): next = .success(s)
				case .failure(let e): next = .failure(e)
				}
			}

			// Apply the change to the authoritative version under the mutex
			self.sync {
				switch next {
				case .success(let v): self.stateOrInitializer = .state(v)
				case .failure(let e): self.end = e
				}
			}
			
			// Ensure any old references are released outside the mutex
			withExtendedLifetime(stateOrInitializer) {}
		}
	}
	
	// On result, update any activation values.
	// - Returns: a function to use as the handler after activation
	fileprivate override func nextHandlerInternal() -> (Result<OutputValue, SignalEnd>) -> Void {
		assert(signal.mutex.unbalancedTryLock() == false)
		
		let activated = signal.delivery.isNormal
		return { [weak self] r in
			guard let self = self else { return }
			
			// Copy the state under the mutex
			let stateOrInitializer = self.sync { self.stateOrInitializer }
			
			let next: Result<State, SignalEnd>
			switch stateOrInitializer {
			case .state(let state): next = self.reducer(state, r)
			case .initializer(let initializer):
				switch initializer(r) {
				case .success(nil): return
				case .success(let s?): next = .success(s)
				case .failure(let e): next = .failure(e)
				}
			}

			// Apply the change to the authoritative version under the mutex
			var outputs: OutputsArray = []
			var result = Signal<State>.Result.failure(.complete)
			self.sync {
				switch next {
				case .success(let v):
					self.stateOrInitializer = .state(v)
					result = .success(v)
				case .failure(let e):
					self.end = e
					result = .failure(e)
				}
				outputs = self.outputs
			}
			
			// Ensure any old references are released outside the mutex
			withExtendedLifetime(stateOrInitializer) {}
			
			let predecessor: Unmanaged<AnyObject>? = Unmanaged.passUnretained(self)
			for o in outputs {
				if let d = o.destination.value, let ac = o.activationCount {
					d.send(result: result, predecessor: predecessor, activationCount: ac, activated: activated)
				}
			}
		}
	}
}

// A handler which starts receiving `Signal`s immediately and caches them until an output connects
fileprivate final class SignalCacheUntilActive<OutputValue>: SignalProcessor<OutputValue, OutputValue> {
	var cachedValues: Array<OutputValue>
	var cachedEnd: SignalEnd? = nil
	
	// Construct a SignalCacheUntilActive handler
	//
	// - Parameters:
	//   - signal: the predecessor signal
	//   - dw: required
	init(signal: Signal<OutputValue>, precached: [OutputValue]?, dw: inout DeferredWork) {
		cachedValues = precached ?? []
		super.init(signal: signal, dw: &dw, context: .direct)
	}
	
	// Is always active
	fileprivate override var activeWithoutOutputsInternal: Bool {
		assert(signal.mutex.unbalancedTryLock() == false)
		return true
	}
	
	// Sends the cached values when an output connects
	//
	// - Parameters:
	//   - index: identifies the output
	//   - dw: required
	fileprivate final override func sendActivationToOutputInternal(index: Int, dw: inout DeferredWork) {
		guard !cachedValues.isEmpty || cachedEnd != nil else { return }
		
		// Push as *not* activated (i.e. this is the activation)
		outputs[index].destination.value?.pushInternal(values: cachedValues, end: cachedEnd, activated: false, dw: &dw)
	}
	
	/// Caches values prior to an output connecting
	// - Returns: a function to use as the handler prior to activation
	override func initialHandlerInternal() -> (Result<OutputValue, SignalEnd>) -> Void {
		assert(signal.mutex.unbalancedTryLock() == false)
		return { [weak self] r in
			switch r {
			case .success(let v): self?.cachedValues.append(v)
			case .failure(let e): self?.cachedEnd = e
			}
		}
	}
	
	// Clears the cache immediately after an output connects
	//
	// - Parameter dw: required
	fileprivate override func firstOutputActivatedInternal(dw: inout DeferredWork) {
		let tuple = (self.cachedValues, self.cachedEnd)
		self.cachedValues = []
		self.cachedEnd = nil
		dw.append { withExtendedLifetime(tuple) {} }
	}
	
	// Once an output is connected, the handler function is a basic passthrough
	// - Returns: a function to use as the handler after activation
	override func nextHandlerInternal() -> (Result<OutputValue, SignalEnd>) -> Void {
		return SignalProcessor.simpleNext(processor: self) { r in r }
	}
}

// A transformer applies a user transformation to any signal. It's the typical "between two `Signal`s" handler.
fileprivate final class SignalTransformer<OutputValue, U>: SignalProcessor<OutputValue, U> {
	typealias UserProcessorType = (Result<OutputValue, SignalEnd>) -> Signal<U>.Next
	let userProcessor: UserProcessorType
	
	// Constructs a `SignalTransformer`
	//
	// - Parameters:
	//   - signal: the predecessor signal
	//   - dw: required
	//   - context: where the `handler` will be invoked
	//   - processor: the user supplied processing function
	init(signal: Signal<OutputValue>, dw: inout DeferredWork, context: Exec, _ processor: @escaping UserProcessorType) {
		self.userProcessor = context.isImmediateNonDirect ? { a in context.invokeSync { processor(a) } } : processor
		super.init(signal: signal, dw: &dw, context: context)
	}

	/// Invoke the user handler and block if the `next` gains an additional reference count in the process.
	// - Returns: a function to use as the handler after activation
	override func nextHandlerInternal() -> (Result<OutputValue, SignalEnd>) -> Void {
		assert(signal.mutex.unbalancedTryLock() == false)
		guard let output = outputs.first, let outputSignal = output.destination.value, let ac = output.activationCount else { return initialHandlerInternal() }
		let predecessor: Unmanaged<AnyObject>? = Unmanaged.passUnretained(self)
		let activated = signal.delivery.isNormal
		return { [userProcessor, weak outputSignal] r in
			let transformedResult = userProcessor(r)

			switch transformedResult {
			case .none: break
			case .single(let r):
				if let os = outputSignal {
					os.send(result: r, predecessor: predecessor, activationCount: ac, activated: activated)
				}
			case .array(let a):
				if let os = outputSignal {
					for r in a {
						os.send(result: r, predecessor: predecessor, activationCount: ac, activated: activated)
					}
				}
			}
		}
	}
}

/// Same as `SignalTransformer` plus a `state` value that is passed `inout` to the handler each time so state can be safely retained between invocations. This `state` value is reset to its `initialState` if the signal graph is deactivated.
fileprivate final class SignalTransformerWithState<OutputValue, U, S>: SignalProcessor<OutputValue, U> {
	typealias UserProcessorType = (inout S, Result<OutputValue, SignalEnd>) -> Signal<U>.Next
	let userProcessor: UserProcessorType
	let initialState: S
	
	// Constructs a `SignalTransformer`
	//
	// - Parameters:
	//   - signal: the predecessor signal
	//   - initialState: initial value to use for the "state" passed to the processing handler on each iteration
	//   - dw: required
	//   - context: where the `handler` will be invoked
	//   - processor: the user supplied processing function
	init(signal: Signal<OutputValue>, initialState: S, dw: inout DeferredWork, context: Exec, _ processor: @escaping (inout S, Result<OutputValue, SignalEnd>) -> Signal<U>.Next) {
		self.userProcessor = context.isImmediateNonDirect ? { a, b in context.invokeSync { processor(&a, b) } } : processor
		self.initialState = initialState
		super.init(signal: signal, dw: &dw, context: context)
	}
	
	// Invoke the user handler and block if the `next` gains an additional reference count in the process.
	// - Returns: a function to use as the handler after activation
	override func nextHandlerInternal() -> (Result<OutputValue, SignalEnd>) -> Void {
		assert(signal.mutex.unbalancedTryLock() == false)
		guard let output = outputs.first, let outputSignal = output.destination.value, let ac = output.activationCount else { return initialHandlerInternal() }
		let activated = signal.delivery.isNormal
		let predecessor: Unmanaged<AnyObject>? = Unmanaged.passUnretained(self)
		
		/// Every time the handler is recreated, the `state` value is initialized from the `initialState`.
		var state = initialState
		
		return { [userProcessor, weak outputSignal] r in
			let transformedResult = userProcessor(&state, r)

			switch transformedResult {
			case .none: break
			case .single(let r):
				if let os = outputSignal {
					os.send(result: r, predecessor: predecessor, activationCount: ac, activated: activated)
				}
			case .array(let a):
				if let os = outputSignal {
					for r in a {
						os.send(result: r, predecessor: predecessor, activationCount: ac, activated: activated)
					}
				}
			}
		}
	}
}

/// A processor used by `combine(...)` to transform incoming `Signal`s into the "combine" type. The handler function is typically just a wrap of the preceeding `Result` in a `EitherResultX.resultY`. Other than that, it's a basic passthrough transformer that returns `false` to `successorsShareMutex`.
fileprivate final class SignalCombiner<OutputValue, U>: SignalProcessor<OutputValue, U> {
	let combineProcessor: (Result<OutputValue, SignalEnd>) -> U
	
	// Constructs a `SignalCombiner`
	//
	// - Parameters:
	//   - signal: the predecessor signal
	//   - dw: required
	//   - context: where the `handler` will be invoked
	//   - processor: the user supplied processing function
	init(signal: Signal<OutputValue>, dw: inout DeferredWork, context: Exec, processor: @escaping (Result<OutputValue, SignalEnd>) -> U) {
		self.combineProcessor = context.isImmediateNonDirect ? { a in context.invokeSync { processor(a) } } : processor
		super.init(signal: signal, dw: &dw, context: context)
	}
	
	/// Only one predecessor in a multi-predecessor scenario can share its mutex.
	fileprivate override var successorsShareMutex: Bool {
		return false
	}
	
	/// Simple application of the handler
	// - Returns: a function to use as the handler after activation
	fileprivate override func nextHandlerInternal() -> (Result<OutputValue, SignalEnd>) -> Void {
		return SignalProcessor.simpleNext(processor: self) { [combineProcessor] r in Result<U, SignalEnd>.success(combineProcessor(r)) }
	}
}

// Common implementation of bind behavior used by `SignalJunction` and `SignalCapture`.
//
// - Parameters:
//   - processor: the `SignalJuction` or `SignalCapture`
//   - disconnect: receiver for a new `SignalInput` when the junction is disconnected.
//   - to: destination of the bind
//   - optionalEndHandler: passed as the `param` to `addPreceedingInternal`
// - Throws: and `addPreceedingInternal` error or other `SignalBindError<OutputValue>.cancelled` errors if weak properties can't strongified.
fileprivate func bindFunction<OutputValue>(processor: SignalProcessor<OutputValue, OutputValue>, disconnect: () -> SignalInput<OutputValue>?, to input: SignalInput<OutputValue>, optionalEndHandler: Any?) throws {
	var dw = DeferredWork()
	defer { dw.runWork() }
	assert(!(input is SignalMultiInput<OutputValue>))
	if let nextSignal = input.signal {
		try nextSignal.mutex.sync { () throws -> () in
			guard input.activationCount == nextSignal.activationCount else {
				throw SignalBindError<OutputValue>.cancelled
			}
			nextSignal.removeAllPreceedingInternal(dw: &dw)
			do {
				try nextSignal.addPreceedingInternal(processor, param: optionalEndHandler, dw: &dw)
			} catch {
				switch error {
				case SignalBindError<OutputValue>.duplicate:
					throw SignalBindError<OutputValue>.duplicate(SignalInput<OutputValue>(signal: nextSignal, activationCount: nextSignal.activationCount))
				default: throw error
				}
			}
		}
	} else {
		throw SignalBindError<OutputValue>.cancelled
	}
}

/// A junction is a point in the signal graph that can be disconnected and reconnected at any time. Constructed implicitly by calling `bind(to:...)` or explicitly by calling `junction()` on an `Signal`.
class SignalJunction<OutputValue>: SignalProcessor<OutputValue, OutputValue>, Lifetime {
	typealias Handler = (SignalJunction<OutputValue>, SignalEnd, SignalInput<OutputValue>) -> ()
	private var disconnectOnEnd: Handler? = nil
	
	// Constructs a "bind" handler
	//
	// - Parameters:
	//   - signal: the predecessor signal
	//   - dw: required
	init(signal: Signal<OutputValue>, dw: inout DeferredWork) {
		super.init(signal: signal, dw: &dw, context: .direct)
	}
	
	// Can't share mutex since successor may swap between different graphs
	fileprivate override var successorsShareMutex: Bool {
		return false
	}
	
	// Typical processors *don't* need to check their predecessors for a loop (only junctions do)
	fileprivate override var needsPredecessorCheck: Bool {
		return true
	}
	
	// If a `disconnectOnEnd` handler is configured, then `failure` signals are not sent through the junction. Instead, the junction is disconnected and the `disconnectOnEnd` function is given an opportunity to handle the `SignalJunction` (`self`) and `SignalInput` (from the `disconnect`).
	// - Returns: a function to use as the handler after activation
	fileprivate override func nextHandlerInternal() -> (Result<OutputValue, SignalEnd>) -> Void {
		assert(signal.mutex.unbalancedTryLock() == false)
		guard let output = outputs.first, let outputSignal = output.destination.value, let ac = output.activationCount else { return initialHandlerInternal() }
		let activated = signal.delivery.isNormal
		let predecessor: Unmanaged<AnyObject>? = Unmanaged.passUnretained(self)
		let disconnectAction = disconnectOnEnd
		return { [weak outputSignal, weak self] r in
			if let d = disconnectAction, case .failure(let e) = r, let s = self, let input = s.disconnect() {
				d(s, e, input)
			} else {
				_ = outputSignal?.send(result: r, predecessor: predecessor, activationCount: ac, activated: activated)
			}
		}
	}
	
	/// Disconnects the succeeding `Signal` (if any).
	///
	/// - returns: the new `SignalInput` for the succeeding `Signal` (if any `Signal` was connected) otherwise nil. If the `SignalInput` value is non-nil and is released, the succeeding `Signal` will be closed.
	func disconnect() -> SignalInput<OutputValue>? {
		var previous: SignalJunction<OutputValue>.Handler? = nil
		let result = sync { () -> Signal<OutputValue>? in
			previous = disconnectOnEnd
			return outputs.first?.destination.value
		}?.newInput(forDisconnector: self)
		withExtendedLifetime(previous) {}
		return result
	}
	
	/// Implementation of `Lifetime` simply invokes a `disconnect()`
	func cancel() {
		_ = disconnect()
	}
	
	// Implementation of `Lifetime` requires `cancel` is called in the `deinit`
	deinit {
		cancel()
	}
	
	// The `disconnectOnEnd` needs to be set inside the mutex, if-and-only-if a successor connects successfully. To allow this to work, the desired `disconnectOnEnd` function is passed into this function via the `outputAddedSuccessorInternal` called from `addPreceedingInternal` in the `bindFunction`.
	//
	// - Parameter param: received through `addPreceedingInternal` – should be the onEnd handler from `bind(to:resend:onEnd:)`
	fileprivate override func handleParamFromSuccessor(param: Any) {
		if let p = param as? SignalJunction<OutputValue>.Handler {
			disconnectOnEnd = p
		}
	}
	
	/// Invokes `disconnect` on self before attemping to bind this junction to a successor, identified by its `SignalInput`.
	///
	/// - Parameter to: used to identify an `Signal`. If this `SignalInput` is not the active input for its `Signal`, then no bind attempt will occur (although this `SignalJunction` will still be `disconnect`ed.
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	func bind<U: SignalInputInterface>(to: U) throws where U.InputValue == OutputValue {
		try bindFunction(processor: self, disconnect: self.disconnect, to: to.input.singleInput(), optionalEndHandler: nil)
	}
	
	/// Invokes `disconnect` on self before attemping to bind this junction to a successor, identified by its `SignalInput`.
	///
	/// - Parameters:
	///   - to: used to identify an `Signal`. If this `SignalInput` is not the active input for its `Signal`, then no bind attempt will occur (although this `SignalJunction` will still be `disconnect`ed.
	///   - onEnd: if nil, errors from self will be passed through to `to`'s `Signal` normally. If non-nil, errors will not be sent, instead, the `Signal` will be disconnected and the `onEnd` function will be invoked with the disconnected `SignalJunction` and the input created by calling `disconnect` on it.
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	func bind<U: SignalInputInterface>(to: U, onEnd: @escaping SignalJunction<OutputValue>.Handler) throws where U.InputValue == OutputValue {
		try bindFunction(processor: self, disconnect: self.disconnect, to: to.input.singleInput(), optionalEndHandler: onEnd)
	}
	
	/// Invokes `disconnect` on self before attemping to bind this junction to a successor, identified by its `SignalInput`.
	///
	/// - Parameter to: used to identify an `Signal`. If this `SignalInput` is not the active input for its `Signal`, then no bind attempt will occur (although this `SignalJunction` will still be `disconnect`ed.
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	func bind(to: SignalMergedInput<OutputValue>, closePropagation: SignalEndPropagation, removeOnDeactivate: Bool = false) throws {
		try bindFunction(processor: self, disconnect: self.disconnect, to: to.singleInput(closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate), optionalEndHandler: nil)
	}
	
	/// Invokes `disconnect` on self before attemping to bind this junction to a successor, identified by its `SignalInput`.
	///
	/// - Parameters:
	///   - to: used to identify an `Signal`. If this `SignalInput` is not the active input for its `Signal`, then no bind attempt will occur (although this `SignalJunction` will still be `disconnect`ed.
	///   - onEnd: if nil, errors from self will be passed through to `to`'s `Signal` normally. If non-nil, errors will not be sent, instead, the `Signal` will be disconnected and the `onEnd` function will be invoked with the disconnected `SignalJunction` and the input created by calling `disconnect` on it.
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	func bind(to: SignalMergedInput<OutputValue>, closePropagation: SignalEndPropagation, removeOnDeactivate: Bool = false, onEnd: @escaping (SignalJunction<OutputValue>, Error, SignalInput<OutputValue>) -> ()) throws {
		try bindFunction(processor: self, disconnect: self.disconnect, to: to.singleInput(closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate), optionalEndHandler: onEnd)
	}
	
	/// Disconnect and reconnect to the same input, to deliberately deactivate and reactivate. If `disconnect` returns `nil`, no further action will be taken. Any error attempting to reconnect will be sent to the input.
	func rebind() {
		if let input = disconnect() {
			do {
				try bind(to: input)
			} catch {
				input.send(result: .failure(.other(error)))
			}
		}
	}
	
	/// Disconnect and reconnect to the same input, to deliberately deactivate and reactivate. If `disconnect` returns `nil`, no further action will be taken. Any error attempting to reconnect will be sent to the input.
	///
	/// - Parameter onEnd: passed through to `bind`
	func rebind(onEnd: @escaping SignalJunction<OutputValue>.Handler) {
		if let input = disconnect() {
			do {
				try bind(to: input, onEnd: onEnd)
			} catch {
				input.send(result: .failure(.other(error)))
			}
		}
	}
}

// Used to hold the handler function for onEnd behavior for `SignalCapture`
private struct SignalCaptureParam<OutputValue> {
	let sendAsNormal: Bool
	let disconnectOnEnd: SignalCapture<OutputValue>.Handler?
}

/// A "capture" handler separates activation signals (those sent immediately on connection) from normal signals. This allows activation signals to be handled separately or removed from the stream entirely.
/// NOTE: this handler *blocks* delivery between capture and connecting to the output. Signals sent in the meantime are queued.
final class SignalCapture<OutputValue>: SignalProcessor<OutputValue, OutputValue>, Lifetime {
	struct FailedToEmit: Error {}
	typealias Handler = (SignalCapture<OutputValue>, SignalEnd, SignalInput<OutputValue>) -> ()

	private var sendAsNormal: Bool = false
	private var capturedEnd: SignalEnd? = nil
	private var capturedValues: [OutputValue] = []
	private var blockActivationCount: Int = 0
	private var disconnectOnEnd: SignalCapture<OutputValue>.Handler? = nil
	
	// Constructs a capture handler
	//
	// - Parameters:
	//   - signal: the predecessor signal
	//   - dw: required
	fileprivate init(signal: Signal<OutputValue>, dw: inout DeferredWork) {
		super.init(signal: signal, dw: &dw, context: .direct)
	}
	
	// Once an output is connected, `SignalCapture` becomes a no-special-behaviors passthrough handler.
	fileprivate override var activeWithoutOutputsInternal: Bool {
		assert(super.signal.mutex.unbalancedTryLock() == false)
		return outputs.count > 0 ? false : true
	}
	
	/// Accessor for any captured values. Activation signals captured can be accessed through this property between construction and activating an output (after that point, capture signals are cleared).
	///
	/// - Returns: and array of values (which may be empty) and an optional error, which are the signals received during activation.
	var values: [OutputValue] {
		return sync {
			return capturedValues
		}
	}
	
	/// Accessor for any captured error. Activation signals captured can be accessed through this property between construction and activating an output (after that point, capture signals are cleared).
	///
	/// - Returns: and array of values (which may be empty) and an optional error, which are the signals received during activation.
	var end: SignalEnd? {
		return sync {
			return capturedEnd
		}
	}

	/// Accessor for the last captured value, if any.
	///
	/// - Returns: the last captured value
	/// - Throws: if no captured value but captured end, the `SignalEnd` is thrown. If neither value nor end, `SignalCapture.FailedToEmit` is thrown.
	func get() throws -> OutputValue {
		return try sync {
			if let last = capturedValues.last {
				return last
			} else if let end = capturedEnd {
				throw end
			} else {
				throw FailedToEmit()
			}
		}
	}

	/// Accessor for the last captured value, if any.
	///
	/// - Returns: the last captured value
	/// - Throws: if no captured value but captured end, the `SignalEnd` is thrown. If neither value nor end, `SignalCapture.FailedToEmit` is thrown.
	func peek() -> OutputValue? {
		return sync { capturedValues.last }
	}
	
	// Since this node operates as a junction, it cannot share mutex
	fileprivate override var successorsShareMutex: Bool {
		return false
	}
	
	// Typical processors *don't* need to check their predecessors for a loop (only junctions do)
	fileprivate override var needsPredecessorCheck: Bool {
		return true
	}
	
	// The initial behavior is to capture
	// - Returns: a function to use as the handler prior to activation
	fileprivate override func initialHandlerInternal() -> (Result<OutputValue, SignalEnd>) -> Void {
		guard outputs.isEmpty else { return { r in } }
		
		assert(super.signal.mutex.unbalancedTryLock() == false)
		capturedEnd = nil
		capturedValues = []
		return { [weak self] r in
			guard let s = self else { return }
			switch r {
			case .success(let v): s.capturedValues.append(v)
			case .failure(let e): s.capturedEnd = e
			}
		}
	}
	
	// After the initial "capture" phase, the queue is blocked, causing any non-activation signals to queue.
	// - Parameter dw: required
	fileprivate override func handleSynchronousToNormalInternal(dw: inout DeferredWork) {
		if outputs.isEmpty {
			let (vs, err) = super.signal.pullQueuedSynchronousInternal()
			capturedValues.append(contentsOf: vs)
			if let e = err {
				capturedEnd = e
			}
			super.signal.blockInternal()
			blockActivationCount = super.signal.activationCount
		}
	}
	
	// If this handler disconnected, then it reactivates and reverts to being a "capture".
	// - Parameter dw: required
	fileprivate override func lastOutputRemovedInternal(dw: inout DeferredWork) {
		guard super.signal.delivery.isDisabled else { return }
		
		// While a capture has an output connected – even an inactive output – it doesn't self-activate. When the last output is removed, we need to re-activate.
		dw.append { [handler] in withExtendedLifetime(handler) {} }
		handler = initialHandlerInternal()
		if activateInternal(dw: &dw) {
			let count = super.signal.activationCount
			dw.append { self.endActivation(activationCount: count) }
		}
	}
	
	// When an output activates, if `sendAsNormal` is true, the new output is sent any captured values. In all cases, the captured values are cleared at this point and the queue is unblocked.
	// - Parameter dw: required
	fileprivate override func firstOutputActivatedInternal(dw: inout DeferredWork) {
		if sendAsNormal, let output = outputs.first, let outputSignal = output.destination.value, let ac = output.activationCount {
			// Don't deliver errors if `disconnectOnEnd` is set
			if let d = disconnectOnEnd, let e = capturedEnd {
				// NOTE: we use the successors "internal" functon here since this is always called from successor's `updateActivationInternal` function
				// Push as *activated* (i.e. this is deferred from activation to normal)
				outputSignal.pushInternal(values: capturedValues, end: nil, activated: true, dw: &dw)
				dw.append {
					// We need to use a specialized version of disconnect that ensures another disconnect hasn't happened in the meantime. Since it's theoretically possible that this handler could be disconnected and reconnected in the meantime (or deactivated and reactivated) we need to check the output and activationCount to ensure everything's still the same.
					var previous: SignalCapture<OutputValue>.Handler? = nil
					let input = self.sync { () -> Signal<OutputValue>? in
						if let o = self.outputs.first, let os = o.destination.value, os === outputSignal, ac == o.activationCount {
							previous = self.disconnectOnEnd
							return os
						} else {
							return nil
						}
					}?.newInput(forDisconnector: self)
					withExtendedLifetime(previous) {}
					if let i = input {
						d(self, e, i)
					}
				}
			} else {
				// NOTE: we use the successors "internal" functon here since this is always called from successor's `updateActivationInternal` function
				// Push as *activated* (i.e. this is deferred from activation to normal)
				outputSignal.pushInternal(values: capturedValues, end: capturedEnd, activated: true, dw: &dw)
			}
		}
		super.signal.unblockInternal(activationCountAtBlock: blockActivationCount)
		super.signal.resumeIfPossibleInternal(dw: &dw)
		let tuple = (self.capturedValues, self.capturedEnd)
		self.capturedValues = []
		self.capturedEnd = nil
		dw.append { withExtendedLifetime(tuple) {} }
	}
	
	// Like a `SignalJunction`, a capture can respond to an error by disconnecting instead of delivering.
	// - Returns: a function to use as the handler after activation
	fileprivate override func nextHandlerInternal() -> (Result<OutputValue, SignalEnd>) -> Void {
		assert(super.signal.mutex.unbalancedTryLock() == false)
		guard let output = outputs.first, let outputSignal = output.destination.value, let ac = output.activationCount else { return initialHandlerInternal() }
		let activated = super.signal.delivery.isNormal
		let predecessor: Unmanaged<AnyObject>? = Unmanaged.passUnretained(self)
		let disconnectAction = disconnectOnEnd
		return { [weak outputSignal, weak self] r in
			if let d = disconnectAction, case .failure(let e) = r, let s = self, let input = s.disconnect() {
				d(s, e, input)
			} else {
				_ = outputSignal?.send(result: r, predecessor: predecessor, activationCount: ac, activated: activated)
			}
		}
	}
	
	/// Disconnects the succeeding `Signal` (if any).
	///
	/// - returns: the new `SignalInput` for the succeeding `Signal` (if any `Signal` was connected) otherwise nil. If the `SignalInput` value is non-nil and is released, the succeeding `Signal` will be closed.
	func disconnect() -> SignalInput<OutputValue>? {
		var previous: SignalCapture<OutputValue>.Handler? = nil
		let result = sync { () -> Signal<OutputValue>? in
			previous = disconnectOnEnd
			return outputs.first?.destination.value
		}?.newInput(forDisconnector: self)
		withExtendedLifetime(previous) {}
		return result
	}
	
	/// Implementation of `Lifetime` simply invokes a `disconnect()`
	func cancel() {
		_ = self.disconnect()
	}
	
	// Implementation of `Lifetime` requires `cancel` is called in the `deinit`
	deinit {
		cancel()
	}
	
	// The `disconnectOnEnd` needs to be set inside the mutex, if-and-only-if a successor connects successfully. To allow this to work, the desired `disconnectOnEnd` function is passed into this function via the `outputAddedSuccessorInternal` called from `addPreceedingInternal` in the `bindFunction`.
	//
	// - Parameter param: received through `addPreceedingInternal` – should be the onEnd handler from `bind(to:resend:onEnd:)`
	fileprivate override func handleParamFromSuccessor(param: Any) {
		if let p = param as? SignalCaptureParam<OutputValue> {
			disconnectOnEnd = p.disconnectOnEnd
			sendAsNormal = p.sendAsNormal
		}
	}
	
	/// Invokes `disconnect` on self before attemping to bind this junction to a successor, identified by its `SignalInput`.
	///
	/// - Parameters:
	///   - to: used to identify an `Signal`. If this `SignalInput` is not the active input for its `Signal`, then no bind attempt will occur (although this `SignalCapture` will still be `disconnect`ed.
	///   - resend: if true, captured values are sent to the new output as the first values in the stream, otherwise, captured values are not sent (default is false)
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	func bind<U: SignalInputInterface>(to: U, resend: Bool = false) throws where U.InputValue == OutputValue {
		let param = SignalCaptureParam<OutputValue>(sendAsNormal: resend, disconnectOnEnd: nil)
		try bindFunction(processor: self, disconnect: self.disconnect, to: to.input.singleInput(), optionalEndHandler: param)
	}
	
	/// Invokes `disconnect` on self before attemping to bind this junction to a successor, identified by its `SignalInput`.
	///
	/// - Parameters:
	///   - to: used to identify an `Signal`. If this `SignalInput` is not the active input for its `Signal`, then no bind attempt will occur (although this `SignalCapture` will still be `disconnect`ed.
	///   - resend: if true, captured values are sent to the new output as the first values in the stream, otherwise, captured values are not sent (default is false)
	///   - onEnd: if nil, errors from self will be passed through to `to`'s `Signal` normally. If non-nil, errors will not be sent, instead, the `Signal` will be disconnected and the `onEnd` function will be invoked with the disconnected `SignalCapture` and the input created by calling `disconnect` on it.
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	func bind<U: SignalInputInterface>(to: U, resend: Bool = false, onEnd: @escaping SignalCapture<OutputValue>.Handler) throws where U.InputValue == OutputValue {
		let param = SignalCaptureParam<OutputValue>(sendAsNormal: resend, disconnectOnEnd: onEnd)
		try bindFunction(processor: self, disconnect: self.disconnect, to: to.input.singleInput(), optionalEndHandler: param)
	}
	
	/// Invokes `disconnect` on self before attemping to bind this junction to a successor, identified by its `SignalInput`.
	///
	/// - Parameters:
	///   - to: used to identify an `Signal`. If this `SignalInput` is not the active input for its `Signal`, then no bind attempt will occur (although this `SignalCapture` will still be `disconnect`ed.
	///   - resend: if true, captured values are sent to the new output as the first values in the stream, otherwise, captured values are not sent (default is false)
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	func bind(to: SignalMergedInput<OutputValue>, resend: Bool = false, closePropagation: SignalEndPropagation, removeOnDeactivate: Bool) throws {
		let param = SignalCaptureParam<OutputValue>(sendAsNormal: resend, disconnectOnEnd: nil)
		try bindFunction(processor: self, disconnect: self.disconnect, to: to.singleInput(closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate), optionalEndHandler: param)
	}
	
	/// Invokes `disconnect` on self before attemping to bind this junction to a successor, identified by its `SignalInput`.
	///
	/// - Parameters:
	///   - to: used to identify an `Signal`. If this `SignalInput` is not the active input for its `Signal`, then no bind attempt will occur (although this `SignalCapture` will still be `disconnect`ed.
	///   - resend: if true, captured values are sent to the new output as the first values in the stream, otherwise, captured values are not sent (default is false)
	///   - onEnd: if nil, errors from self will be passed through to `to`'s `Signal` normally. If non-nil, errors will not be sent, instead, the `Signal` will be disconnected and the `onEnd` function will be invoked with the disconnected `SignalCapture` and the input created by calling `disconnect` on it.
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	func bind(to: SignalMergedInput<OutputValue>, resend: Bool = false, closePropagation: SignalEndPropagation, removeOnDeactivate: Bool, onEnd: @escaping SignalCapture<OutputValue>.Handler) throws {
		let param = SignalCaptureParam<OutputValue>(sendAsNormal: resend, disconnectOnEnd: onEnd)
		try bindFunction(processor: self, disconnect: self.disconnect, to: to.singleInput(closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate), optionalEndHandler: param)
	}
	
	/// Appends a `Signal` that will resume the stream interrupted by the `SignalCapture`.
	///
	/// - Parameters:
	///   - resend: if true, captured values are sent to the new output as the first values in the stream, otherwise, captured values are not sent (default is false)
	/// - returns: the created `Signal`
	func resume(resend: Bool = false) -> Signal<OutputValue> {
		let (input, output) = Signal<OutputValue>.create()
		// This could be `duplicate` but that's a precondition failure
		try! bind(to: input, resend: resend)
		return output
	}
	
	/// Appends a `Signal` that will resume the stream interrupted by the `SignalCapture`.
	///
	/// - Parameters:
	///   - resend: if true, captured values are sent to the new output as the first values in the stream, otherwise, captured values are not sent (default is false)
	///   - onEnd: if nil, errors from self will be passed through to `to`'s `Signal` normally. If non-nil, errors will not be sent, instead, the `Signal` will be disconnected and the `onEnd` function will be invoked with the disconnected `SignalCapture` and the input created by calling `disconnect` on it.
	/// - returns: the created `SignalOutput`
	func resume(resend: Bool = false, onEnd: @escaping SignalCapture<OutputValue>.Handler) -> Signal<OutputValue> {
		let (input, output) = Signal<OutputValue>.create()
		// This could be `duplicate` but that's a precondition failure
		try! bind(to: input, resend: resend, onEnd: onEnd)
		return output
	}
}

/// When an input to a `SignalMergedInput` sends an error, this behavior determines the effect on the merge set and its output
///
/// - none: the input signal is removed from the merge set but the error is not propagated through to the output.
/// - errors: if the error is not an instance of `SignalComplete`, then the error is propagated through to the output. This is the default.
/// - close: any error, including `SignalEnd.complete`, is progagated through to the output
enum SignalEndPropagation {
	case none
	case errors
	case all
	
	/// Determines whether the error should be sent or if the input should be removed instead.
	///
	/// - Parameter error: sent from one of the inputs
	/// - Returns: if `false`, the input that sent the error should be removed but the error should not be sent. If `true`, the error should be sent to the `SignalMergedInput`'s output (whether or not the input is removed is then determined by the `removeOnDeactivate` property).
	func shouldPropagateEnd(_ end: SignalEnd) -> Bool {
		switch self {
		case .none: return false
		case .errors: return end.isOther
		case .all: return true
		}
	}
}

// A handler that apples the different rules required for inputs to a `SignalMergedInput`.
fileprivate class SignalMultiInputProcessor<InputValue>: SignalProcessor<InputValue, InputValue> {
	let closePropagation: SignalEndPropagation
	let removeOnDeactivate: Bool
	
	// The input is added here to keep it alive at least as long as there are active inputs. You can `cancel` an input to remove all active inputs.
	let multiInput: SignalMultiInput<InputValue>
	
	// Constructs a `SignalMultiInputProcessor`
	//
	// - Parameters:
	//   - signal: destination of the `SignalMergedInput`
	//   - closePropagation: rules to use when this processor handles an error
	//   - removeOnDeactivate: behavior to apply on deactivate
	//   - mergedInput: the mergedInput that manages this processor
	//   - dw: required
	init(signal: Signal<InputValue>, multiInput: SignalMultiInput<InputValue>, closePropagation: SignalEndPropagation, removeOnDeactivate: Bool, dw: inout DeferredWork) {
		self.multiInput = multiInput
		self.closePropagation = closePropagation
		self.removeOnDeactivate = removeOnDeactivate
		super.init(signal: signal, dw: &dw, context: .direct)
	}
	
	// Can't share mutex since predecessor may swap between different graphs
	fileprivate override var successorsShareMutex: Bool {
		return false
	}
	
	// If `removeOnDeactivate` is true, then deactivating this `Signal` removes it from the set
	//
	// - parameter dw: required
	fileprivate override func lastOutputDeactivatedInternal(dw: inout DeferredWork) {
		if removeOnDeactivate {
			guard let output = outputs.first, let os = output.destination.value, let ac = output.activationCount else { return }
			os.mutex.sync {
				guard os.activationCount == ac else { return }
				_ = os.removePreceedingWithoutInterruptionInternal(self, dw: &dw)
			}
		}
	}
	
	// The handler is largely a passthrough but allso applies `sourceClosesOutput` logic – removing error sending signals that don't close the output.
	// - Returns: a function to use as the handler after activation
	fileprivate override func nextHandlerInternal() -> (Result<InputValue, SignalEnd>) -> Void {
		assert(signal.mutex.unbalancedTryLock() == false)
		guard let output = outputs.first, let outputSignal = output.destination.value, let ac = output.activationCount else { return initialHandlerInternal() }
		let activated = signal.delivery.isNormal
		let predecessor: Unmanaged<AnyObject>? = Unmanaged.passUnretained(self)
		let propagation = closePropagation
		return { [weak outputSignal, weak self] r in
			if case .failure(let e) = r, !propagation.shouldPropagateEnd(e), let os = outputSignal, let s = self {
				var dw = DeferredWork()
				os.mutex.sync {
					guard os.activationCount == ac else { return }
					_ = os.removePreceedingWithoutInterruptionInternal(s, dw: &dw)
					s.multiInput.checkForLastInputRemovedInternal(signal: os, dw: &dw)
				}
				dw.runWork()
			} else {
				_ = outputSignal?.send(result: r, predecessor: predecessor, activationCount: ac, activated: activated)
			}
		}
	}
}

/// The `SignalMultiInput` class is used as a persistent, rebindable input to a `Signal`.
/// You can use `SignalMultiInput` as the parameter to `bind(to:)` multiple times, versus `SignalInput` for which subsequent uses after the first will have no effect.
/// When sending an error to `SignalMultiInput`, the preceeding branch of the signal graph will be disconnected but the close will not be propagated to the output signal. This is in accordance with the idea that `SignalMultiInput` is a shared interface – the `SignalMultiInput` remains until all inputs are closed and the `SignalMultiInput` itself is released.
// If you need more precise control about whether incoming signals have the ability to close the outgoing signal, use the `SignalMergedInput` subclass – the default behavior of `SignalMergedInput` is to propgate "unexpected" errors (non-`SignalComplete` errors).
/// Another difference is that a `SignalInput` is invalidated when the graph deactivates whereas `SignalMultiInput` remains valid.
class SignalMultiInput<InputValue>: SignalInput<InputValue> {
	// Constructs a `SignalMergedInput` (typically called from `Signal<InputValue>.createMergedInput`)
	//
	// - Parameter signal: the destination `Signal`
	fileprivate init(signal: Signal<InputValue>) {
		super.init(signal: signal, activationCount: 0)
	}
	
	/// Connect a new predecessor to the `Signal`
	///
	/// - Parameters:
	///   - source: the `Signal` to connect as a new predecessor
	///   - closePropagation: behavior to use when `source` sends an error. See `SignalEndPropagation` for more.
	///   - removeOnDeactivate: if true, then when the output is deactivated, this source will be removed from the merge set. If false, then the source will remain connected through deactivation.
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	func add<U: SignalInterface>(_ source: U) where U.OutputValue == InputValue {
		self.add(source, closePropagation: .none)
	}
	
	// See the comments on the override in `SignalMergedInput`
	fileprivate func add<U: SignalInterface>(_ source: U, closePropagation: SignalEndPropagation, removeOnDeactivate: Bool = false) where U.OutputValue == InputValue {
		guard let sig = signal else { return }
		let processor = source.signal.attach { (s, dw) -> SignalMultiInputProcessor<InputValue> in
			SignalMultiInputProcessor<InputValue>(signal: s, multiInput: self, closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate, dw: &dw)
		}
		var dw = DeferredWork()
		sig.mutex.sync {
			// This can't be `duplicate` since this a a new processor but `loop` is a precondition failure
			try! sig.addPreceedingInternal(processor, param: nil, dw: &dw)
		}
		dw.runWork()
	}
	
	private func remove(mp: SignalMultiInputProcessor<InputValue>, from sig: Signal<InputValue>) -> Bool {
		var dw = DeferredWork()
		let result = sig.mutex.sync { () -> Bool in
			let r = sig.removePreceedingWithoutInterruptionInternal(mp, dw: &dw)
			checkForLastInputRemovedInternal(signal: sig, dw: &dw)
			return r
		}
		dw.runWork()
		return result
	}
	
	/// Removes a predecessor from the merge set
	///
	/// NOTE: if the predecessor is a `SignalMulti` with multiple connections to the merge set, only the first match will be removed.
	///
	/// - Parameter source: the predecessor to remove
	final func remove<U: SignalInterface>(_ source: U) where U.OutputValue == InputValue {
		guard let targetSignal = signal else { return }
		
		let sourceSignal = source.signal
		if let multi = sourceSignal as? SignalMulti<InputValue> {
			let signals = multi.preceeding.first!.base.outputSignals(ofType: InputValue.self)
			let mergeProcessors = signals.compactMap { s in
				s.mutex.sync { s.signalHandler as? SignalMultiInputProcessor<InputValue> }
			}
			for mp in mergeProcessors {
				if remove(mp: mp, from: targetSignal) {
					break
				}
			}
		} else {
			if let mp = sourceSignal.mutex.sync(execute: { sourceSignal.signalHandler as? SignalMultiInputProcessor<InputValue> }) {
				_ = remove(mp: mp, from: targetSignal)
			}
		}
	}
	
	// Overridden by SignalMergeSet to send an error immediately upon last input removed
	fileprivate func checkForLastInputRemovedInternal(signal: Signal<InputValue>, dw: inout DeferredWork) {
	}
	
	/// Connects a new `SignalInput<InputValue>` to `self`. A single input may be faster than a multi-input over multiple `send` operations.
	override func singleInput() -> SignalInput<InputValue> {
		let (input, signal) = Signal<InputValue>.create()
		self.add(signal)
		return input
	}
	
	/// The primary signal sending function
	///
	/// NOTE: on `SignalMultiInput` this is a relatively low performance convenience method; it calls `singleInput()` on each send. If you plan to send multiple results, it is more efficient to call `singleInput()`, retain the `SignalInput` that creates and call `SignalInput` on that single input.
	///
	/// - Parameter result: the value or error to send, composed as a `Result`
	/// - Returns: `nil` on success. Non-`nil` values include `SignalSendError.disconnected` if the `predecessor` or `activationCount` fail to match, `SignalSendError.inactive` if the current `delivery` state is `.disabled`.
	final override func send(result: Result<InputValue, SignalEnd>) -> SignalSendError? {
		return singleInput().send(result: result)
	}
	
	/// Implementation of `Lifetime` removes all inputs and sends a `SignalComplete.cancelled` to the destination.
	final override func cancel() {
		guard let sig = signal else { return }
		var dw = DeferredWork()
		sig.mutex.sync {
			sig.removeAllPreceedingInternal(dw: &dw)
			sig.pushInternal(values: [], end: SignalEnd.cancelled, activated: true, dw: &dw)
		}
		dw.runWork()
	}
}

/// A SignalMergeSet is a very similar to a SignalMultiInput but offering additional customization as expected by common transformations. The reason why this customization is not offered directly on `SignalMultiInput` is that these are behavior customizations you don't generally want to expose in an interface.
///
/// In particular:
///	* The SignalMergeSet can be configured to send a specific Error (e.g. SignalEnd.complete) when the last input is removed. This is helpful when merging a specific set of inputs and running until they're all complete.
///	* The SignalMergeSet can be configured to send a specific Error on deinit (i.e. when there are no inputs and the class is not otherwise retained). SignalMultiInput sends a `.cancelled` in this scenario but SignalMergeSet sends a `.closed` and can be configured to send something else as desired.
///	* A SignalMultiInput rejects all attempts to send errors through it (closes, cancels, or otherwise) and merely disconnects the input that sent the error. A SignalMergeSet can be configured to similar reject all (`.none`) or it can permit all (`.all`), or permit only non-close errors (`.errors`). The latter is the *default* for SignalMultiInput (except when using `singleInput` which keeps the `.none` behavior). This default marks a difference in behavior, relative to SignalMultiInput, which always uses `.none`.
/// Exposing `SignalMergedInput` in an interface is not particularly common. It is typically used for internal subgraphs where specific control is required.
///
/// WARNING: `SignalMergedInput` changes the default `SignalEndPropagation` behavior from `.none` to `.errors`. This is because `SignalMergedInput` is primarily used for implementing transformations like `flatMap` which expect this type of propagation.
class SignalMergedInput<InputValue>: SignalMultiInput<InputValue> {
	fileprivate let onLastInputClosed: SignalEnd?
	fileprivate let onDeinit: SignalEnd
	
	fileprivate init(signal: Signal<InputValue>, onLastInputClosed: SignalEnd? = nil, onDeinit: SignalEnd = .cancelled) {
		self.onLastInputClosed = onLastInputClosed
		self.onDeinit = onDeinit
		super.init(signal: signal)
	}
	
	/// Changes the default closePropagation to `.all`
	override func add<U: SignalInterface>(_ source: U) where U.OutputValue == InputValue {
		self.add(source, closePropagation: .errors, removeOnDeactivate: false)
	}

	fileprivate override func checkForLastInputRemovedInternal(signal sig: Signal<InputValue>, dw: inout DeferredWork) {
		if sig.preceeding.count == 0, let e = onLastInputClosed {
			sig.pushInternal(values: [], end: e, activated: true, dw: &dw)
		}
	}
	
	/// Connect a new predecessor to the `Signal`
	///
	/// - Parameters:
	///   - source: the `Signal` to connect as a new predecessor
	///   - closePropagation: behavior to use when `source` sends an error. See `SignalEndPropagation` for more.
	///   - removeOnDeactivate: f true, then when the output is deactivated, this source will be removed from the merge set. If false, then the source will remain connected through deactivation.
	/// - Throws: may throw a `SignalBindError` (see that type for possible cases)
	override func add<U: SignalInterface>(_ source: U, closePropagation: SignalEndPropagation, removeOnDeactivate: Bool = false) where U.OutputValue == InputValue {
		super.add(source, closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate)
	}

	/// Creates a new `SignalInput`/`Signal` pair, immediately adds the `Signal` to this `SignalMergedInput` and returns the `SignalInput`.
	///
	/// - Parameters:
	///   - closePropagation: passed to `add(_:closePropagation:removeOnDeactivate:) internally
	///   - removeOnDeactivate: passed to `add(_:closePropagation:removeOnDeactivate:) internally
	/// - Returns: the `SignalInput` that will now feed into this `SignalMergedInput`.
	final func singleInput(closePropagation: SignalEndPropagation, removeOnDeactivate: Bool = false) -> SignalInput<InputValue> {
		let (input, signal) = Signal<InputValue>.create()
		self.add(signal, closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate)
		return input
	}

	/// Connects a new `SignalInput<InputValue>` to `self`. A single input may be faster than a multi-input over multiple `send` operations.
	override func singleInput() -> SignalInput<InputValue> {
		let (input, signal) = Signal<InputValue>.create()
		self.add(signal, closePropagation: .none, removeOnDeactivate: false)
		return input
	}
	
	// SignalMergeSet suppresses the standard cancel on deinit behavior in favor of sending its own chosen error.
	fileprivate override func cancelOnDeinit() {
		guard let sig = signal else { return }
		var dw = DeferredWork()
		sig.mutex.sync {
			sig.pushInternal(values: [], end: onDeinit, activated: true, dw: &dw)
		}
		dw.runWork()
	}
}

/// The primary "exit point" for a signal graph. `SignalOutput` provides two important functions:
///	1. a `handler` function which receives signal values and errors
///	2. upon connecting to the graph, `SignalOutput` "activates" the signal graph (which allows sending through the graph to occur and may trigger some "on activation" behavior).
/// This class is instantiated by calling `subscribe` on any `Signal`.
final class SignalOutput<OutputValue>: SignalHandler<OutputValue>, Lifetime {
	private let userHandler: (Result<OutputValue, SignalEnd>) -> Void
	
	/// Constructor called from `subscribe`
	///
	/// - Parameters:
	///   - signal: the source signal
	///   - dw: required
	///   - context: where `handler` will be run
	///   - handler: invoked when a new signal is received
	fileprivate init(signal: Signal<OutputValue>, dw: inout DeferredWork, context: Exec, handler: @escaping (Result<OutputValue, SignalEnd>) -> Void) {
		self.userHandler = context.isImmediateNonDirect ? { a in context.invokeSync { handler(a) } } : handler
		super.init(signal: signal, dw: &dw, context: context)
	}
	
	// Can't have an `output` so this intial handler is the *only* handler
	// - Returns: a function to use as the handler prior to activation
	fileprivate override func initialHandlerInternal() -> (Result<OutputValue, SignalEnd>) -> Void {
		assert(signal.mutex.unbalancedTryLock() == false)
		return { [userHandler] r in
			userHandler(r)
		}
	}
	
	// A `SignalOutput` is active until closed (receives a `failure` signal)
	fileprivate override var activeWithoutOutputsInternal: Bool {
		assert(signal.mutex.unbalancedTryLock() == false)
		return true
	}
	
	/// A simple test for whether this output has received an error, yet. Not generally needed (responding to state changes is best done through the handler function itself).
	var isClosed: Bool {
		return sync { signal.delivery.isDisabled }
	}
	
	/// Implementatation of `Lifetime` forces deactivation
	func cancel() {
		var dw = DeferredWork()
		sync { if !signal.delivery.isDisabled { deactivateInternal(dueToLackOfOutputs: false, dw: &dw) } }
		dw.runWork()
	}
	
	// This is likely redundant but it's required by `Lifetime`
	deinit {
		cancel()
	}
}

@available(*, deprecated, message:"Renamed to SignalOutput")
typealias SignalEndpoint<T> = SignalOutput<T>

/// Reflects the activation state of a `Signal`
/// - normal: Signal will deliver results according to the default behavior of the processing context
/// - disabled: Signal is closed or otherwise inactive. Attempts to send new sseiignals will have no effect. context
/// - synchronous: Signal will attempt to deliver the first `Int` results in the queue synchronously. Results received from synchronous predecessors prior to the completion of activation will be inserted in the queue at the `Int` index and the `Int` value increased. Results received from predecessors with other states will be appended at the end of the queue. context
fileprivate enum SignalDelivery {
	case normal
	case disabled
	case synchronous(Int)
	
	var isDisabled: Bool { if case .disabled = self { return true } else { return false } }
	var isSynchronous: Bool { if case .synchronous = self { return true } else { return false } }
	var isNormal: Bool { if case .normal = self { return true } else { return false } }
}

@available(*, unavailable, message: "SignalEnd[.closed|.cancelled], SignalSendError[.disconnected|.inactive] or SignalReactiveError.timeout instead")
typealias SignalError = SignalEnd

@available(*, unavailable, message: "SignalEnd instead")
typealias SignalComplete = SignalEnd

/// An enum used to represent the two "expected" end-of-stream cases.
///
/// - complete:  indicates the end-of-stream was reached by calling close
/// - cancelled: indicates the end-of-stream was reached because an input was disconnected or cancelled
///
/// There may be rare cases where `.cancelled` indicates a scenario you might want to handle specially but for all handling within the CwlSignal framework, these two are treated identically – this is expected to be the common situation in user code. There are situations where `.cancelled` may indicate programmer error (i.e. failure to retain `SignalInput` correctly) so distinguishing between the two may be important for debugging.
///
/// NOTE: SignalEnd conforms to `Equatable` but this comparison merely matches cases on this enum (any two errors will compare "equal").
///
/// See also: `isSignalComplete` on `Error` and `Result<T, SignalEnd>` for easily testing if a given `Error` or `Result` contains a `SignalComplete`.
enum SignalEnd: Error, Equatable {
	case complete
	case cancelled
	case other(Error)
	
	var isOther: Bool {
		if case .other = self { return true } else { return false }
	}
	var isComplete: Bool {
		if case .complete = self { return true } else { return false }
	}
	var isCancelled: Bool {
		if case .cancelled = self { return true } else { return false }
	}
	var otherError: Error? {
		if case .other(let e) = self { return e } else { return nil }
	}

	static func == (lhs: SignalEnd, rhs: SignalEnd) -> Bool {
		switch (lhs, rhs) {
		case (.complete, .complete): return true
		case (.cancelled, .cancelled): return true
		case (.other, .other): return true
		default: return false
		}
	}
}

/// Possible send-failure return results when sending to a `SignalInput`. This type is used as a discardable return type so it does not need to conform to Swift.Error.
///
/// - disconnected:  the signal input has been disconnected from its target signal
/// - inactive:  the signal graph is not activated (no outputs in the graph) and the Result was not sent
enum SignalSendError {
	case disconnected
	case inactive
}

/// Attempts to bind a `SignalInput` to a bindable handler (`SignalMergeSet`, `SignalJunction` or `SignalCapture`) can fail in two different ways.
/// - cancelled: the destination `SignalInput`/`SignalMergeSet` was no longer the active input for its `Signal` (either its `Signal` is joined to something else or `Signal` has been deactivated, invalidating old inputs)
/// - duplicate(`SignalInput<OutputValue>`): the source `Signal` already had an output connected and doesn't support multiple outputs so the bind failed. If the bind destination was a single `SignalInput` then that `SignalInput` was consumed by the attempt so the associated value will be a new `SignalInput` replacing the old one.
enum SignalBindError<OutputValue>: Error {
	case cancelled
	case loop
	case duplicate(SignalInput<OutputValue>?)
}

/// Used by the Signal<OutputValue>.combine(second:context:handler:) method
enum EitherResult2<U, V> {
	case result1(Signal<U>.Result)
	case result2(Signal<V>.Result)
}

/// Used by the Signal<OutputValue>.combine(second:third:context:handler:) method
enum EitherResult3<U, V, W> {
	case result1(Signal<U>.Result)
	case result2(Signal<V>.Result)
	case result3(Signal<W>.Result)
}

/// Used by the Signal<OutputValue>.combine(second:third:fourth:context:handler:) method
enum EitherResult4<U, V, W, X> {
	case result1(Signal<U>.Result)
	case result2(Signal<V>.Result)
	case result3(Signal<W>.Result)
	case result4(Signal<X>.Result)
}

/// Used by the Signal<OutputValue>.combine(second:third:fourth:fifth:context:handler:) method
enum EitherResult5<U, V, W, X, Y> {
	case result1(Signal<U>.Result)
	case result2(Signal<V>.Result)
	case result3(Signal<W>.Result)
	case result4(Signal<X>.Result)
	case result5(Signal<Y>.Result)
}


import Foundation

#if SWIFT_PACKAGE
	import CwlUtils
#endif

/// A `SignalChannel` forms a basic wrapper around a `SignalInput`/`Signal` pair and exists for syntactic convenience when building a series of pipeline stages and returning the head and tail of the pipeline.
///
/// e.g.: let (input, output) = Signal<Int>.channel().map { $0 + 1 }.subscribe { print($0) }
///
/// Every transform in the CwlSignal library that can be applied to `Signal<Interface.OutputValue>` can also be applied to `SignalChannel<Interface.OutputValue>`. Where possible, the result is another `SignalChannel` so the result can be immediately transformed again.
struct SignalChannel<InputInterface: SignalInputInterface, Interface: SignalInterface> {
	let input: InputInterface
	let signal: Interface
	init(input: InputInterface, signal: Interface) { (self.input, self.signal) = (input, signal) }
}

extension SignalChannel {
	/// Append an additional `Signal` stage in the `SignalChannel` pipeline, returning a new SignalChannel that combines the `input` from `self` and the `signal` from the new stage.
	///
	/// - Parameter compose: a transformation that takes `signal` from `self` and returns a new `Signal`.
	/// - Returns: a `SignalChannel` combining `input` and the result from `compose`.
	/// - Throws: rethrows the contents of the `compose` closure.
	func next<Next>(_ compose: (Signal<Interface.OutputValue>) throws -> Next) rethrows -> SignalChannel<InputInterface, Next> {
		return try SignalChannel<InputInterface, Next>(input: input, signal: compose(signal.signal))
	}
	
	/// Similar to `next` but producing a new stage that is *not* a `Signal` and returning `input` and this new stage as a tuple.
	///
	/// - Parameter compose: a transformation that takes `signal` from `self` and returns a new value.
	/// - Returns: a tuple combining `input` and the result from `compose`.
	/// - Throws: rethrows the contents of the `compose` closure.
	func final<U>(_ compose: (Signal<Interface.OutputValue>) throws -> U) rethrows -> (input: InputInterface, output: U) {
		return try (input, compose(signal.signal))
	}
	
	/// Similar to `next` but consuming (not returning) the result from the `compose` function. The result is simply `input` from `self`. Typically used when `bind(to:)` is invoked, linking the output of this channel to another signal graph.
	///
	/// - Parameter compose: a transformation that takes `signal` from `self` and returns `Void`.
	/// - Returns: `input` from `self`
	/// - Throws: rethrows the contents of the `compose` closure.
	func consume(_ compose: (Signal<Interface.OutputValue>) throws -> ()) rethrows -> InputInterface {
		try compose(signal.signal)
		return input
	}
	
	/// A `SignalChannel` is essentially a tuple. This property explodes the contents as a convenience in some scenarios.
	var tuple: (input: InputInterface, signal: Interface) { return (input: input, signal: signal) }
}

typealias Input<Value> = SignalChannel<SignalInput<Value>, Signal<Value>>
typealias MultiInput<Value> = SignalChannel<SignalMultiInput<Value>, Signal<Value>>
typealias MergedInput<Value> = SignalChannel<SignalMergedInput<Value>, Signal<Value>>

typealias MultiOutput<Value> = SignalChannel<SignalInput<Value>, SignalMulti<Value>>
typealias MultiInputMultiOutput<Value> = SignalChannel<SignalMultiInput<Value>, SignalMulti<Value>>
typealias MergedInputMultiOutput<Value> = SignalChannel<SignalMergedInput<Value>, SignalMulti<Value>>

extension SignalChannel { 
	init<Value>() where SignalInput<Value> == InputInterface, Signal<Value> == Interface {
		self = Signal<Value>.channel()
	}
	init<Value>() where SignalMultiInput<Value> == InputInterface, Signal<Value> == Interface {
		self = Signal<Value>.multiChannel()
	}
	init<Value>() where SignalMergedInput<Value> == InputInterface, Signal<Value> == Interface {
		self = Signal<Value>.mergedChannel()
	}
}

extension Signal {
	/// This function is used for starting SignalChannel pipelines with a `SignalInput`
	static func channel() -> SignalChannel<SignalInput<OutputValue>, Signal<OutputValue>> {
		let (input, signal) = Signal<OutputValue>.create()
		return SignalChannel<SignalInput<OutputValue>, Signal<OutputValue>>(input: input, signal: signal)
	}
	
	/// This function is used for starting SignalChannel pipelines with a `SignalMultiInput`
	static func multiChannel() -> SignalChannel<SignalMultiInput<OutputValue>, Signal<OutputValue>> {
		let (input, signal) = Signal<OutputValue>.createMultiInput()
		return SignalChannel<SignalMultiInput<OutputValue>, Signal<OutputValue>>(input: input, signal: signal)
	}
	
	/// This function is used for starting SignalChannel pipelines with a `SignalMergedInput`
	static func mergedChannel(onLastInputClosed: SignalEnd? = nil, onDeinit: SignalEnd = .cancelled) -> SignalChannel<SignalMergedInput<OutputValue>, Signal<OutputValue>> {
		let (input, signal) = Signal<OutputValue>.createMergedInput(onLastInputClosed: onLastInputClosed, onDeinit: onDeinit)
		return SignalChannel<SignalMergedInput<OutputValue>, Signal<OutputValue>>(input: input, signal: signal)
	}
}

// Implementation of Signal.swift
extension SignalChannel {
	func subscribe(context: Exec = .direct, _ handler: @escaping (Result<Interface.OutputValue, SignalEnd>) -> Void) -> (input: InputInterface, output: SignalOutput<Interface.OutputValue>) {
		let tuple = final { $0.subscribe(context: context, handler) }
		return (input: tuple.input, output: tuple.output)
	}
	
	func subscribeWhile(context: Exec = .direct, _ handler: @escaping (Result<Interface.OutputValue, SignalEnd>) -> Bool) -> InputInterface {
		return final { $0.subscribeWhile(context: context, handler) }.input
	}
	
	func junction() -> (input: InputInterface, junction: SignalJunction<Interface.OutputValue>) {
		let tuple = final { $0.junction() }
		return (input: tuple.input, junction: tuple.output)
	}
	
	func transform<U>(context: Exec = .direct, _ processor: @escaping (Result<Interface.OutputValue, SignalEnd>) -> Signal<U>.Next) -> SignalChannel<InputInterface, Signal<U>> {
		return next { $0.transform(context: context, processor) }
	}
	
	func transform<S, U>(initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, Result<Interface.OutputValue, SignalEnd>) -> Signal<U>.Next) -> SignalChannel<InputInterface, Signal<U>> {
		return next { $0.transform(initialState: initialState, context: context, processor) }
	}
	
	func combine<U: SignalInterface, V>(_ second: U, context: Exec = .direct, _ processor: @escaping (EitherResult2<Interface.OutputValue, U.OutputValue>) -> Signal<V>.Next) -> SignalChannel<InputInterface, Signal<V>> {
		return next { $0.combine(second, context: context, processor) }
	}
	
	func combine<U: SignalInterface, V: SignalInterface, W>(_ second: U, _ third: V, context: Exec = .direct, _ processor: @escaping (EitherResult3<Interface.OutputValue, U.OutputValue, V.OutputValue>) -> Signal<W>.Next) -> SignalChannel<InputInterface, Signal<W>> {
		return next { $0.combine(second, third, context: context, processor) }
	}
	
	func combine<U: SignalInterface, V: SignalInterface, W: SignalInterface, X>(_ second: U, _ third: V, _ fourth: W, context: Exec = .direct, _ processor: @escaping (EitherResult4<Interface.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>) -> Signal<X>.Next) -> SignalChannel<InputInterface, Signal<X>> {
		return next { $0.combine(second, third, fourth, context: context, processor) }
	}
	
	func combine<U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y>(_ second: U, _ third: V, _ fourth: W, _ fifth: X, context: Exec = .direct, _ processor: @escaping (EitherResult5<Interface.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>) -> Signal<Y>.Next) -> SignalChannel<InputInterface, Signal<Y>> {
		return next { $0.combine(second, third, fourth, fifth, context: context, processor) }
	}
	
	func combine<S, U: SignalInterface, V>(initialState: S, _ second: U, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult2<Interface.OutputValue, U.OutputValue>) -> Signal<V>.Next) -> SignalChannel<InputInterface, Signal<V>> {
		return next { $0.combine(second, initialState: initialState, context: context, processor) }
	}
	
	func combine<S, U: SignalInterface, V: SignalInterface, W>(initialState: S, _ second: U, _ third: V, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult3<Interface.OutputValue, U.OutputValue, V.OutputValue>) -> Signal<W>.Next) -> SignalChannel<InputInterface, Signal<W>> {
		return next { $0.combine(second, third, initialState: initialState, context: context, processor) }
	}
	
	func combine<S, U: SignalInterface, V: SignalInterface, W: SignalInterface, X>(initialState: S, _ second: U, _ third: V, _ fourth: W, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult4<Interface.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>) -> Signal<X>.Next) -> SignalChannel<InputInterface, Signal<X>> {
		return next { $0.combine(second, third, fourth, initialState: initialState, context: context, processor) }
	}
	
	func combine<S, U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y>(initialState: S, _ second: U, _ third: V, _ fourth: W, _ fifth: X, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult5<Interface.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>) -> Signal<Y>.Next) -> SignalChannel<InputInterface, Signal<Y>> {
		return next { $0.combine(second, third, fourth, fifth, initialState: initialState, context: context, processor) }
	}
	
	func continuous(initialValue: Interface.OutputValue) -> SignalChannel<InputInterface, SignalMulti<Interface.OutputValue>> {
		return next { $0.continuous(initialValue: initialValue) }
	}
	
	func continuous() -> SignalChannel<InputInterface, SignalMulti<Interface.OutputValue>> {
		return next { $0.continuous() }
	}
	
	func continuousWhileActive() -> SignalChannel<InputInterface, SignalMulti<Interface.OutputValue>> {
		return next { $0.continuousWhileActive() }
	}
	
	func playback() -> SignalChannel<InputInterface, SignalMulti<Interface.OutputValue>> {
		return next { $0.playback() }
	}
	
	func cacheUntilActive() -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.cacheUntilActive() }
	}
	
	func multicast() -> SignalChannel<InputInterface, SignalMulti<Interface.OutputValue>> {
		return next { $0.multicast() }
	}
	
	func multicast(sequence: [SignalInput<Interface.OutputValue>]) -> InputInterface {
		return final {
			let multi = $0.multicast()
			for i in sequence {
				multi.bind(to: i)
			}
		}.input
	}
	
	func multicast(_ interfaces: SignalInput<Interface.OutputValue>...) -> InputInterface {
		return multicast(sequence: interfaces)
	}
	
	func customActivation(initialValues: Array<Interface.OutputValue> = [], context: Exec = .direct, _ updater: @escaping (_ cachedValues: inout Array<Interface.OutputValue>, _ cachedEnd: inout SignalEnd?, _ incoming: Result<Interface.OutputValue, SignalEnd>) -> Void) -> SignalChannel<InputInterface, SignalMulti<Interface.OutputValue>> {
		return next { $0.customActivation(initialValues: initialValues, context: context, updater) }
	}
	
	func reduce<State>(initialState: State, context: Exec = .direct, _ reducer: @escaping (_ state: State, _ message: Interface.OutputValue) throws -> State) -> SignalChannel<InputInterface, SignalMulti<State>> {
		return next { $0.reduce(initialState: initialState, context: context, reducer) }
	}
	
	func capture() -> (input: InputInterface, capture: SignalCapture<Interface.OutputValue>) {
		let tuple = final { $0.capture() }
		return (input: tuple.input, capture: tuple.output)
	}
}

// Implementation of SignalExtensions.swift
extension SignalChannel {
	func dropActivation() -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.dropActivation() }
	}
	
	func deferActivation() -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.deferActivation() }
	}
	
	func subscribeUntilEnd(context: Exec = .direct, _ handler: @escaping (Result<Interface.OutputValue, SignalEnd>) -> Void) -> InputInterface {
		return final { $0.subscribeUntilEnd(context: context, handler) }.input
	}
	
	func subscribeValues(context: Exec = .direct, _ handler: @escaping (Interface.OutputValue) -> Void) -> (input: InputInterface, output: SignalOutput<Interface.OutputValue>) {
		let tuple = final { $0.subscribeValues(context: context, handler) }
		return (input: tuple.input, output: tuple.output)
	}
	
	func subscribeValuesUntilEnd(context: Exec = .direct, _ handler: @escaping (Interface.OutputValue) -> Void) -> InputInterface {
		signal.subscribeValuesUntilEnd(context: context, handler)
		return input
	}
	
	func subscribeValuesWhile(context: Exec = .direct, _ handler: @escaping (Interface.OutputValue) -> Bool) -> InputInterface {
		signal.subscribeValuesWhile(context: context, handler)
		return input
	}
	
	func stride(count: Int, initialSkip: Int = 0) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.stride(count: count, initialSkip: initialSkip) }
	}
	
	func transformValues<U>(context: Exec = .direct, _ processor: @escaping (Interface.OutputValue) -> Signal<U>.Next) -> SignalChannel<InputInterface, Signal<U>> {
		return next { $0.transformValues(context: context, processor) }
	}

	func transformValues<S, U>(initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, Interface.OutputValue) -> Signal<U>.Next) -> SignalChannel<InputInterface, Signal<U>> {
		return next { $0.transformValues(initialState: initialState, context: context, processor) }
	}
	
	func transformFlatten<U>(closePropagation: SignalEndPropagation = .none, context: Exec = .direct, _ processor: @escaping (Interface.OutputValue, SignalMergedInput<U>) -> ()) -> SignalChannel<InputInterface, Signal<U>> {
		return next { $0.transformFlatten(closePropagation: closePropagation, context: context, processor) }
	}
	
	func transformFlatten<S, U>(initialState: S, closePropagation: SignalEndPropagation = .none, context: Exec = .direct, _ processor: @escaping (inout S, Interface.OutputValue, SignalMergedInput<U>) -> ()) -> SignalChannel<InputInterface, Signal<U>> {
		return next { $0.transformFlatten(initialState: initialState, closePropagation: closePropagation, context: context, processor) }
	}
	
	func valueDurations<DurationInterface: SignalInterface>(closePropagation: SignalEndPropagation = .none, context: Exec = .direct, _ duration: @escaping (Interface.OutputValue) -> DurationInterface) -> SignalChannel<InputInterface, Signal<(Int, Interface.OutputValue?)>> {
		return next { $0.valueDurations(closePropagation: closePropagation, context: context, duration) }
	}
	
	func valueDurations<DurationInterface: SignalInterface, V>(initialState: V, closePropagation: SignalEndPropagation = .none, context: Exec = .direct, _ duration: @escaping (inout V, Interface.OutputValue) -> DurationInterface) -> SignalChannel<InputInterface, Signal<(Int, Interface.OutputValue?)>> {
		return next { $0.valueDurations(initialState: initialState, closePropagation: closePropagation, context: context, duration) }
	}
	
	func toggle(initialState: Bool = false) -> SignalChannel<InputInterface, Signal<Bool>> {
		return next { $0.toggle(initialState: initialState) }
	}
	
	func optional() -> SignalChannel<InputInterface, Signal<Interface.OutputValue?>> {
		return next { $0.optional() }
	}
	
	func optionalToArray<U>() -> SignalChannel<InputInterface, Signal<[U]>> where Interface.OutputValue == Optional<U> {
		return next { $0.optionalToArray() }
	}
	
	func bind<Target>(to interface: Target) -> InputInterface where Target: SignalInputInterface, Target.InputValue == Interface.OutputValue {
		return final { $0.bind(to: interface) }.input
	}
	
	func bind(to: SignalMergedInput<Interface.OutputValue>, closePropagation: SignalEndPropagation = .none, removeOnDeactivate: Bool = false) -> InputInterface {
		signal.signal.bind(to: to, closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate)
		return input
	}

	func flatMapBind<Output: SignalInterface, Input: SignalInputInterface>(to interface: Output, _ transform: @escaping (Output.OutputValue) -> Input) -> InputInterface where Input.InputValue == Interface.OutputValue {
		return final { $0.flatMapBind(to: interface, transform) }.input
	}
	
	
	func cacheLatest() -> (input: InputInterface, output: SignalLatest<Interface.OutputValue>) {
		let tuple = final { SignalLatest(signal: $0) }
		return (input: tuple.input, output: tuple.output)
	}
}

// Implementation of SignalReactive.swift
extension SignalChannel {
	func buffer<Boundaries: SignalInterface>(boundaries: Boundaries) -> SignalChannel<InputInterface, Signal<[Interface.OutputValue]>> {
		return next { $0.buffer(boundaries: boundaries) }
	}
	
	func buffer<Boundaries: SignalInterface>(windows: Boundaries) -> SignalChannel<InputInterface, Signal<[Interface.OutputValue]>> where Boundaries.OutputValue: SignalInterface {
		return next { $0.buffer(windows: windows) }
	}
	
	func buffer(count: UInt, skip: UInt) -> SignalChannel<InputInterface, Signal<[Interface.OutputValue]>> {
		return next { $0.buffer(count: count, skip: skip) }
	}
	
	func buffer(interval: DispatchTimeInterval, count: Int = Int.max, continuous: Bool = true, context: Exec = .direct) -> SignalChannel<InputInterface, Signal<[Interface.OutputValue]>> {
		return next { $0.buffer(interval: interval, count: count, continuous: continuous, context: context) }
	}
	
	func buffer(count: UInt) -> SignalChannel<InputInterface, Signal<[Interface.OutputValue]>> {
		return next { $0.buffer(count: count, skip: count) }
	}
	
	func buffer(interval: DispatchTimeInterval, timeshift: DispatchTimeInterval, context: Exec = .direct) -> SignalChannel<InputInterface, Signal<[Interface.OutputValue]>> {
		return next { $0.buffer(interval: interval, timeshift: timeshift, context: context) }
	}
	
	func compact<U>() -> SignalChannel<InputInterface, Signal<U>> where Interface.OutputValue == Optional<U> {
		return next { $0.compact() }
	}
		
	func compactMap<U>(context: Exec = .direct, _ processor: @escaping (Interface.OutputValue) throws -> U?) -> SignalChannel<InputInterface, Signal<U>> {
		return next { $0.compactMap(context: context, processor) }
	}
	
	func compactMap<S, U>(initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, Interface.OutputValue) throws -> U?) -> SignalChannel<InputInterface, Signal<U>> {
		return next { $0.compactMap(initialState: initialState, context: context, processor) }
	}

	func compactMapActivation<U>(select: SignalActivationSelection, context: Exec = .direct, activation: @escaping (Interface.OutputValue) throws -> U?, remainder: @escaping (Interface.OutputValue) throws -> U?) -> SignalChannel<InputInterface, Signal<U>> {
		return next { $0.compactMapActivation(select: select, context: context, activation: activation, remainder: remainder) }
	}
	
	func compactMapLatestActivation(select: SignalActivationSelection, context: Exec = .direct, activation: @escaping (Interface.OutputValue) throws -> Interface.OutputValue?) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.compactMapLatestActivation(context: context, activation: activation) }
	}
	
	func flatten<V>() -> SignalChannel<InputInterface, Signal<V>> where Interface.OutputValue: SignalInterface, Interface.OutputValue.OutputValue == V {
		return next { $0.flatten() }
	}
	
	func flatMap<Content: SignalInterface>(context: Exec = .direct, _ processor: @escaping (Interface.OutputValue) throws -> Content) -> SignalChannel<InputInterface, Signal<Content.OutputValue>> {
		return next { $0.flatMap(context: context, processor) }
	}
	
	func flatMapFirst<Content: SignalInterface>(context: Exec = .direct, _ processor: @escaping (Interface.OutputValue) throws -> Content) -> SignalChannel<InputInterface, Signal<Content.OutputValue>> {
		return next { $0.flatMapFirst(context: context, processor) }
	}
	
	func flatMapLatest<Content: SignalInterface>(context: Exec = .direct, _ processor: @escaping (Interface.OutputValue) throws -> Content) -> SignalChannel<InputInterface, Signal<Content.OutputValue>> {
		return next { $0.flatMapLatest(context: context, processor) }
	}
	
	func flatMap<Content: SignalInterface, V>(initialState: V, context: Exec = .direct, _ processor: @escaping (inout V, Interface.OutputValue) throws -> Content) -> SignalChannel<InputInterface, Signal<Content.OutputValue>> {
		return next { $0.flatMap(initialState: initialState, context: context, processor) }
	}
	
	func concatMap<Content: SignalInterface>(context: Exec = .direct, _ processor: @escaping (Interface.OutputValue) throws -> Content) -> SignalChannel<InputInterface, Signal<Content.OutputValue>> {
		return next { $0.concatMap(context: context, processor) }
	}
	
	func groupBy<U: Hashable>(context: Exec = .direct, _ processor: @escaping (Interface.OutputValue) throws -> U) -> SignalChannel<InputInterface, Signal<(U, Signal<Interface.OutputValue>)>> {
		return next { $0.groupBy(context: context, processor) }
	}
	
	func mapErrors(context: Exec = .direct, _ processor: @escaping (SignalEnd) -> SignalEnd) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.mapErrors(context: context, processor) }
	}
	
	func keyPath<U>(_ keyPath: KeyPath<Interface.OutputValue, U>) -> SignalChannel<InputInterface, Signal<U>> {
		return next { $0.keyPath(keyPath) }
	}
	
	func map<U>(context: Exec = .direct, _ processor: @escaping (Interface.OutputValue) throws -> U) -> SignalChannel<InputInterface, Signal<U>> {
		return next { $0.map(context: context, processor) }
	}
	
	func map<U, V>(initialState: V, context: Exec = .direct, _ processor: @escaping (inout V, Interface.OutputValue) throws -> U) -> SignalChannel<InputInterface, Signal<U>> {
		return next { $0.map(initialState: initialState, context: context, processor) }
	}
	
	func scan<U>(initialState: U, context: Exec = .direct, _ processor: @escaping (U, Interface.OutputValue) throws -> U) -> SignalChannel<InputInterface, Signal<U>> {
		return next { $0.scan(initialState: initialState, context: context, processor) }
	}
	
	func window<Boundaries: SignalInterface>(boundaries: Boundaries) -> SignalChannel<InputInterface, Signal<Signal<Interface.OutputValue>>> {
		return next { $0.window(boundaries: boundaries) }
	}
	
	func window<Boundaries: SignalInterface>(windows: Boundaries) -> SignalChannel<InputInterface, Signal<Signal<Interface.OutputValue>>> where Boundaries.OutputValue: SignalInterface {
		return next { $0.window(windows: windows) }
	}
	
	func window(count: UInt, skip: UInt) -> SignalChannel<InputInterface, Signal<Signal<Interface.OutputValue>>> {
		return next { $0.window(count: count, skip: skip) }
	}
	
	func window(interval: DispatchTimeInterval, count: Int = Int.max, continuous: Bool = true, context: Exec = .direct) -> SignalChannel<InputInterface, Signal<Signal<Interface.OutputValue>>> {
		return next { $0.window(interval: interval, count: count, continuous: continuous, context: context) }
	}
	
	func window(count: UInt) -> SignalChannel<InputInterface, Signal<Signal<Interface.OutputValue>>> {
		return next { $0.window(count: count, skip: count) }
	}
	
	func window(interval: DispatchTimeInterval, timeshift: DispatchTimeInterval, context: Exec = .direct) -> SignalChannel<InputInterface, Signal<Signal<Interface.OutputValue>>> {
		return next { $0.window(interval: interval, timeshift: timeshift, context: context) }
	}
	
	func debounce(interval: DispatchTimeInterval, flushOnClose: Bool = false, context: Exec = .direct) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.debounce(interval: interval, flushOnClose: flushOnClose, context: context) }
	}
	
	func throttleFirst(interval: DispatchTimeInterval, context: Exec = .direct) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.throttleFirst(interval: interval, context: context) }
	}
}

extension SignalChannel where Interface.OutputValue: Hashable {
	func distinct() -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.distinct() }
	}
}

extension SignalChannel where Interface.OutputValue: Equatable {
	func distinctUntilChanged() -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.distinctUntilChanged() }
	}
}

extension SignalChannel {
	func distinctUntilChanged(context: Exec = .direct, compare: @escaping (Interface.OutputValue, Interface.OutputValue) throws -> Bool) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.distinctUntilChanged(context: context, compare: compare) }
	}
	
	func elementAt(_ index: UInt) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.elementAt(index) }
	}
	
	func filter(context: Exec = .direct, matching: @escaping (Interface.OutputValue) throws -> Bool) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.filter(context: context, matching: matching) }
	}
	
	func ofType<U>(_ type: U.Type) -> SignalChannel<InputInterface, Signal<U>> {
		return next { $0.ofType(type) }
	}
	
	func first(context: Exec = .direct, matching: @escaping (Interface.OutputValue) throws -> Bool = { _ in true }) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.first(context: context, matching: matching) }
	}
	
	func single(context: Exec = .direct, matching: @escaping (Interface.OutputValue) throws -> Bool = { _ in true }) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.single(context: context, matching: matching) }
	}
	
	func ignoreElements<U>(outputType: U.Type = U.self) -> SignalChannel<InputInterface, Signal<U>> {
		return next { $0.ignoreElements(outputType: outputType) }
	}
	
	func last(context: Exec = .direct, matching: @escaping (Interface.OutputValue) throws -> Bool = { _ in true }) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.last(context: context, matching: matching) }
	}
	
	func sample<Trigger: SignalInterface>(_ trigger: Trigger) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> where Trigger.OutputValue == () {
		return next { $0.sample(trigger) }
	}
	
	func throttleFirst<Trigger: SignalInterface>(_ trigger: Trigger) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> where Trigger.OutputValue == () {
		return next { $0.throttleFirst(trigger) }
	}
	
	func withLatestFrom<Interface: SignalInterface>(_ sample: Interface) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.withLatestFrom(sample) }
	}
	
	func withLatestFrom<Other: SignalInterface, R>(_ sample: Other, context: Exec = .direct, _ processor: @escaping (Interface.OutputValue, Other.OutputValue) throws -> R) -> SignalChannel<InputInterface, Signal<R>> {
		return next { $0.withLatestFrom(sample, context: context, processor) }
	}
	
	func skip(_ count: Int) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.skip(count) }
	}
	
	func skipLast(_ count: Int) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.skipLast(count) }
	}
	
	func take(_ count: Int) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.take(count) }
	}
	
	func takeLast(_ count: Int) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.takeLast(count) }
	}
	
	func combineLatestWith<U: SignalInterface, V>(_ second: U, context: Exec = .direct, _ processor: @escaping (Interface.OutputValue, U.OutputValue) throws -> V) -> SignalChannel<InputInterface, Signal<V>> {
		return next { $0.combineLatestWith(second, context: context, processor) }
	}
	
	func combineLatestWith<U: SignalInterface, V: SignalInterface, W>(_ second: U, _ third: V, context: Exec = .direct, _ processor: @escaping (Interface.OutputValue, U.OutputValue, V.OutputValue) throws -> W) -> SignalChannel<InputInterface, Signal<W>> {
		return next { $0.combineLatestWith(second, third, context: context, processor) }
	}
	
	func combineLatestWith<U: SignalInterface, V: SignalInterface, W: SignalInterface, X>(_ second: U, _ third: V, _ fourth: W, context: Exec = .direct, _ processor: @escaping (Interface.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue) throws -> X) -> SignalChannel<InputInterface, Signal<X>> {
		return next { $0.combineLatestWith(second, third, fourth, context: context, processor) }
	}
	
	func combineLatestWith<U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y>(_ second: U, _ third: V, _ fourth: W, _ fifth: X, context: Exec = .direct, _ processor: @escaping (Interface.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue) throws -> Y) -> SignalChannel<InputInterface, Signal<Y>> {
		return next { $0.combineLatestWith(second, third, fourth, fifth, context: context, processor) }
	}
	
	func intersect<U: SignalInterface, V: SignalInterface, W: SignalInterface, X>(withRight: U, leftEnd: @escaping (Interface.OutputValue) -> V, rightEnd: @escaping (U.OutputValue) -> W, context: Exec = .direct, _ processor: @escaping ((Interface.OutputValue, U.OutputValue)) -> X) -> SignalChannel<InputInterface, Signal<X>> {
		return next { $0.intersect(withRight: withRight, leftEnd: leftEnd, rightEnd: rightEnd, context: context, processor) }
	}
	
	func groupIntersect<U: SignalInterface, V: SignalInterface, W: SignalInterface, X>(withRight: U, leftEnd: @escaping (Interface.OutputValue) -> V, rightEnd: @escaping (U.OutputValue) -> W, context: Exec = .direct, _ processor: @escaping ((Interface.OutputValue, Signal<U.OutputValue>)) -> X) -> SignalChannel<InputInterface, Signal<X>> {
		return next { $0.groupIntersect(withRight: withRight, leftEnd: leftEnd, rightEnd: rightEnd, context: context, processor) }
	}
	
	func merge(_ sources: Signal<Interface.OutputValue>...) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.merge(sequence: sources) }
	}
	
	func merge<S: Sequence>(sequence: S) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> where S.Iterator.Element == Signal<Interface.OutputValue> {
		return next { $0.merge(sequence: sequence) }
	}
	
	func startWith<S: Sequence>(sequence: S) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> where S.Iterator.Element == Interface.OutputValue {
		return next { $0.startWith(sequence: sequence) }
	}
	
	func startWith(_ values: Interface.OutputValue...) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.startWith(sequence: values) }
	}
	
	func endWith<U: Sequence>(_ sequence: U, conditional: @escaping (SignalEnd) -> SignalEnd? = { e in e }) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> where U.Iterator.Element == Interface.OutputValue {
		return next { $0.endWith(sequence: sequence, conditional: conditional) }
	}
	
	func endWith(_ values: Interface.OutputValue..., conditional: @escaping (SignalEnd) -> SignalEnd? = { e in e }) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.endWith(sequence: values, conditional: conditional) }
	}
	
	func switchLatest<U>() -> SignalChannel<InputInterface, Signal<U>> where Interface.OutputValue: Signal<U> {
		return next { $0.switchLatest() }
	}

	func zipWith<U: SignalInterface>(_ second: U) -> SignalChannel<InputInterface, Signal<(Interface.OutputValue, U.OutputValue)>> {
		return next { $0.zipWith(second) }
	}
	
	func zipWith<U: SignalInterface, V: SignalInterface>(_ second: U, _ third: V) -> SignalChannel<InputInterface, Signal<(Interface.OutputValue, U.OutputValue, V.OutputValue)>> {
		return next { $0.zipWith(second, third) }
	}
	
	func zipWith<U: SignalInterface, V: SignalInterface, W: SignalInterface>(_ second: U, _ third: V, _ fourth: W) -> SignalChannel<InputInterface, Signal<(Interface.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue)>> {
		return next { $0.zipWith(second, third, fourth) }
	}
	
	func zipWith<U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface>(_ second: U, _ third: V, _ fourth: W, _ fifth: X) -> SignalChannel<InputInterface, Signal<(Interface.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue)>> {
		return next { $0.zipWith(second, third, fourth, fifth) }
	}
	
	func catchError(context: Exec = .direct, recover: @escaping (SignalEnd) -> Signal<Interface.OutputValue>) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.catchError(context: context, recover: recover) }
	}
	
	func retry<U>(_ initialState: U, context: Exec = .direct, shouldRetry: @escaping (inout U, SignalEnd) -> DispatchTimeInterval?) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.retry(initialState, context: context, shouldRetry: shouldRetry) }
	}
	
	func retry(count: Int, delayInterval: DispatchTimeInterval, context: Exec = .direct) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.retry(count: count, delayInterval: delayInterval, context: context) }
	}
	
	func delay<U>(initialState: U, closePropagation: SignalEndPropagation = .none, context: Exec = .direct, offset: @escaping (inout U, Interface.OutputValue) -> DispatchTimeInterval) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.delay(initialState: initialState, closePropagation: closePropagation, context: context, offset: offset) }
	}
	
	func delay(interval: DispatchTimeInterval, context: Exec = .direct) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.delay(interval: interval, context: context) }
	}
	
	func delay<U>(closePropagation: SignalEndPropagation = .none, context: Exec = .direct, offset: @escaping (Interface.OutputValue) -> Signal<U>) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.delay(closePropagation: closePropagation, context: context, offset: offset) }
	}
	
	func delay<U, V>(initialState: V, closePropagation: SignalEndPropagation = .none, context: Exec = .direct, offset: @escaping (inout V, Interface.OutputValue) -> Signal<U>) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.delay(initialState: initialState, closePropagation: closePropagation, context: context, offset: offset) }
	}
	
	func onActivate(context: Exec = .direct, _ handler: @escaping () -> ()) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.onActivate(context: context, handler) }
	}
	
	func onDeactivate(context: Exec = .direct, _ handler: @escaping () -> ()) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.onDeactivate(context: context, handler) }
	}
	
	func onResult(context: Exec = .direct, _ handler: @escaping (Result<Interface.OutputValue, SignalEnd>) -> ()) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.onResult(context: context, handler) }
	}
	
	func onValue(context: Exec = .direct, _ handler: @escaping (Interface.OutputValue) -> ()) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.onValue(context: context, handler) }
	}
	
	func onError(context: Exec = .direct, _ handler: @escaping (SignalEnd) -> ()) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.onError(context: context, handler) }
	}

	func debug(logPrefix: String = "", file: String = #file, line: Int = #line) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.debug(logPrefix: logPrefix, file: file, line: line) }
	}
	
	func materialize() -> SignalChannel<InputInterface, Signal<Result<Interface.OutputValue, SignalEnd>>> {
		return next { $0.materialize() }
	}
	
	func timeInterval(context: Exec = .direct) -> SignalChannel<InputInterface, Signal<Double>> {
		return next { $0.timeInterval(context: context) }
	}
	
	func timeout(interval: DispatchTimeInterval, resetOnValue: Bool = true, context: Exec = .direct) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.timeout(interval: interval, resetOnValue: resetOnValue, context: context) }
	}
	
	func timestamp(context: Exec = .direct) -> SignalChannel<InputInterface, Signal<(Interface.OutputValue, DispatchTime)>> {
		return next { $0.timestamp(context: context) }
	}
	
	func all(context: Exec = .direct, test: @escaping (Interface.OutputValue) -> Bool) -> SignalChannel<InputInterface, Signal<Bool>> {
		return next { $0.all(context: context, test: test) }
	}
	
	func find(context: Exec = .direct, test: @escaping (Interface.OutputValue) -> Bool) -> SignalChannel<InputInterface, Signal<Bool>> {
		return next { $0.find(context: context, test: test) }
	}
	
	func findIndex(context: Exec = .direct, test: @escaping (Interface.OutputValue) -> Bool) -> SignalChannel<InputInterface, Signal<Int?>> {
		return next { $0.findIndex(context: context, test: test) }
	}
}

extension SignalChannel where Interface.OutputValue: Equatable {
	func find(value: Interface.OutputValue) -> SignalChannel<InputInterface, Signal<Bool>> {
		return next { $0.find(value: value) }
	}
}

extension SignalChannel {
	func defaultIfEmpty(value: Interface.OutputValue) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.defaultIfEmpty(value: value) }
	}
	
	func switchIfEmpty(alternate: Signal<Interface.OutputValue>) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.switchIfEmpty(alternate: alternate) }
	}
}

extension SignalChannel where Interface.OutputValue: Equatable {
	func sequenceEqual(to: Signal<Interface.OutputValue>) -> SignalChannel<InputInterface, Signal<Bool>> {
		return next { $0.sequenceEqual(to: to) }
	}
}

extension SignalChannel {
	func skipUntil<U: SignalInterface>(_ other: U) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.skipUntil(other) }
	}
	
	func skipWhile(context: Exec = .direct, condition: @escaping (Interface.OutputValue) throws -> Bool) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.skipWhile(context: context, condition: condition) }
	}
	
	func skipWhile<U>(initialState initial: U, context: Exec = .direct, condition: @escaping (inout U, Interface.OutputValue) throws -> Bool) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.skipWhile(initialState: initial, context: context, condition: condition) }
	}
	
	func takeUntil<U: SignalInterface>(_ other: U) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.takeUntil(other) }
	}
	
	func takeWhile(context: Exec = .direct, condition: @escaping (Interface.OutputValue) throws -> Bool) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.takeWhile(context: context, condition: condition) }
	}
	
	func takeWhile<U>(initialState initial: U, context: Exec = .direct, condition: @escaping (inout U, Interface.OutputValue) throws -> Bool) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.takeWhile(initialState: initial, context: context, condition: condition) }
	}
	
	func foldAndFinalize<U, V>(_ initial: V, context: Exec = .direct, finalize: @escaping (V) throws -> U?, fold: @escaping (V, Interface.OutputValue) throws -> V) -> SignalChannel<InputInterface, Signal<U>> {
		return next { $0.foldAndFinalize(initial, context: context, finalize: finalize, fold: fold) }
	}
}

extension SignalChannel where Interface.OutputValue: BinaryInteger {
	func average() -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.average() }
	}
}

extension SignalChannel {
	func concat(_ other: Signal<Interface.OutputValue>) -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.concat(other) }
	}
	
	func count() -> SignalChannel<InputInterface, Signal<Int>> {
		return next { $0.count() }
	}
}

extension SignalChannel where Interface.OutputValue: Comparable {
	func min() -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.min() }
	}
	
	func max() -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.max() }
	}
}

extension SignalChannel {
	func aggregate<U>(_ initial: U, context: Exec = .direct, fold: @escaping (U, Interface.OutputValue) -> U) -> SignalChannel<InputInterface, Signal<U>> {
		return next { $0.aggregate(initial, context: context, fold: fold) }
	}
}

extension SignalChannel where Interface.OutputValue: Numeric {
	func sum() -> SignalChannel<InputInterface, Signal<Interface.OutputValue>> {
		return next { $0.sum() }
	}
}

import Foundation

#if SWIFT_PACKAGE
	import CwlUtils
#endif

/// Instances of `SignalActionTarget` can be used as the "target" of Cocoa "target-action" events and the result will be emitted as a signal.
/// Instance of this class are owned by the output `signal` so if you're holding onto the signal, you can drop references to this class itself.
class SignalActionTarget: NSObject, SignalInterface {
	// Ownership note: we are owned by the output signal so we only weakly retain it.
	private weak var stored: SignalMulti<Any?>? = nil
	private var input: SignalInput<Any?>? = nil
	
	/// The `signal` emits the actions received
	var signal: Signal<Any?> {
		// If there's a current signal output, return it
		if let so = stored {
			return so
		}
		
		let s = Signal<Any?>.generate { i in self.input = i }.continuous()
		stored = s
		return s
	}
	
	/// Receiver function for the target-action events
	///
	/// - Parameter sender: typical target-action "sender" parameter
	@IBAction func cwlSignalAction(_ sender: Any?) {
		_ = input?.send(value: sender)
	}
	
	/// Convenience accessor for `#selector(SignalActionTarget<Value>.cwlSignalAction(_:))`
	static var selector: Selector { return #selector(SignalActionTarget.cwlSignalAction(_:)) }
}

/// Like `SignalActionTarget` but with a second action method connected to the same target. Useful for situations like NSTableView targets which send single-click and double-click to the same target.
class SignalDoubleActionTarget: SignalActionTarget {
	// Ownership note: we are owned by the output signal so we only weakly retain it.
	private weak var secondStored: SignalMulti<Any?>? = nil
	private var secondInput: SignalInput<Any?>? = nil

	/// The `signal` emits the actions received
	var secondSignal: SignalMulti<Any?> {
		// If there's a current signal output, return it
		if let so = secondStored {
			return so
		}
		
		// Otherwise, create a new one
		let s = Signal<Any?>.generate { i in self.secondInput = i }.continuous()
		secondStored = s
		return s
	}

	/// Receiver function for "secondary" target-action events
	///
	/// - Parameter sender: typical target-action "sender" parameter
	@IBAction func cwlSignalSecondAction(_ sender: Any?) {
		_ = secondInput?.send(value: sender)
	}
	
	/// Convenience accessor for `#selector(SignalDoubleActionTarget<Value>.cwlSignalSecondAction(_:))`
	static var secondSelector: Selector { return #selector(SignalDoubleActionTarget.cwlSignalSecondAction(_:)) }
}

/// This enum contains errors that might be emitted by `signalKeyValueObserving`
///
/// - missingChangeDictionary: the observation failed to supply a change dictionary
enum SignalObservingError: Error {
	case missingChangeDictionary
}

/// Observe a property via key-value-observing and emit the changes as a Signal<OutputValue> on the condition that the emitted `Any` value can be dynamically cast (`as?`) to `OutputValue`
///
/// - Parameters:
///   - source: will have `addObserver(_:forKeyPath:options:context:)` invoked on it
///   - keyPath: passed to `addObserver(_:forKeyPath:options:context:)`
///   - initial: if true, NSKeyValueObservingOptions.initial is included in the options passed to `addObserver(_:forKeyPath:options:context:)`
/// - Returns: a signal which emits the observation results that match the expected type
extension Signal {
	static func keyValueObserving<Source: NSObject>(_ source: Source, keyPath: KeyPath<Source, OutputValue>, initial: Bool = true) -> Signal<OutputValue> {
		var observer: NSObjectProtocol?
		return Signal<OutputValue>.generate { [weak source] (input: SignalInput<OutputValue>?) -> Void in
			guard let i = input, let s = source else {
				observer = nil
				return
			}
			let options = NSKeyValueObservingOptions.new.union(initial ? NSKeyValueObservingOptions.initial : NSKeyValueObservingOptions())
			observer = s.observe(keyPath, options: options) { (object, value) in
				if let nv = value.newValue {
					i.send(nv)
				}
			}
			withExtendedLifetime(observer) {}
		}
	}
}

extension Signal where OutputValue == Notification {
	/// Observe a notification
	///
	/// - Parameters:
	///   - center: the NotificationCenter where addObserver will be invoked (`NotificationCenter.default` is the default)
	///   - name: the Notification.Name to observer (nil is default)
	///   - object: the object to observer (nil is default)
	/// - Returns: a signal which emits the observation results
	static func notifications(from center: NotificationCenter = NotificationCenter.default, name: Notification.Name? = nil, object: AnyObject? = nil) -> Signal<OutputValue> {
		var observerObject: NSObjectProtocol?
		return Signal<Notification>.generate { [weak object] input in
			if let o = observerObject {
				NotificationCenter.default.removeObserver(o)
			}
			if let i = input {
				observerObject = center.addObserver(forName: name, object: object, queue: nil) { n in
					i.send(value: n)
				}
			}
		}
	}
}

@available(*, deprecated, message: "Use Signal<Notification>.notifications")
func signalFromNotifications(center: NotificationCenter = NotificationCenter.default, name: Notification.Name? = nil, object: AnyObject? = nil) -> Signal<Notification> {
	return Signal.notifications(from: center, name: name, object: object)
}

extension Signal {
	/// Attaches a SignalOutput that applies all values to a target NSObject using key value coding via the supplied keyPath. The property must match the runtime type of the Signal signal values or a precondition failure will be raised.
	///
	/// - Parameters:
	///   - context: the execution context where the setting will occur
	///   - target: the object upon which `setValue(_:forKeyPath:)` will be invoked
	///   - keyPath: passed to `setValue(_:forKeyPath:)`
	/// - Returns: the `SignalOutput` created by this action (releasing the output will cease any further setting)
	func kvcSetter(context: Exec, target: NSObject, keyPath: String) -> SignalOutput<OutputValue> {
		return subscribeValues(context: context) { [weak target] (value: OutputValue) -> Void in
			target?.setValue(value, forKeyPath: keyPath)
		}
	}
}

extension Signal where OutputValue == Date {
	/// A convenience wrapper around Signal.interval that emits a Date
	///
	/// - Parameters:
	///   - interval: time between emitted Date values (default is 1 second)
	///   - initialInterval: time until first emitted Date value (default is zero)
	/// - Returns: a `Signal<Date>` that emits according to the described intervals
	static func date(_ interval: DispatchTimeInterval = .seconds(1), initial initialInterval: DispatchTimeInterval? = .seconds(0), context: Exec = .direct) -> Signal<OutputValue> {
		return Signal<Int>.interval(interval, initial: initialInterval, context: context).transform { r in
			switch r {
			case .success: return .value(Date())
			case .failure(let e): return .end(e)
			}
		}
	}
}

import Foundation

#if SWIFT_PACKAGE
	import CwlUtils
#endif

// All transformations on a Signal are built on top of the following functions, implemented in CwlSignal.swift
extension SignalInterface {
	func subscribe(context: Exec = .direct, _ handler: @escaping (Result<OutputValue, SignalEnd>) -> Void) -> SignalOutput<OutputValue> {
		return signal.subscribe(context: context, handler)
	}
	func subscribeWhile(context: Exec = .direct, _ handler: @escaping (Result<OutputValue, SignalEnd>) -> Bool) {
		return signal.subscribeWhile(context: context, handler)
	}
	func junction() -> SignalJunction<OutputValue> {
		return signal.junction()
	}
	func transform<U>(context: Exec = .direct, _ processor: @escaping (Result<OutputValue, SignalEnd>) -> Signal<U>.Next) -> Signal<U> {
		return signal.transform(context: context, processor)
	}
	func transform<S, U>(initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, Result<OutputValue, SignalEnd>) -> Signal<U>.Next) -> Signal<U> {
		return signal.transform(initialState: initialState, context: context, processor)
	}
	func combine<U: SignalInterface, V>(_ second: U, context: Exec = .direct, _ processor: @escaping (EitherResult2<OutputValue, U.OutputValue>) -> Signal<V>.Next) -> Signal<V> {
		return signal.combine(second, context: context, processor)
	}
	func combine<U: SignalInterface, V: SignalInterface, W>(_ second: U, _ third: V, context: Exec = .direct, _ processor: @escaping (EitherResult3<OutputValue, U.OutputValue, V.OutputValue>) -> Signal<W>.Next) -> Signal<W> {
		return signal.combine(second, third, context: context, processor)
	}
	func combine<U: SignalInterface, V: SignalInterface, W: SignalInterface, X>(_ second: U, _ third: V, _ fourth: W, context: Exec = .direct, _ processor: @escaping (EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>) -> Signal<X>.Next) -> Signal<X> {
		return signal.combine(second, third, fourth, context: context, processor)
	}
	func combine<U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y>(_ second: U, _ third: V, _ fourth: W, _ fifth: X, context: Exec = .direct, _ processor: @escaping (EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>) -> Signal<Y>.Next) -> Signal<Y> {
		return signal.combine(second, third, fourth, fifth, context: context, processor)
	}
	func combine<S, U: SignalInterface, V>(_ second: U, initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult2<OutputValue, U.OutputValue>) -> Signal<V>.Next) -> Signal<V> {
		return signal.combine(second, initialState: initialState, context: context, processor)
	}
	func combine<S, U: SignalInterface, V: SignalInterface, W>(_ second: U, _ third: V, initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult3<OutputValue, U.OutputValue, V.OutputValue>) -> Signal<W>.Next) -> Signal<W> {
		return signal.combine(second, third, initialState: initialState, context: context, processor)
	}
	func combine<S, U: SignalInterface, V: SignalInterface, W: SignalInterface, X>(_ second: U, _ third: V, _ fourth: W, initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>) -> Signal<X>.Next) -> Signal<X> {
		return signal.combine(second, third, fourth, initialState: initialState, context: context, processor)
	}
	func combine<S, U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y>(_ second: U, _ third: V, _ fourth: W, _ fifth: X, initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>) -> Signal<Y>.Next) -> Signal<Y> {
		return signal.combine(second, third, fourth, fifth, initialState: initialState, context: context, processor)
	}
	func continuous(initialValue: OutputValue) -> SignalMulti<OutputValue> {
		return signal.continuous(initialValue: initialValue)
	}
	func continuous() -> SignalMulti<OutputValue> {
		return signal.continuous()
	}
	func continuousWhileActive() -> SignalMulti<OutputValue> {
		return signal.continuousWhileActive()
	}
	func playback() -> SignalMulti<OutputValue> {
		return signal.playback()
	}
	func cacheUntilActive() -> Signal<OutputValue> {
		return signal.cacheUntilActive()
	}
	func multicast() -> SignalMulti<OutputValue> {
		return signal.multicast()
	}
	func customActivation(initialValues: Array<OutputValue> = [], context: Exec = .direct, _ updater: @escaping (_ cachedValues: inout Array<OutputValue>, _ cachedError: inout SignalEnd?, _ incoming: Result<OutputValue, SignalEnd>) -> Void) -> SignalMulti<OutputValue> {
		return signal.customActivation(initialValues: initialValues, context: context, updater)
	}
	func reduce<State>(initialState: State, context: Exec = .direct, _ reducer: @escaping (_ state: State, _ message: OutputValue) throws -> State) -> SignalMulti<State> {
		return signal.reduce(initialState: initialState, context: context, reducer)
	}
	func capture() -> SignalCapture<OutputValue> {
		return signal.capture()
	}
}

extension Signal {
	// Like `create` but also provides a trailing closure to transform the `Signal` normally returned from `create` and in its place, return the result of the transformation.
	//
	// - Parameter compose: a trailing closure which receices the `Signal` as a parameter and any result is returned as the second tuple parameter from this function
	// - Returns: a (`SignalInput`, U) tuple where `SignalInput` is the input to the signal graph and `U` is the return value from the `compose` function.
	// - Throws: rethrows any error from the closure
	static func create<U>(compose: (Signal<OutputValue>) throws -> U) rethrows -> (input: SignalInput<OutputValue>, composed: U) {
		let (i, s) = Signal<OutputValue>.create()
		return (i, try compose(s))
	}
	
	/// A version of `generate` that retains the latest `input` so it doesn't automatically close the signal when the input falls out of scope. This enables a generator that never closes (lives until deactivation).
	///
	/// - Parameters:
	///   - context: the `activationChange` will be invoked in this context
	///   - activationChange: receives inputs on activation and nil on each deactivation
	/// - Returns: the constructed `Signal`
	static func retainedGenerate(context: Exec = .direct, activationChange: @escaping (SignalInput<OutputValue>?) -> Void) -> Signal<OutputValue> {
		var latestInput: SignalInput<OutputValue>? = nil
		return .generate(context: context) { input in
			latestInput = input
			withExtendedLifetime(latestInput) {}
			activationChange(input)
		}
	}
	
	/// Change the default execution to an asynchronous context – typically the global concurrent queue.
	///
	/// This transformation exists as an optimization to multiple stages that must all run in the same queue (for thread-safety reasons) but also want to run asynchronously (to avoid blocking main or calling queues). e.g.:
	/// ```
	/// signal
	///    .map(context: myAsyncQueue) { v in work1(v) }
	///    .map(context: myAsyncQueue) { v in work2(v) }
	/// ```
	///
	/// The executation will not stay on `myAsyncQueue` between these stages... `Signal` must exit any non-reentrant context at the end of a processing stage as part of its thread safety rules. This means that execution through this pipeline takes the following path:
	///
	/// 1. asynchronously transfer to `myAsyncQueue` and run work1
	/// 2. asynchronously transfer to the dispatch global concurrent queue to leave `myAsyncQueue`
	/// 3. asynchronously transfer to `myAsyncQueue` and run work2
	/// 4. asynchronously transfer to the dispatch global concurrent queue to leave `myAsyncQueue`
	///
	/// This involves 4 asynchronous transfers, each of which has a latency of about 5 microseconds, leading to 20 microseconds minimum latency and a maximum throughput of 50 000 per second, when `work1` and `work2` are trivial.
	///
	/// Instead consider the following:
	/// ```
	/// signal
	///    .scheduleAsync()
	///    .map(context: mySyncQueue) { v in work1(v) }
	///    .map(context: mySyncQueue) { v in work2(v) }
	/// ```
	///
	/// Values travelling through this pipeline:
	/// 1. asynchronously transfer to the dispatch global concurrent queue
	/// 2. synchronously invoke on `mySyncQueue` and run work1
	/// 3. synchronously invoke on `mySyncQueue` and run work2
	///
	/// This pipeline offers the same thread safety – `work1` and `work2` are still invoked on the same serial queue – and is still asynchronous. But this arrangement involves 1 asynchronous transfer and 2 synchronous queue invocations, leading to around 7 microseconds minimum latency and a maximum throughput of nearly 150 000 per second, when `work1` and `work2` are trivial –– around 3 times faster (an advantage that increases for pipelines with more stages).
	///
	/// NOTE: there is no equivalent `scheduleMain` for transferring back to the main thread because the `Exec.main` context is reentrant (checks the current thread and directly invokes if `Thread.isMainThread` returns `true`) so `Signal` does not need to exit the context at the end of each pipeline stage. This function primarily exists to optimize DispatchQueues (e.g. `Exec.asyncQueue`) which are not reentrant.
	///
	/// - Parameter relativeTo: the global scheduling will be achieved by calling `relativeAsync` on this context.
	/// - Parameter qos: used as a parameter to `relativeAsync` to override the `QoSClass`, if desired. Default: `nil`
	/// - Returns: a signal which is transferred to an async context.
	func scheduleAsync(relativeTo: Exec = .direct, qos: DispatchQoS.QoSClass? = nil) -> Signal<OutputValue> {
		return transform(context: relativeTo.relativeAsync(qos: qos), Signal<OutputValue>.Next.single)
	}
}

extension SignalInputInterface {
	/// A convenience version of `send` that wraps a value in `Result.success` before sending
	///
	/// - Parameter value: will be wrapped and sent
	/// - Returns: the return value from the underlying `send(result:)` function
	func send(result: Signal<InputValue>.Result) {
		input.send(result: result)
	}
	
	/// A convenience version of `send` that wraps a value in `Result.success` before sending
	///
	/// - Parameter value: will be wrapped and sent
	/// - Returns: the return value from the underlying `send(result:)` function
	func send(value: InputValue) {
		input.send(result: .success(value))
	}
	
	/// A convenience version of `send` that wraps a value in `Result.success` before sending
	///
	/// - Parameter value: will be wrapped and sent
	/// - Returns: the return value from the underlying `send(result:)` function
	func send(_ values: InputValue...) {
		let i = self.input
		for v in values {
			i.send(result: .success(v))
		}
	}
	
	/// A convenience version of `send` that wraps a value in `Result.success` before sending
	///
	/// - Parameter value: will be wrapped and sent
	/// - Returns: the return value from the underlying `send(result:)` function
	func send<S: Sequence>(sequence: S) where S.Iterator.Element == InputValue {
		let i = self.input
		for v in sequence {
			i.send(result: .success(v))
		}
	}
	
	/// A convenience version of `send` that wraps an error in `Result.failure` before sending
	///
	/// - Parameter error: will be wrapped and sent
	/// - Returns: the return value from the underlying `send(result:)` function
	func send(error: Error) {
		input.send(result: .failure(.other(error)))
	}
	
	/// A convenience version of `send` that wraps an error in `Result.failure` before sending
	///
	/// - Parameter error: will be wrapped and sent
	/// - Returns: the return value from the underlying `send(result:)` function
	func send(end: SignalEnd) {
		input.send(result: .failure(end))
	}
	
	/// Sends a `Result.failure(SignalEnd.complete)`
	///
	/// - Returns: the return value from the underlying `send(result:)` function
	func complete() {
		input.send(result: .failure(.complete))
	}

	@available(*, deprecated, message: "Renamed `complete`")
	func close() {
		complete()
	}
}

extension Signal.Next {
	static func value(_ value: OutputValue) -> Signal<OutputValue>.Next {
		return .single(.success(value))
	}
	
	static func value(_ value: OutputValue, end: SignalEnd) -> Signal<OutputValue>.Next {
		return .array([.success(value), .failure(end)])
	}
	
	static func values(_ value: OutputValue...) -> Signal<OutputValue>.Next {
		return .array(value.map { Signal<OutputValue>.Result.success($0) })
	}
	
	static func values(_ value: OutputValue..., end: SignalEnd) -> Signal<OutputValue>.Next {
		return .array(value.map { Signal<OutputValue>.Result.success($0) }.appending(.failure(end)))
	}
	
	static func values<OutputValue, S: Sequence>(sequence: S) -> Signal<OutputValue>.Next where S.Element == OutputValue {
		return .array(sequence.map { Signal<OutputValue>.Result.success($0) })
	}
	
	static func values<OutputValue, S: Sequence>(sequence: S, end: SignalEnd) -> Signal<OutputValue>.Next where S.Element == OutputValue {
		return .array(sequence.map { Signal<OutputValue>.Result.success($0) }.appending(.failure(end)))
	}
	
	static func error(_ error: Error) -> Signal<OutputValue>.Next {
		return .single(.failure(.other(error)))
	}
	
	static func end(_ end: SignalEnd) -> Signal<OutputValue>.Next {
		return .single(.failure(end))
	}
	
	static func complete() -> Signal<OutputValue>.Next {
		return .single(.failure(.complete))
	}
}

/// Used by the Signal<OutputValue>.combine(second:context:handler:) method
enum EitherValue2<U, V> {
	case value1(U)
	case value2(V)
}

/// Used by the Signal<OutputValue>.combine(second:third:context:handler:) method
enum EitherValue3<U, V, W> {
	case value1(U)
	case value2(V)
	case value3(W)
}

/// Used by the Signal<OutputValue>.combine(second:third:fourth:context:handler:) method
enum EitherValue4<U, V, W, X> {
	case value1(U)
	case value2(V)
	case value3(W)
	case value4(X)
}

/// Used by the Signal<OutputValue>.combine(second:third:fourth:fifth:context:handler:) method
enum EitherValue5<U, V, W, X, Y> {
	case value1(U)
	case value2(V)
	case value3(W)
	case value4(X)
	case value5(Y)
}

extension SignalInterface {
	/// Removes any activation from the signal. Useful in cases when you only want *changes*, not the latest value.
	func dropActivation() -> Signal<OutputValue> {
		let pair = Signal<OutputValue>.create()
		try! signal.capture().bind(to: pair.input)
		return pair.signal
	}
	
	/// Causes any activation to be deferred past activation time to the "normal" phase. This avoids the synchronous send rules normally used for activation signals an allows this initial signal to be asynchronously delivered.
	func deferActivation() -> Signal<OutputValue> {
		let pair = Signal<OutputValue>.create()
		try! signal.capture().bind(to: pair.input, resend: true)
		return pair.signal
	}
	
	/// Appends a handler function that transforms the value emitted from this `Signal` into a new `Signal`.
	///
	/// - Parameters:
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: the function invoked for each received `Result`
	/// - Returns: the created `Signal`
	func transformValues<U>(context: Exec = .direct, _ processor: @escaping (OutputValue) -> Signal<U>.Next) -> Signal<U> {
		return transform(context: context) { r in
			switch r {
			case .success(let v): return processor(v)
			case .failure(let e): return .single(.failure(e))
			}
		}
	}
	
	/// Appends a handler function that transforms the value emitted from this `Signal` into a new `Signal`.
	///
	/// - Parameters:
	///   - initialState: the initial value for a state value associated with the handler. This value is retained and if the signal graph is deactivated, the state value is reset to this value.
	///   - context: the `Exec` context used to invoke the `handler`
	///   - processor: the function invoked for each received `Result`
	/// - Returns: the transformed output `Signal`
	func transformValues<S, U>(initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, OutputValue) -> Signal<U>.Next) -> Signal<U> {
		return transform(initialState: initialState, context: context) { s, r in
			switch r {
			case .success(let v): return processor(&s, v)
			case .failure(let e): return .single(.failure(e))
			}
		}
	}

	/// Maps values from self or second to EitherValue2 and merges into a single stream.
	///
	/// - Parameter second: another signal
	/// - Returns: Signal<EitherValue2<OutputValue, U.OutputValue>>
	func combineValues<U: SignalInterface>(_ second: U, closePropagation: SignalEndPropagation = .errors) -> Signal<EitherValue2<OutputValue, U.OutputValue>> {
		return signal.combine(second.signal, initialState: (false, false)) { (closed: inout (Bool, Bool), either: EitherResult2<OutputValue, U.OutputValue>) -> Signal<EitherValue2<OutputValue, U.OutputValue>>.Next in
			switch either {
			case .result1(.failure(let e)):
				if closed.1 || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.0 = true
				return .none
			case .result2(.failure(let e)):
				if closed.0 || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.1 = true
				return .none
			case .result1(.success(let v)): return .value(.value1(v))
			case .result2(.success(let v)): return .value(.value2(v))
			}
		}
	}

	func combineValues<U: SignalInterface, V: SignalInterface>(_ second: U, _ third: V, closePropagation: SignalEndPropagation = .errors) -> Signal<EitherValue3<OutputValue, U.OutputValue, V.OutputValue>> {
		return signal.combine(second.signal, third.signal, initialState: (false, false, false)) { (closed: inout (Bool, Bool, Bool), either: EitherResult3<OutputValue, U.OutputValue, V.OutputValue>) -> Signal<EitherValue3<OutputValue, U.OutputValue, V.OutputValue>>.Next in
			switch either {
			case .result1(.failure(let e)):
				if (closed.1 && closed.2) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.0 = true
				return .end(e)
			case .result2(.failure(let e)):
				if (closed.0 && closed.2) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.1 = true
				return .end(e)
			case .result3(.failure(let e)):
				if (closed.0 && closed.1) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.2 = true
				return .end(e)
			case .result1(.success(let v)): return .value(.value1(v))
			case .result2(.success(let v)): return .value(.value2(v))
			case .result3(.success(let v)): return .value(.value3(v))
			}
		}
	}
	
	func combineValues<U: SignalInterface, V: SignalInterface, W: SignalInterface>(_ second: U, _ third: V, fourth: W, closePropagation: SignalEndPropagation = .errors) -> Signal<EitherValue4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>> {
		return signal.combine(second.signal, third.signal, fourth.signal, initialState: (false, false, false, false)) { (closed: inout (Bool, Bool, Bool, Bool), either: EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>) -> Signal<EitherValue4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>>.Next in
			switch either {
			case .result1(.failure(let e)):
				if (closed.1 && closed.2 && closed.3) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.0 = true
				return .end(e)
			case .result2(.failure(let e)):
				if (closed.0 && closed.2 && closed.3) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.1 = true
				return .end(e)
			case .result3(.failure(let e)):
				if (closed.0 && closed.1 && closed.3) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.2 = true
				return .end(e)
			case .result4(.failure(let e)):
				if (closed.0 && closed.1 && closed.2) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.3 = true
				return .end(e)
			case .result1(.success(let v)): return .value(.value1(v))
			case .result2(.success(let v)): return .value(.value2(v))
			case .result3(.success(let v)): return .value(.value3(v))
			case .result4(.success(let v)): return .value(.value4(v))
			}
		}
	}
	
	func combineValues<U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface>(_ second: U, _ third: V, _ fourth: W, _ fifth: X, closePropagation: SignalEndPropagation = .errors) -> Signal<EitherValue5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>> {
		return signal.combine(second.signal, third.signal, fourth.signal, fifth.signal, initialState: (false, false, false, false, false)) { (closed: inout (Bool, Bool, Bool, Bool, Bool), either: EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>) -> Signal<EitherValue5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>>.Next in
			switch either {
			case .result1(.failure(let e)):
				if (closed.1 && closed.2 && closed.3 && closed.4) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.0 = true
				return .end(e)
			case .result2(.failure(let e)):
				if (closed.0 && closed.2 && closed.3 && closed.4) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.1 = true
				return .end(e)
			case .result3(.failure(let e)):
				if (closed.0 && closed.1 && closed.3 && closed.4) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.2 = true
				return .end(e)
			case .result4(.failure(let e)):
				if (closed.0 && closed.1 && closed.2 && closed.4) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.3 = true
				return .end(e)
			case .result5(.failure(let e)):
				if (closed.0 && closed.1 && closed.2 && closed.3) || closePropagation.shouldPropagateEnd(e) {
					return .end(e)
				}
				closed.4 = true
				return .end(e)
			case .result1(.success(let v)): return .value(.value1(v))
			case .result2(.success(let v)): return .value(.value2(v))
			case .result3(.success(let v)): return .value(.value3(v))
			case .result4(.success(let v)): return .value(.value4(v))
			case .result5(.success(let v)): return .value(.value5(v))
			}
		}
	}

	/// A version of `subscribe` that retains the `SignalOutput` internally, keeping the signal graph alive. The `SignalOutput` is cancelled and released when the signal closes.
	///
	/// NOTE: this subscriber deliberately creates a reference counted loop. If the signal is never closed, it will result in a memory leak. This function should be used only when `self` is guaranteed to close.
	///
	/// - Parameters:
	///   - context: the execution context where the `processor` will be invoked
	///   - handler: will be invoked with each value received and if returns `false`, the output will be cancelled and released
	func subscribeUntilEnd(context: Exec = .direct, _ handler: @escaping (Result<OutputValue, SignalEnd>) -> Void) {
		return signal.subscribeWhile(context: context, { (result: Result<OutputValue, SignalEnd>) -> Bool in
			handler(result)
			return true
		})
	}
	
	/// A convenience version of `subscribe` that only invokes the `processor` on `Result.success`
	///
	/// - Parameters:
	///   - context: the execution context where the `processor` will be invoked
	///   - handler: will be invoked with each value received
	/// - Returns: the `SignalOutput` created by this function
	func subscribeValues(context: Exec = .direct, _ handler: @escaping (OutputValue) -> Void) -> SignalOutput<OutputValue> {
		return signal.subscribe(context: context) { r in
			if case .success(let v) = r {
				handler(v)
			}
		}
	}
	
	/// A convenience version of `subscribeUntilEnd` that only invokes the `processor` on `Result.success`
	///
	/// NOTE: this subscriber deliberately creates a reference counted loop. If the signal is never closed, it will result in a memory leak. This function should be used only when `self` is guaranteed to close.
	///
	/// - Parameters:
	///   - context: the execution context where the `processor` will be invoked
	///   - handler: will be invoked with each value received and if returns `false`, the output will be cancelled and released
	func subscribeValuesUntilEnd(context: Exec = .direct, _ handler: @escaping (OutputValue) -> Void) {
		signal.subscribeUntilEnd(context: context) { r in
			if case .success(let v) = r {
				handler(v)
			}
		}
	}
	
	/// A convenience version of `subscribeWhile` that only invokes the `processor` on `Result.success`
	///
	/// NOTE: this subscriber deliberately creates a reference counted loop. If the signal is never closed and the handler never returns false, it will result in a memory leak. This function should be used only when `self` is guaranteed to close or the handler `false` condition is guaranteed.
	///
	/// - Parameters:
	///   - context: the execution context where the `processor` will be invoked
	///   - handler: will be invoked with each value received and if returns `false`, the output will be cancelled and released
	func subscribeValuesWhile(context: Exec = .direct, _ handler: @escaping (OutputValue) -> Bool) {
		signal.subscribeWhile(context: context) { r in
			if case .success(let v) = r {
				return handler(v)
			} else {
				return false
			}
		}
	}
	
	/// Returns a signal that drops an `initial` number of values from the start of the stream and emits the next value and every `count`-th value after that.
	///
	/// - Parameters:
	///   - count: number of values beteen emissions
	///   - initialSkip: number of values before the first emission
	/// - Returns: the strided signal
	func stride(count: Int, initialSkip: Int = 0) -> Signal<OutputValue> {
		return signal.transform(initialState: count - initialSkip - 1) { (state: inout Int, r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			switch r {
			case .success(let v) where state >= count - 1:
				state = 0
				return .value(v)
			case .success:
				state += 1
				return .none
			case .failure(let e):
				return .end(e)
			}
		}
	}
	
	/// A signal transform function that, instead of creating plain values and emitting them to a `SignalNext`, creates entire signals and adds them to a `SignalMergedInput`. The output of the merge set (which contains the merged output from all of the created signals) forms the signal returned from this function.
	///
	/// NOTE: this function is primarily used for implementing various Reactive X operators.
	///
	/// - Parameters:
	///   - closePropagation: whether signals added to the merge set will close the output
	///   - context: the context where the processor will run
	///   - processor: performs work with values from this `Signal` and the `SignalMergedInput` used for output
	/// - Returns: output of the merge set
	func transformFlatten<U>(closePropagation: SignalEndPropagation = .none, context: Exec = .direct, _ processor: @escaping (OutputValue, SignalMergedInput<U>) throws -> ()) -> Signal<U> {
		return transformFlatten(initialState: (), closePropagation: closePropagation, context: context, { (state: inout (), value: OutputValue, mergedInput: SignalMergedInput<U>) in try processor(value, mergedInput) })
	}
	
	/// A signal transform function that, instead of creating plain values and emitting them to a `SignalNext`, creates entire signals and adds them to a `SignalMergedInput`. The output of the merge set (which contains the merged output from all of the created signals) forms the signal returned from this function.
	///
	/// NOTE: this function is primarily used for implementing various Reactive X operators.
	///
	/// - Parameters:
	///   - initialState: initial state for the state parameter passed into the processor
	///   - closePropagation: whether signals added to the merge set will close the output
	///   - context: the context where the processor will run
	///   - processor: performs work with values from this `Signal` and the `SignalMergedInput` used for output
	/// - Returns: output of the merge set
	func transformFlatten<S, U>(initialState: S, closePropagation: SignalEndPropagation = .errors, context: Exec = .direct, _ processor: @escaping (inout S, OutputValue, SignalMergedInput<U>) throws -> ()) -> Signal<U> {
		let (mergedInput, result) = Signal<U>.createMergedInput()
		var end: SignalEnd? = nil
		let outerSignal = signal.transform(initialState: initialState, context: context) { (state: inout S, r: Result<OutputValue, SignalEnd>) -> Signal<U>.Next in
			switch r {
			case .success(let v):
				do {
					try processor(&state, v, mergedInput)
					return .none
				} catch {
					end = .other(error)
					return .error(error)
				}
			case .failure(let e):
				end = e
				return .end(e)
			}
		}
		
		// Keep the merge set alive at least as long as self
		mergedInput.add(outerSignal, closePropagation: closePropagation)
		
		return result.transform(initialState: nil) { [weak mergedInput] (onDelete: inout OnDelete?, r: Result<U, SignalEnd>) -> Signal<U>.Next in
			if onDelete == nil {
				onDelete = OnDelete {
					end = nil
				}
			}
			switch r {
			case .success(let v): return .value(v)
			case .failure(.cancelled):
				// If the `mergedInput` is `nil` at this point, that means that this `.cancelled` comes from the `mergedInput`, not one of its inputs. We'd prefer in that case to emit the `outerSignal`'s `closeError` rather than follow the `shouldPropagateEnd` logic.
				return .end(mergedInput == nil ? (end ?? .cancelled) : .cancelled)
			case .failure(let e):
				return .end(closePropagation.shouldPropagateEnd(e) ? e : (end ?? .cancelled))
			}
		}
	}

	/// A utility function, used by ReactiveX implementations, that generates "window" durations in single signal from the values in self and a "duration" function that returns duration signals for each value.
	///
	/// - Parameters:
	///   - closePropagation: passed through to the underlying `transformFlatten` call (unlikely to make much different in expected use cases of this function)
	///   - context: the context where `duration` will be invoked
	///   - duration: for each value emitted by `self`, emit a signal
	/// - Returns: a signal of two element tuples
	func valueDurations<Interface: SignalInterface>(closePropagation: SignalEndPropagation = .none, context: Exec = .direct, _ duration: @escaping (OutputValue) -> Interface) -> Signal<(Int, OutputValue?)> {
		return valueDurations(initialState: (), closePropagation: closePropagation, context: context, { (state: inout (), value: OutputValue) -> Interface in duration(value) })
	}

	/// A utility function, used by ReactiveX implementations, that generates "window" durations in single signal from the values in self and a "duration" function that returns duration signals for each value.
	///
	/// - Parameters:
	///   - initialState: initial state for the state parameter passed into the processor
	///   - closePropagation: passed through to the underlying `transformFlatten` call (unlikely to make much different in expected use cases of this function)
	///   - context: the context where `duration` will be invoked
	///   - duration: for each value emitted by `self`, emit a signal
	/// - Returns: a signal of two element tuples
	func valueDurations<Interface: SignalInterface, V>(initialState: V, closePropagation: SignalEndPropagation = .none, context: Exec = .direct, _ duration: @escaping (inout V, OutputValue) -> Interface) -> Signal<(Int, OutputValue?)> {
		return transformFlatten(initialState: (index: 0, userState: initialState), closePropagation: closePropagation, context: context) { (state: inout (index: Int, userState: V), v: OutputValue, mergedInput: SignalMergedInput<(Int, OutputValue?)>) in
			let count = state.index
			let innerSignal = duration(&state.userState, v).transform { (innerResult: Result<Interface.OutputValue, SignalEnd>) -> Signal<(Int, OutputValue?)>.Next in
				switch innerResult {
				case .success: return .none
				case .failure(let e): return .value((count, nil), end: e)
				}
			}
			let prefixedInnerSignal = Signal<(Int, OutputValue?)>.preclosed((count, Optional(v))).combine(innerSignal) { (r: EitherResult2<(Int, OutputValue?), (Int, OutputValue?)>) -> Signal<(Int, OutputValue?)>.Next in
				switch r {
				case .result1(.success(let v)): return .value(v)
				case .result1(.failure): return .none
				case .result2(.success(let v)): return .value(v)
				case .result2(.failure(let e)): return .end(e)
				}
			}

			mergedInput.add(prefixedInnerSignal, closePropagation: .none)
			state.index += 1
		}
	}
	
	/// A continuous signal which alternates between true and false values each time it receives a value.
	///
	/// - Parameter initialState: before receiving the first value
	/// - Returns: the alternating, continuous signal
	func toggle(initialState: Bool = false) -> Signal<Bool> {
		return reduce(initialState: initialState) { (state: Bool, input: OutputValue) -> Bool in
			return !state
		}
	}

	/// A convenience transform to turn a signal of optional values into an signal of array values with one or zero elements.
	///
	/// - Returns: an array signal
	func optionalToArray<U>() -> Signal<[U]> where OutputValue == Optional<U> {
		return signal.transform { (optional: Result<U?, SignalEnd>) -> Signal<[U]>.Next in
			switch optional {
			case .success(.some(let v)): return .value([v])
			case .success: return .value([])
			case .failure(let e): return .end(e)
			}
		}
	}
	
	/// A convenience transform to turn a signal of optional values into an signal of array values with one or zero elements.
	///
	/// - Returns: an array signal
	func optional() -> Signal<OutputValue?> {
		return signal.transform { (optional: Result<OutputValue, SignalEnd>) -> Signal<OutputValue?>.Next in
			return .single(optional.map { $0 as OutputValue? })
		}
	}
	
	/// Joins this `Signal` to a destination `SignalInput`
	///
	/// WARNING: if you bind to a previously joined or otherwise inactive instance of the base `SignalInput` class, this function will have no effect. To get underlying errors, use `junction().bind(to: input)` instead.
	///
	/// - Parameters:
	///   - to: target `SignalInput` to which this signal will be added
	func bind<InputInterface>(to interface: InputInterface) where InputInterface: SignalInputInterface, InputInterface.InputValue == OutputValue {
		let input = interface.input
		if let multiInput = input as? SignalMultiInput<OutputValue> {
			multiInput.add(signal)
		} else {
			_ = try? signal.junction().bind(to: input)
		}
	}
	
	/// Joins this `Signal` to a destination `SignalMergedInput`
	///
	/// - Parameters:
	///   - to: target `SignalMultiInput` to which this signal will be added
	func bind(to input: SignalMergedInput<OutputValue>, closePropagation: SignalEndPropagation, removeOnDeactivate: Bool = true) {
		input.add(signal, closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate)
	}

	func flatMapBind<Interface: SignalInterface, InputInterface: SignalInputInterface>(to interface: Interface, _ transform: @escaping (Interface.OutputValue) -> InputInterface) where InputInterface.InputValue == OutputValue {
		let j = junction()
		interface.subscribeUntilEnd { result in
			switch result {
			case .success(let v): _ = try? j.bind(to: transform(v))
			case .failure: _ = j.disconnect()
			}
		}
	}
	
	/// Joins this `Signal` to a destination `SignalMultiInput` and returns a `Lifetime` that, when cancelled, will remove the `Signal` from the `SignalMultiInput` again.
	///
	/// - Parameters:
	///   - to: target `SignalMultiInput` to which this signal will be added
	/// - Returns: a `Lifetime` that will undo the bind if cancelled or released
	func cancellableBind<InputInterface>(to interface: InputInterface) -> Lifetime where InputInterface: SignalInputInterface, InputInterface.InputValue == OutputValue {
		let input = interface.input
		if let multiInput = input as? SignalMultiInput<OutputValue> {
			let sig = signal
			multiInput.add(sig)
			return OnDelete { [weak multiInput, weak sig] in
				guard let mi = multiInput, let s = sig else { return }
				mi.remove(s)
			}
		} else {
			let j = signal.junction()
			_ = try? j.bind(to: input)
			return j
		}
	}
	
	/// Joins this `Signal` to a destination `SignalMultiInput` and returns a `Lifetime` that, when cancelled, will remove the `Signal` from the `SignalMultiInput` again.
	///
	/// - Parameters:
	///   - to: target `SignalMultiInput` to which this signal will be added
	/// - Returns: a `Lifetime` that will undo the bind if cancelled or released
	func cancellableBind(to input: SignalMergedInput<OutputValue>, closePropagation: SignalEndPropagation, removeOnDeactivate: Bool = true) -> Lifetime {
		let sig = signal
		input.add(sig, closePropagation: closePropagation, removeOnDeactivate: removeOnDeactivate)
		return OnDelete { [weak input, weak sig] in
			guard let i = input, let s = sig else { return }
			i.remove(s)
		}
	}

	/// - Returns: a signal where value in the sequence is accompanied by its zero-indexed position in the sequence
	func enumerated() -> Signal<(offset: Int, element: OutputValue)> {
		return transform(initialState: -1) { index, result in
			index += 1
			return .single(result.map { (offset: index, element: $0) })
		}
	}
	
	/// Given an array of source Signals, returns a single, merged Signal where each value is a tuple of the index in the array and the element from the corresponding source signal. 
	///
	/// - Parameter sequence: an sequence of SignalInterfaces
	/// - Returns: a merged signal of (offset, element) tuples
	static func indexed<S: Sequence>(_ sequence: S) -> Signal<(offset: Int, element: OutputValue)> where S.Element: SignalInterface, OutputValue == S.Element.OutputValue {
		return Signal<(offset: Int, element: OutputValue)>.merge(sequence: sequence.enumerated().map { offset, s in s.map { (offset: offset, element: $0) } })
	}
}

/// This class is used for disconnecting and reconnecting a preceeding signal subgraph from the succeeding signal subgraph. This is useful in cases where you have a generating signal that will automatically pause itself when disconnected (like `Signal.interval`) and you want to disconnect it and reconnect to take advantage of that pause and restart functionality.
/// Internally, this class is a wrapper around a `SignalJunction` (which disconnects the succeeding graph) and a `Signal` (which is the head of the succeeding graph) and 
struct SignalReconnector<OutputValue>: Lifetime {
	let queue = PThreadMutex()
	var disconnectedInput: SignalInput<OutputValue>?
	let junction: SignalJunction<OutputValue>
	
	mutating func reconnect() {
		let input = queue.sync { () -> SignalInput<OutputValue>? in
			let di = disconnectedInput
			disconnectedInput = nil
			return di
		}
		if let i = input {
			_ = try? junction.bind(to: i)
		}
	}
	
	mutating func cancel() {
		junction.cancel()
		queue.sync {
			disconnectedInput?.cancel()
			disconnectedInput = nil
		}
	}
	
	mutating func disconnect() {
		if let i = junction.disconnect() {
			queue.sync {
				disconnectedInput = i
			}
		}
	}
	
	init(preceeding: Signal<OutputValue>, succeeding: SignalInput<OutputValue>, initiallyConnected: Bool = true) {
		disconnectedInput = succeeding
		junction = preceeding.junction()
		if initiallyConnected {
			reconnect()
		}
	}
}

extension SignalInterface {
	/// Create a `SignalReconnector` and a downstream `Signal`. The `SignalReconnector` is used for disconnecting and reconnecting the downstream signal from `self`. This is useful in cases where `self` is a generating signal that automatically pauses itself when disconnected from all outputs (like `Signal.interval`) and you want to take advantage of that pause and restart functionality.
	///
	/// - Parameter initiallyConnected: should the downstream signal be connected when this function returns
	/// - Returns: a tuple of `SignalReconnector` and `Signal`. The reconnector disconnects `self` (upstream) from the `Signal` in the tuple (downstream). 
	func reconnector(initiallyConnected: Bool = true) -> (SignalReconnector<OutputValue>, Signal<OutputValue>) {
		let (i, s) = Signal<OutputValue>.create()
		return (SignalReconnector<OutputValue>(preceeding: signal, succeeding: i, initiallyConnected: initiallyConnected), s)
	}
}

/// This wrapper around `SignalOutput` saves the last received value from the signal so that it can be 'polled' (read synchronously from an arbitrary execution context). This class ensures thread-safety on the read operation.
///
/// The typical use-case for this type of class is in the implementation of delegate methods and similar callback functions that must synchronously return a value.
///
/// Note that there is a semantic difference between this class which is intended to be left active for some time and polled periodically and `SignalCapture` which captures the *activation* value (leaving it running for a duration is pointless). For that reason, the standalone `peek()` function actually uses `SignalCapture` rather than this class (`SignalCapture` is more consistent in the presence of multi-threaded updates since there is no possibility of asychronous updates between creation and reading).
///
/// However, `SignalCapture` can only read activation values (not regular values). Additionally, `peek()` will be less efficient than this class if multiple reads are required since the `SignalCapture` is created and thrown away each time.
///
/// **WARNING**: this class should be avoided where possible since it removes the "reactive" part of reactive programming (changes in the polled value must be detected through other means, usually another subscriber to the underlying `Signal`).
///
final class SignalLatest<OutputValue>: Lifetime {
	var output: SignalOutput<OutputValue>? = nil
	var latest: Result<OutputValue, SignalEnd>? = nil
	let mutex = Exec.syncQueue()
	
	init(signal: Signal<OutputValue>) {
		output = signal.subscribe(context: mutex) { [weak self] r in
			self?.latest = r
		}
	}
	
	var latestResult: Result<OutputValue, SignalEnd>? {
		return mutex.invokeSync { latest }
	}
	
	var latestValue: OutputValue? {
		return mutex.invokeSync { latest?.value }
	}
	
	func cancel() {
		output?.cancel()
	}
}

/// A SignalCapture subscribes to a signal and records any synchronously emitted "activation" values.
/// If there is no value to return or the value can't be emitted synchronously, this error may be returned.
struct SignalCaptureFailedToEmit: Error {}

extension SignalInterface {
	/// Appends a `SignalLatest` listener to the value emitted from this `Signal`. `SignalLatest` adds an output to the signal and remembers the latest result emitted. This latest result can be accessed in a thread-safe way, using `latestValue` or `latestResult`.
	func cacheLatest() -> SignalLatest<OutputValue> {
		return SignalLatest(signal: signal)
	}
	
	/// Internally creates a `SignalCapture` which reads the latest activation value and is immediately discarded.
	///
	/// NOTE: if you're not specifically interested in activation values or you're performing multiple times, the
	/// performance of `cacheLatest` is better.
	///
	/// - Returns: the latest captured value, if any
	/// - Throws: if no value is emitted but a `SignalEnd` is emitted, then the `SignalEnd` will be thrown. If no value or end is emitted, a `SignalCapture.FailedToEmit` error will be thrown.
	func peek() -> OutputValue? {
		return signal.capture().peek()
	}
}

extension SignalCapture: SignalInterface {
	var signal: Signal<OutputValue> { return resume() }
}

extension Result where Failure == SignalEnd {
	/// A minor convenience so that parameters requesting a `Result` can be passed `.signalComplete`
	static var signalComplete: Result<Success, SignalEnd> { return Result<Success, SignalEnd>.failure(.complete) }
	
	/// A convenience extension on `Result` to test if it wraps a `SignalComplete`
	var isComplete: Bool {
		switch self {
		case .failure(.complete): return true
		default: return false
		}
	}
}

import Foundation

#if SWIFT_PACKAGE
	import CwlUtils
#endif

#if swift(>=4)
#else
	typealias Numeric = IntegerArithmetic & ExpressibleByIntegerLiteral
	typealias BinaryInteger = IntegerArithmetic & ExpressibleByIntegerLiteral
#endif

/// Errors used by the Reactive extensions on Signal.
/// - timeout: used to close the stream when the Signal.timeout function reaches its limit.
enum SignalReactiveError: Error {
	case timeout
}

/// For `mapActivation`, in the event of multiple activation values, you must device which of the activation values to process using the activation closure.
///
/// - all: process all activation values using the `activation` closure and all remaining values using the `remainder` closure (default)
/// - first: process the first activation value using the `activation` closure and process any remaining activation values using the `remainder` closure 
/// - last: process the last activation value using the `activation` closure, *discarding* all preceeding activation values, then process all subsequent values using the `remainder` closure
enum SignalActivationSelection {
	case all
	case first
	case last
}

extension SignalInterface {
	/// - Note: the [Reactive X operator "Create"](http://reactivex.io/documentation/operators/create.html) is considered unnecessary, given the `CwlSignal.Signal.generate` and `CwlSignal.Signal.create` methods.
	
	/// - Note: the [Reactive X operator "Defer"](http://reactivex.io/documentation/operators/defer.html) is considered not applicable, given the different semantics of "activation" with `CwlSignal.Signal`. If `Defer`-like behavior is desired, either a method that constructs and returns a new `Signal` graph should be used (if a truly distinct graph is desired) or `CwlSignal.Signal.generate` should be used (if wait-until-activated behavior is desired).
}

extension Signal {
	/// Implementation of [Reactive X operator "From"](http://reactivex.io/documentation/operators/from.html) in the context of the Swift `Sequence`
	///
	/// See also: `preclosed(:)`, which is a shareable activation sequence
	/// See also: `just(:)`, which offers the same functionality but accepts a variable argument list instead of a sequence
	///
	/// NOTE: it is possible to specify a `nil` error to have the signal remain at the end of the sequence.
	///
	/// - parameter values: A Swift `Sequence` that generates the signal values.
	/// - parameter end: The error with which to close the sequence. Can be `nil` to leave the sequence (default: `SignalEnd.complete`)
	/// - parameter context: the `Exec` where the `SequenceType` will be enumerated (default: .direct).
	/// - returns: a signal that emits `values` and then closes
	static func from<S: Sequence>(_ sequence: S, end: SignalEnd? = .complete, context: Exec = .direct) -> Signal<OutputValue> where S.Iterator.Element == OutputValue {
		if let e = end {
			return generate(context: context) { input in
				guard let i = input else { return }
				for v in sequence {
					if let _ = i.send(result: .success(v)) {
						break
					}
				}
				i.send(end: e)
			}
		} else {
			return retainedGenerate(context: context) { input in
				guard let i = input else { return }
				for v in sequence {
					if let _ = i.send(result: .success(v)) {
						break
					}
				}
			}
		}
	}

	/// Implementation of [Reactive X operator "Never"](http://reactivex.io/documentation/operators/empty-never-throw.html)
	///
	/// Implemented as `.from([], end: nil)`
	///
	/// - returns: a non-sending, non-closing signal of the desired type
	static func never() -> Signal<OutputValue> {
		return .from([], end: nil)
	}
	
	/// - Implementation of [Reactive X operator "Just"](http://reactivex.io/documentation/operators/just.html)
	///
	/// See also: `from(:)`, which sends a sequence of values (optionally on a specific context)
	/// See also: `preclosed(:)`, which is a shareable activation sequence
	///
	/// - Parameters:
	///   - value: the value to send
	///   - end: if non-nil, sent after value to close the stream 
	/// - Returns: a signal that will emit `value` and (optionally) close
	static func just(_ values: OutputValue..., end: SignalEnd? = .complete) -> Signal<OutputValue> {
		return .from(values, end: end)
	}

	/// - Implementation of [Reactive X operator "Throw"](http://reactivex.io/documentation/operators/empty-never-throw.html)
	///
	/// See also: `from(:)`, which sends a sequence of values (optionally on a specific context)
	/// See also: `preclosed(:)`, which is a shareable activation sequence
	///
	/// - Parameters:
	///   - value: the value to send
	///   - end: if non-nil, sent after value to close the stream 
	/// - Returns: a signal that will emit `value` and (optionally) close
	static func error(_ error: Error) -> Signal<OutputValue> {
		return Signal<OutputValue>.from([], end: .other(error))
	}

	/// - Implementation of [Reactive X operator "Empty"](http://reactivex.io/documentation/operators/empty-never-throw.html)
	///
	/// See also: `from(:)`, which sends a sequence of values (optionally on a specific context)
	///
	/// - Returns: a signal that will emit no values and then close
	static func empty() -> Signal<OutputValue> {
		return Signal<OutputValue>.from([])
	}
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "To"](http://reactivex.io/documentation/operators/to.html) in the context of the Swift `Sequence`
	///
	/// WARNING: Because it blocks the receiving thread, and because it undermines the principle of *reactive* programming, this function should only be used in specific circumstances.
	///
	/// `SignalSequence` subscribes to `self` and blocks. This means that if any earlier signals in the graph force processing on the same context where `SignalSequence` is iterated, a deadlock may occur between the iteration and the signal processing.
	/// This function is safe only when you can guarantee all parts of the signal graph are independent of the blocking context.
	func toSequence() -> SignalSequence<OutputValue> {
		return SignalSequence<OutputValue>(signal)
	}
}

/// Represents a Signal<OutputValue> converted to a synchronously iterated sequence. Values can be obtained using typical SequenceType actions. The error that ends the sequence is available through the `error` property.
class SignalSequence<OutputValue>: Sequence, IteratorProtocol {
	typealias GeneratorType = SignalSequence<OutputValue>
	typealias ElementType = OutputValue
	
	let semaphore = DispatchSemaphore(value: 0)
	let context = Exec.syncQueue()
	var output: SignalOutput<OutputValue>? = nil
	
	var queued: Array<OutputValue> = []
	
	/// Error type property is `nil` before the end of the signal is reached and contains the error used to close the signal in other cases
	var end: SignalEnd?
	
	// Only intended to be constructed by `Signal.toSequence`
	//
	// - Parameter signal: the signal whose values will be iterated by this sequence
	init(_ signal: Signal<OutputValue>) {
		output = signal.subscribe(context: context) { [weak self] (r: Result<OutputValue, SignalEnd>) in
			guard let s = self else { return }
			switch r {
			case .success(let v):
				s.queued.append(v)
				s.semaphore.signal()
			case .failure(let e):
				s.end = e
				s.semaphore.signal()
			}
		}
	}
	
	/// Stops listening to the signal and set the error value to SignalComplete.cancelled
	func cancel() {
		context.invokeSync {
			self.end = .cancelled
			self.output?.cancel()
			self.semaphore.signal()
		}
	}
	
	/// Implementation of GeneratorType method.
	func next() -> OutputValue? {
		_ = semaphore.wait(timeout: DispatchTime.distantFuture)
		return context.invokeSync { [weak self] () -> OutputValue? in
			guard let s = self else { return nil }
			if !s.queued.isEmpty {
				return s.queued.removeFirst()
			} else {
				// Signal the sempahore so that `nil` can be fetched again.
				s.semaphore.signal()
				return nil
			}
		}
	}
	
	deinit {
		if end == nil {
			semaphore.signal()
		}
	}
}

extension SignalInterface where OutputValue == Int {

	/// Implementation of [Reactive X operator "Interval"](http://reactivex.io/documentation/operators/interval.html)
	///
	/// - Parameters:
	///   - interval: duration between values
	///   - initialInterval: duration until first value
	///   - context: execution context where the timer will run
	/// - Returns: the interval signal
	static func interval(_ interval: DispatchTimeInterval = .seconds(1), initial initialInterval: DispatchTimeInterval? = nil, context: Exec = .global) -> Signal<Int> {
		// We need to protect the `count` variable and make sure that out-of-date timers don't update it so we use a `serialized` context for the `generate` and the timers, since the combination of the two will ensure that these requirements are met.
		let serialContext = context.serialized()
		var timer: Lifetime? = nil
		var count = 0
		
		return Signal<Int>.generate(context: serialContext) { input in
			guard let i = input else {
				timer?.cancel()
				count = 0
				return
			}
			
			let repeater = {
				timer = serialContext.periodicTimer(interval: interval) {
					i.send(value: count)
					count += 1
				}
			}
			
			if let initial = initialInterval {
				if initial == .seconds(0) {
					i.send(value: count)
					count += 1
					repeater()
				} else {
					timer = serialContext.singleTimer(interval: initial) {
						i.send(value: count)
						count += 1
						repeater()
					}
				}
			} else {
				repeater()
			}
		}
	}
}

extension SignalInterface {
	/// - Note: the [Reactive X operator `Range`](http://reactivex.io/documentation/operators/range.html) is considered unnecessary, given that ranges are already handled by `from(:)`.
}

extension Signal {
	/// Implementation of [Reactive X operator "Repeat"](http://reactivex.io/documentation/operators/repeat.html) for a Swift `CollectionType`
	///
	/// - Parameters:
	///   - values: A Swift `CollectionType` that generates the signal values.
	///   - count: the number of times that `values` will be repeated.
	///   - context: the `Exec` where the `SequenceType` will be enumerated.
	/// - Returns: a signal that emits `values` a `count` number of times and then closes
	static func repeatCollection<C: Collection>(_ values: C, count: Int, context: Exec = .direct) -> Signal<OutputValue> where C.Iterator.Element == OutputValue {
		return generate(context: context) { input in
			guard let i = input else { return }
			for _ in 0..<count {
				for v in values {
					if i.send(result: .success(v)) != nil {
						break
					}
				}
			}
			i.complete()
		}
	}
	
	/// Implementation of [Reactive X operator "Start"](http://reactivex.io/documentation/operators/start.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `f` will be evaluated (default: .direct).
	///   - f: a function that is run to generate the value.
	/// - Returns: a signal that emits a single value emitted from a function
	static func start(context: Exec = .direct, f: @escaping () -> OutputValue) -> Signal<OutputValue> {
		return Signal.generate(context: context) { input in
			guard let i = input else { return }
			i.send(value: f())
			i.complete()
		}
	}
	
	/// Implementation of [Reactive X operator "Timer"](http://reactivex.io/documentation/operators/timer.html)
	///
	/// - Parameters:
	///   - interval: the time until the value is sent.
	///   - value: the value that will be sent before closing the signal (if `nil` then the signal will simply be closed at the end of the timer)
	///   - context: execution context where the timer will be run
	/// - Returns: the timer signal
	static func timer(interval: DispatchTimeInterval, value: OutputValue? = nil, context: Exec = .global) -> Signal<OutputValue> {
		var timer: Lifetime? = nil
		return Signal<OutputValue>.generate(context: context) { input in
			if let i = input {
				timer = context.singleTimer(interval: interval) {
					if let v = value {
						i.send(value: v)
					}
					i.complete()
				}
			} else {
				timer?.cancel()
			}
		}
	}
}
	
extension SignalInterface {
	/// A shared function for emitting a boundary signal usable by the timed, non-overlapping buffer/window functions buffer(timeshift:count:continuous:behavior:) or window(timeshift:count:continuous:behavior:)
	///
	/// - Parameters:
	///   - interval: maximum duration between boundaries
	///   - count: maximum number of signal values between boundaries
	///   - continuous: timer is paused immediately after a boundary until the next value is received
	///   - context: execution context where the timer will be run
	/// - Returns: the boundary signal
	private func timedCountedBoundary(interval: DispatchTimeInterval, count: Int, continuous: Bool, context: Exec) -> Signal<Void> {
		// An interval signal
		let intSig = Signal.interval(interval, context: context)
		
		if count == Int.max {
			// If number of values per boundary is infinite, then all we need is the timer signal
			return intSig.map { v in () }
		}
		
		// The interval signal may need to be disconnectable so create a junction
		let intervalJunction = intSig.junction()
		let (initialInput, sig) = Signal<Int>.create()
		
		// Continuous signals don't really need the junction. Just connect it immediately and ignore it.
		if continuous {
			// Both `intervalJunction` and `initialInput` are newly created so this can't be an error
			try! intervalJunction.bind(to: initialInput)
		}
		
		return combine(sig, initialState: (0, nil)) { (state: inout (count: Int, timerInput: SignalInput<Int>?), cr: EitherResult2<OutputValue, Int>) -> Signal<Void>.Next in
			var send = false
			switch cr {
			case .result1(.success):
				// Count the values received per window
				state.count += 1
				
				// If we hit `count` values, trigger the boundary signal
				if state.count == count {
					send = true
				} else if !continuous, let i = state.timerInput {
					// If we're not continuous, make sure the timer is connected
					do {
						try intervalJunction.bind(to: i)
					} catch {
						return .end(.other(error))
					}
				}
			case .result1(.failure(let e)):
				// If there's an error on the `self` signal, forward it on.
				return .end(e)
			case .result2(.success):
				// When the timer fires, trigger the boundary signal
				send = true
			case .result2(.failure(let e)):
				// If there's a timer error, close
				return .end(e)
			}
			
			if send {
				// Reset the count and – if not continuous – disconnect the timer until we receive a signal from `self`
				state.count = 0
				if !continuous {
					state.timerInput = intervalJunction.disconnect()
				}
				
				// Send the boundary signal
				return .value(())
			} else {
				return .none
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Buffer"](http://reactivex.io/documentation/operators/buffer.html) for non-overlapping/no-gap buffers.
	///
	/// - Parameter boundaries: when this `Signal` sends a value, the buffer is emitted and cleared
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `boundaries`
	func buffer<Interface: SignalInterface>(boundaries: Interface) -> Signal<[OutputValue]> {
		return combine(boundaries, initialState: [OutputValue]()) { (buffer: inout [OutputValue], cr: EitherResult2<OutputValue, Interface.OutputValue>) -> Signal<[OutputValue]>.Next in
			switch cr {
			case .result1(.success(let v)):
				buffer.append(v)
				return .none
			case .result1(.failure(let e)):
				let b = buffer
				buffer.removeAll()
				return .value(b, end: e)
			case .result2(.success):
				let b = buffer
				buffer.removeAll()
				return .value(b)
			case .result2(.failure(let e)):
				let b = buffer
				buffer.removeAll()
				return .value(b, end: e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Buffer"](http://reactivex.io/documentation/operators/buffer.html) for buffers with overlap or gaps between.
	///
	/// - Parameter windows: a "windows" signal (one that describes a series of times and durations). Each value `Signal` in the stream starts a new buffer and when the value `Signal` closes, the buffer is emitted.
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `windows`
	func buffer<Interface: SignalInterface>(windows: Interface) -> Signal<[OutputValue]> where Interface.OutputValue: SignalInterface {
		return combine(windows.valueDurations { s in s }, initialState: [Int: [OutputValue]]()) { (buffers: inout [Int: [OutputValue]], cr: EitherResult2<OutputValue, (Int, Interface.OutputValue?)>) -> Signal<[OutputValue]>.Next in
			switch cr {
			case .result1(.success(let v)):
				for index in buffers.keys {
					buffers[index]?.append(v)
				}
				return .none
			case .result1(.failure(let e)):
				let values = buffers.map { $0.1 }
				buffers.removeAll()
				return .values(sequence: values, end: e)
			case .result2(.success(let index, .some)):
				buffers[index] = []
				return .none
			case .result2(.success(let index, .none)):
				if let b = buffers[index] {
					buffers.removeValue(forKey: index)
					return .value(b)
				}
				return .none
			case .result2(.failure(let e)):
				let values = buffers.map { $0.1 }
				buffers.removeAll()
				return .values(sequence: values, end: e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Buffer"](http://reactivex.io/documentation/operators/buffer.html) for buffers of fixed length and a fixed number of values separating starts.
	///
	/// - Parameters:
	///   - count: the number of separate values to accumulate before emitting an array of values
	///   - skip: the stride between the start of each new buffer (can be smaller than `count`, resulting in overlapping buffers)
	/// - Returns: a signal where the values are arrays of length `count` of values from `self`, with start values separated by `skip`
	func buffer(count: UInt, skip: UInt) -> Signal<[OutputValue]> {
		if count == 0 {
			return Signal<[OutputValue]>.preclosed()
		}
		
		let multi = multicast()
		
		// Create the two listeners to the "multi" signal carefully so that the window signal is *first* (so it reaches the buffer before the value signal)
		let windowSignal = multi.stride(count: Int(skip)).map { _ in
			// `count - 1` is the index of the count-th element but since `valuesSignal` will resolve before this, we need to fire 1 element sooner, hence `count - 2`
			multi.elementAt(count - 2).ignoreElements(outputType: OutputValue.self)
		}
		
		return multi.buffer(windows: windowSignal)
	}
	
	/// Implementation of [Reactive X operator "Buffer"](http://reactivex.io/documentation/operators/buffer.html) for non-overlapping, periodic buffer start times and possibly limited buffer sizes.
	///
	/// - Parameters:
	///   - interval: number of seconds between the start of each buffer
	///   - count: the number of separate values to accumulate before emitting an array of values
	///   - continuous: if `true` (default), the `timeshift` periodic timer runs continuously (empty buffers may be emitted if a timeshift elapses without any source signals). If `false`, the periodic timer does start until the first value is received from the source and the periodic timer is paused when a buffer is emitted.
	///   - context: context where the timer will be run
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `windows
	func buffer(interval: DispatchTimeInterval, count: Int = Int.max, continuous: Bool = true, context: Exec = .direct) -> Signal<[OutputValue]> {
		let multi = multicast()
		
		// Create the two listeners to the "multi" signal carefully so that the raw signal is *first* (so it reaches the buffer before the boundary signal)
		let valuesSignal = multi.map { v in v }
		let boundarySignal = multi.timedCountedBoundary(interval: interval, count: count, continuous: continuous, context: context)
		
		return valuesSignal.buffer(boundaries: boundarySignal)
	}
	
	/// Implementation of [Reactive X operator "Buffer"](http://reactivex.io/documentation/operators/buffer.html) for non-overlapping buffers of fixed length.
	///
	/// - Note: this is just a convenience wrapper around `buffer(count:skip:)` where `skip` equals `count`.
	///
	/// - Parameter count: the number of separate values to accumulate before emitting an array of values
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `count`
	func buffer(count: UInt) -> Signal<[OutputValue]> {
		return buffer(count: count, skip: count)
	}
	
	/// Implementation of [Reactive X operator "Buffer"](http://reactivex.io/documentation/operators/buffer.html) for periodic buffer start times and fixed duration buffers.
	///
	/// - Note: this is just a convenience wrapper around `buffer(windows:behaviors)` where the `windows` signal contains `timerSignal` signals contained in a `Signal.interval` signal.
	///
	/// - Parameters:
	///   - interval: the duration of each buffer, in seconds.
	///   - timeshift: the number of seconds between the start of each buffer (if smaller than `interval`, buffers will overlap).
	///   - context: context where the timer will be run
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `windows`
	func buffer(interval: DispatchTimeInterval, timeshift: DispatchTimeInterval, context: Exec = .direct) -> Signal<[OutputValue]> {
		return buffer(windows: Signal.interval(timeshift, initial: .seconds(0), context: context).map { v in Signal<Void>.timer(interval: interval, context: context) })
	}
	
	/// Implementation of map and filter. Essentially a flatMap but instead of flattening over child `Signal`s like the standard Reactive implementation, this flattens over child `Optional`s.
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a new `Signal`
	/// - Returns: a signal where every value from every `Signal` output by `processor` is merged into a single stream
	func compact<U>() -> Signal<U> where OutputValue == Optional<U> {
		return transform() { (r: Result<Optional<U>, SignalEnd>) -> Signal<U>.Next in
			switch r {
			case .success(.some(let v)): return .value(v)
			case .success: return .none
			case .failure(let e): return .end(e)
			}
		}
	}
	
	/// Implementation of map and filter. Essentially a flatMap but instead of flattening over child `Signal`s like the standard Reactive implementation, this flattens over child `Optional`s.
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a new `Signal`
	/// - Returns: a signal where every value from every `Signal` output by `processor` is merged into a single stream
	func compactMap<U>(context: Exec = .direct, _ processor: @escaping (OutputValue) throws -> U?) -> Signal<U> {
		return transform(context: context) { (r: Result<OutputValue, SignalEnd>) -> Signal<U>.Next in
			switch r {
			case .success(let v):
				do {
					if let u = try processor(v) {
						return .value(u)
					}
					return .none
				} catch {
					return .end(.other(error))
				}
			case .failure(let e): return .end(e)
			}
		}
	}
	
	/// Implementation of map and filter. Essentially a flatMap but instead of flattening over child `Signal`s like the standard Reactive implementation, this flattens over child `Optional`s.
	///
	/// - Parameters:
	///   - initialState: an initial value for a state parameter that will be passed to the processor on each iteration.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a new `Signal`
	/// - Returns: a signal where every value from every `Signal` output by `processor` is merged into a single stream
	func compactMap<S, U>(initialState: S, context: Exec = .direct, _ processor: @escaping (inout S, OutputValue) throws -> U?) -> Signal<U> {
		return transform(initialState: initialState, context: context) { (s: inout S, r: Result<OutputValue, SignalEnd>) -> Signal<U>.Next in
			switch r {
			case .success(let v):
				do {
					if let u = try processor(&s, v) {
						return .value(u)
					}
					return .none
				} catch {
					return .end(.other(error))
				}
			case .failure(let e): return .end(e)
			}
		}
	}
	
	/// Equivalent to a compactMap over the activation values in the sequence but passthrough for the other values.
	///
	/// - Parameters:
	///   - select: chooses which end (first or last) 
	///   - context: the `Exec` where `activation` will be evaluated (default: .direct).
	///   - activation: processing closure for activation values
	/// - Returns: a `Signal` where all the activation values have been transformed by `activation` and all other values have been transformed by `remained`. Any error is emitted in the output without change.
	func compactMapActivation<U>(select: SignalActivationSelection, context: Exec = .direct, activation: @escaping (OutputValue) throws -> U?, remainder: @escaping (OutputValue) throws -> U?) -> Signal<U> {
		var capture: SignalCapture<OutputValue>? = nil
		return Signal<U>.generate { input in
			guard let input = input else { return }
			
			let c: SignalCapture<OutputValue>
			if let cap = capture {
				// Subsequent runs, disconnect the old capture to restart it
				_ = cap.disconnect()
				c = cap
			} else {
				// First run, start the capture.
				c = self.capture()
				capture = c
			}
			
			// Subsequent values will be compactMapped normally
			var subsequent = c.resume().compactMap(context: context, remainder)
			
			let values = c.values
			guard !values.isEmpty else {
				subsequent.bind(to: input)
				return
			}
			
			var initial: [U]? = nil
			do {
				// Process the captured values
				switch select {
				case .all: initial = try context.invokeSync { try values.compactMap(activation) }
				case .first:
					initial = [U]()
					try context.invokeSync {
						if let v = values.first, let a = try activation(v) {
							initial!.append(a)
						}
						for v in values.dropFirst() {
							if let r = try remainder(v) {
								initial!.append(r)
							}
						}
					}
				case .last:
					initial = try values.last.flatMap { v in try context.invokeSync { try activation(v).map { [$0] } } }
				}
				
				// If we have any initial values, precache them for immediate sending
				if let i = initial, !i.isEmpty {
					subsequent = subsequent.cacheUntilActive(precached: i)
				}
			} catch {
				subsequent = Signal<U>.preclosed(sequence: initial ?? [], end: SignalEnd.other(error))
			}
		
			subsequent.bind(to: input)
		}		
	}

	func compactMapLatestActivation(context: Exec = .direct, activation: @escaping (OutputValue) throws -> OutputValue?) -> Signal<OutputValue> {
		var capture: SignalCapture<OutputValue>? = nil
		return Signal<OutputValue>.generate { input in
			guard let input = input else { return }
			
			let c: SignalCapture<OutputValue>
			if let cap = capture {
				// Subsequent runs, disconnect the old capture to restart it
				_ = cap.disconnect()
				c = cap
			} else {
				// First run, start the capture.
				c = self.capture()
				capture = c
			}
			
			let values = c.values
			guard !values.isEmpty else {
				c.resume().bind(to: input)
				return
			}
			
			do {
				let initial = try values.last.flatMap { v in try context.invokeSync { try activation(v).map { [$0] } } }
				if let i = initial, !i.isEmpty {
					return c.resume().cacheUntilActive(precached: i).bind(to: input)
				} else {
					return c.resume().bind(to: input)
				}
			} catch {
				Signal<OutputValue>.preclosed(end: SignalEnd.other(error)).bind(to: input)
			}
		}		
	}
	
	/// Implementation of [Reactive X operator "FlatMap"](http://reactivex.io/documentation/operators/flatmap.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a new `Signal`
	/// - Returns: a signal where every value from every `Signal` output by `processor` is merged into a single stream
	func flatten<Interface: SignalInterface>() -> Signal<Interface.OutputValue> where OutputValue == Interface {
		return transformFlatten(closePropagation: .errors) { (v: OutputValue, mergedInput: SignalMergedInput<Interface.OutputValue>) in
			mergedInput.add(v, closePropagation: .errors, removeOnDeactivate: true)
		}
	}
	
	/// Implementation of [Reactive X operator "FlatMap"](http://reactivex.io/documentation/operators/flatmap.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a new `Signal`
	/// - Returns: a signal where every value from every `Signal` output by `processor` is merged into a single stream
	func flatMap<Interface: SignalInterface>(context: Exec = .direct, _ processor: @escaping (OutputValue) throws -> Interface) -> Signal<Interface.OutputValue> {
		return transformFlatten(closePropagation: .errors, context: context) { (v: OutputValue, mergedInput: SignalMergedInput<Interface.OutputValue>) in
			mergedInput.add(try processor(v), closePropagation: .errors, removeOnDeactivate: true)
		}
	}
	
	/// Implementation of [Reactive X operator "FlatMapFirst"](http://reactivex.io/documentation/operators/flatmap.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a new `Signal`
	/// - Returns: a signal where every value from every `Signal` output by `processor` is merged into a single stream
	func flatMapFirst<Interface: SignalInterface>(context: Exec = .direct, _ processor: @escaping (OutputValue) throws -> Interface) -> Signal<Interface.OutputValue> {
		return transformFlatten(initialState: false, closePropagation: .errors, context: context) { (s: inout Bool, v: OutputValue, mergedInput: SignalMergedInput<Interface.OutputValue>) in
			if !s {
				mergedInput.add(try processor(v), closePropagation: .errors, removeOnDeactivate: true)
				s = true
			}
		}
	}
	
	/// Implementation of [Reactive X operator "FlatMapLatest"](http://reactivex.io/documentation/operators/flatmap.html)
	///
	/// See also `switchLatest`
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a new `Signal`
	/// - Returns: a signal where every value from every `Signal` output by `processor` is merged into a single stream
	func flatMapLatest<Interface: SignalInterface>(context: Exec = .direct, _ processor: @escaping (OutputValue) throws -> Interface) -> Signal<Interface.OutputValue> {
		return transformFlatten(initialState: nil, closePropagation: .errors, context: context) { (s: inout Signal<Interface.OutputValue>?, v: OutputValue, mergedInput: SignalMergedInput<Interface.OutputValue>) in
			if let existing = s {
				mergedInput.remove(existing)
			}
			let next = try processor(v).signal
			mergedInput.add(next, closePropagation: .errors, removeOnDeactivate: true)
			s = next
		}
	}
	
	/// Implementation of [Reactive X operator "FlatMap"](http://reactivex.io/documentation/operators/flatmap.html)
	///
	/// - Parameters:
	///   - initialState: an initial value for a state parameter that will be passed to the processor on each iteration.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a new `Signal`
	/// - Returns: a signal where every value from every `Signal` output by `processor` is merged into a single stream
	func flatMap<Interface: SignalInterface, V>(initialState: V, context: Exec = .direct, _ processor: @escaping (inout V, OutputValue) throws -> Interface) -> Signal<Interface.OutputValue> {
		return transformFlatten(initialState: initialState, closePropagation: .errors, context: context) { (s: inout V, v: OutputValue, mergedInput: SignalMergedInput<Interface.OutputValue>) in
			mergedInput.add(try processor(&s, v), closePropagation: .errors, removeOnDeactivate: true)
		}
	}
	
	/// Implementation of [Reactive X operator "ConcatMap"](http://reactivex.io/documentation/operators/flatmap.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a new `Signal`
	/// - Returns: a signal where every value from every `Signal` output by `processor` is serially concatenated into a single stream
	func concatMap<Interface: SignalInterface>(context: Exec = .direct, _ processor: @escaping (OutputValue) throws -> Interface) -> Signal<Interface.OutputValue> {
		return transformFlatten(initialState: 0, closePropagation: .errors, context: context) { (index: inout Int, v: OutputValue, mergedInput: SignalMergedInput<(Int, Result<Interface.OutputValue, SignalEnd>)>) in
			mergedInput.add(try processor(v).transform { (r: Result<Interface.OutputValue, SignalEnd>) -> Signal<Result<Interface.OutputValue, SignalEnd>>.Next in
				switch r {
				case .success:
					return .value(r)
				case .failure(let e):
					return .value(r, end: e)
				}
			}.map { [index] (r: Result<Interface.OutputValue, SignalEnd>) -> (Int, Result<Interface.OutputValue, SignalEnd>) in (index, r) }, closePropagation: .errors, removeOnDeactivate: true)
			index += 1
		}.transform(initialState: (0, Array<Array<Result<Interface.OutputValue, SignalEnd>>>())) { (state: inout (completed: Int, buffers: Array<Array<Result<Interface.OutputValue, SignalEnd>>>), result: Result<(Int, Result<Interface.OutputValue, SignalEnd>), SignalEnd>) -> Signal<Interface.OutputValue>.Next in
			switch result {
			case .success(let index, .success(let v)):
				// We can send results for the first incomplete signal without buffering
				if index == state.completed {
					return .value(v)
				} else {
					// Make sure we have enough buffers
					while index >= state.buffers.count {
						state.buffers.append([])
					}
					
					// Buffer the result
					state.buffers[index].append(Result<Interface.OutputValue, SignalEnd>.success(v))
					return .none
				}
			case .success(let index, .failure(let e)):
				// If its an error, try to send some more buffers
				if index == state.completed {
					state.completed += 1
					var results = [Signal<Interface.OutputValue>.Result]()
					for i in state.completed..<state.buffers.count {
						for j in state.buffers[i] where !j.isFailure {
							results.append(j)
						}
						
						let incomplete = state.buffers[i].last?.isFailure != true
						state.buffers[i].removeAll()
						if incomplete {
							break
						}
						state.completed += 1
					}
					return .array(results)
				} else {
					// If we're not up to that buffer, just record the error
					state.buffers[index].append(Result<Interface.OutputValue, SignalEnd>.failure(e))
					return .none
				}
			case .failure(let error): return .end(error)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "GroupBy"](http://reactivex.io/documentation/operators/groupby.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs the "key" for the output `Signal`
	/// - Returns: a parent `Signal` where values are tuples of a "key" and a child `Signal` that will contain all values from `self` associated with that "key".
	func groupBy<U: Hashable>(context: Exec = .direct, _ processor: @escaping (OutputValue) throws -> U) -> Signal<(U, Signal<OutputValue>)> {
		return self.transform(initialState: Dictionary<U, SignalInput<OutputValue>>(), context: context) { (outputs: inout Dictionary<U, SignalInput<OutputValue>>, r: Result<OutputValue, SignalEnd>) -> Signal<(U, Signal<OutputValue>)>.Next in
			switch r {
			case .success(let v):
				do {
					let u = try processor(v)
					if let o = outputs[u] {
						o.send(value: v)
						return .none
					} else {
						let (input, preCachedSignal) = Signal<OutputValue>.create()
						let s = preCachedSignal.cacheUntilActive()
						input.send(value: v)
						outputs[u] = input
						return .value((u, s))
					}
				} catch {
					return .error(error)
				}
			case .failure(let e):
				outputs.forEach { tuple in tuple.value.send(end: e) }
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Map"](http://reactivex.io/documentation/operators/map.html)
	///
	/// - Parameters:
	///   - keyPath: selects a child value to emit
	/// - Returns: a `Signal` where all the values have been transformed by the key path.
	func keyPath<U>(_ keyPath: KeyPath<OutputValue, U>) -> Signal<U> {
		return transform { (r: Result<OutputValue, SignalEnd>) -> Signal<U>.Next in
			switch r {
			case .success(let v): return .value(v[keyPath: keyPath])
			case .failure(let e): return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Map"](http://reactivex.io/documentation/operators/map.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a value for the output `Signal`
	/// - Returns: a `Signal` where all the values have been transformed by the `processor`. Any error is emitted in the output without change.
	func map<U>(context: Exec = .direct, _ processor: @escaping (OutputValue) throws -> U) -> Signal<U> {
		return transform(context: context) { (r: Result<OutputValue, SignalEnd>) -> Signal<U>.Next in
			switch r {
			case .success(let v): return .single(Result<U, Error> { try processor(v) }.mapError(SignalEnd.other))
			case .failure(let e): return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Map"](http://reactivex.io/documentation/operators/map.html)
	///
	/// - Parameters:
	///   - initialState: an initial value for a state parameter that will be passed to the processor on each iteration.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: for each value emitted by `self`, outputs a value for the output `Signal`
	/// - Returns: a `Signal` where all the values have been transformed by the `processor`. Any error is emitted in the output without change.
	func map<U, V>(initialState: V, context: Exec = .direct, _ processor: @escaping (inout V, OutputValue) throws -> U) -> Signal<U> {
		return transform(initialState: initialState, context: context) { (s: inout V, r: Result<OutputValue, SignalEnd>) -> Signal<U>.Next in
			switch r {
			case .success(let v): return .single(Result<U, Error> { try processor(&s, v) }.mapError(SignalEnd.other))
			case .failure(let e): return .end(e)
			}
		}
	}

	/// Implementation of [Reactive X operator "Map"](http://reactivex.io/documentation/operators/map.html) that offers a separate transformation for "activation" values.
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - activation: processing closure for activation values
	///   - remainder: processing closure for all normal (non-activation) values
	/// - Returns: a `Signal` where all the activation values have been transformed by `activation` and all other values have been transformed by `remained`. Any error is emitted in the output without change.
	func mapActivation<U>(select: SignalActivationSelection, context: Exec = .direct, activation: @escaping (OutputValue) throws -> U, remainder: @escaping (OutputValue) throws -> U) -> Signal<U> {
		return compactMapActivation(select: select, context: context, activation: activation, remainder: remainder)
	}
	
	/// Implementation of [Reactive X operator "Map"](http://reactivex.io/documentation/operators/map.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: used to transform the closing error 
	/// - Returns: when an error is emitted from `self`, emits the result returned from passing that error into `processor`. All values emitted normally.
	func mapErrors(context: Exec = .direct, _ processor: @escaping (SignalEnd) -> SignalEnd) -> Signal<OutputValue> {
		return transform(context: context) { (r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			switch r {
			case .success(let v): return .value(v)
			case .failure(let e): return .end(processor(e))
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Scan"](http://reactivex.io/documentation/operators/scan.html)
	///
	/// See also: `Signal.reduce` which returns a `SignalMulti` and whose processor has the signature `(inout U, OutputValue) -> Void` to make in-place transformations easier.
	/// See also: `aggregate` which performs the equivalent of scan over the entire sequence before emitting a single value.
	///
	/// - Parameters:
	///   - initialState: an initial value for a state parameter that will be passed to the processor on each iteration.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: takes the most recently emitted value and the most recent value from `self` and returns the next emitted value
	/// - Returns: a `Signal` where the result from each invocation of `processor` are emitted
	func scan<U>(initialState: U, context: Exec = .direct, _ processor: @escaping (U, OutputValue) throws -> U) -> Signal<U> {
		return transform(initialState: initialState, context: context) { (accumulated: inout U, r: Result<OutputValue, SignalEnd>) -> Signal<U>.Next in
			switch r {
			case .success(let v):
				do {
					accumulated = try processor(accumulated, v)
					return .value(accumulated)
				} catch {
					return .error(error)
				}
			case .failure(let e):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Window"](http://reactivex.io/documentation/operators/window.html) for non-overlapping/no-gap buffers.
	///
	/// - Note: equivalent to "buffer" method with same parameters
	///
	/// - Parameter boundaries: when this `Signal` sends a value, the buffer is emitted and cleared
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `boundaries`
	func window<Interface: SignalInterface>(boundaries: Interface) -> Signal<Signal<OutputValue>> {
		return combine(boundaries, initialState: nil) { (current: inout SignalInput<OutputValue>?, cr: EitherResult2<OutputValue, Interface.OutputValue>) -> Signal<Signal<OutputValue>>.Next in
			switch cr {
			case .result1(.success(let v)):
				if let c = current {
					c.send(value: v)
					return .none
				} else {
					let (i, s) = Signal<OutputValue>.create()
					current = i
					return .value(s.cacheUntilActive(precached: [v]))
				}
			case .result1(.failure(let e)):
				return .end(e)
			case .result2(.success):
				_ = current?.complete()
				current = nil
				return .none
			case .result2(.failure(let e)):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Window"](http://reactivex.io/documentation/operators/window.html) for buffers with overlap or gaps between.
	///
	/// - Note: equivalent to "buffer" method with same parameters
	///
	/// - Parameter windows: a "windows" signal (one that describes a series of times and durations). Each value `Signal` in the stream starts a new buffer and when the value `Signal` closes, the buffer is emitted.
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `windows`
	func window<Interface: SignalInterface>(windows: Interface) -> Signal<Signal<OutputValue>> where Interface.OutputValue: SignalInterface {
		return combine(windows.valueDurations { s in s }, initialState: [Int: SignalInput<OutputValue>]()) { (children: inout [Int: SignalInput<OutputValue>], cr: EitherResult2<OutputValue, (Int, Interface.OutputValue?)>) -> Signal<Signal<OutputValue>>.Next in
			switch cr {
			case .result1(.success(let v)):
				for index in children.keys {
					if let c = children[index] {
						c.send(value: v)
					}
				}
				return .none
			case .result1(.failure(let e)):
				return .end(e)
			case .result2(.success(let index, .some)):
				let (i, s) = Signal<OutputValue>.create()
				children[index] = i
				return .value(s)
			case .result2(.success(let index, .none)):
				if let c = children[index] {
					c.complete()
					children.removeValue(forKey: index)
				}
				return .none
			case .result2(.failure(let e)):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Window"](http://reactivex.io/documentation/operators/window.html) for buffers of fixed length and a fixed number of values separating starts.
	///
	/// - Note: equivalent to "buffer" method with same parameters
	///
	/// - Parameters:
	///   - count: the number of separate values to accumulate before emitting an array of values
	///   - skip: the stride between the start of each new buffer (can be smaller than `count`, resulting in overlapping buffers)
	/// - Returns: a signal where the values are arrays of length `count` of values from `self`, with start values separated by `skip`
	func window(count: UInt, skip: UInt) -> Signal<Signal<OutputValue>> {
		let multi = multicast()
		
		// Create the two listeners to the "multi" signal carefully so that the window signal is *first* (so it reaches the buffer before the value signal)
		let windowSignal = multi.stride(count: Int(skip)).map { v in
			// `count - 1` is the index of the count-th element but since `valuesSignal` will resolve before this, we need to fire 1 element sooner, hence `count - 2`
			multi.elementAt(count - 2).ignoreElements(outputType: OutputValue.self)
		}
		
		return multi.window(windows: windowSignal)
	}
	
	/// Implementation of [Reactive X operator "Window"](http://reactivex.io/documentation/operators/window.html) for non-overlapping, periodic buffer start times and possibly limited buffer sizes.
	///
	/// - Note: equivalent to "buffer" method with same parameters
	///
	/// - Parameters:
	///   - interval: the number of seconds between the start of each buffer
	///   - count: the number of separate values to accumulate before emitting an array of values
	///   - continuous: if `true` (default), the `timeshift` periodic timer runs continuously (empty buffers may be emitted if a timeshift elapses without any source signals). If `false`, the periodic timer does start until the first value is received from the source and the periodic timer is paused when a buffer is emitted.
	///   - context: context where the timer will run
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `windows`
	func window(interval: DispatchTimeInterval, count: Int = Int.max, continuous: Bool = true, context: Exec = .direct) -> Signal<Signal<OutputValue>> {
		let multi = multicast()
		
		// Create the two listeners to the "multi" signal carefully so that the raw signal is *first* (so it reaches the buffer before the boundary signal)
		let valuesSignal = multi.map { v in v }
		let boundarySignal = multi.timedCountedBoundary(interval: interval, count: count, continuous: continuous, context: context)
		
		return valuesSignal.window(boundaries: boundarySignal)
	}
	
	/// Implementation of [Reactive X operator "Window"](http://reactivex.io/documentation/operators/window.html) for non-overlapping buffers of fixed length.
	///
	/// - Note: this is just a convenience wrapper around `buffer(count:skip:behavior)` where `skip` equals `count`.
	/// - Note: equivalent to "buffer" method with same parameters
	///
	/// - Parameter count: the number of separate values to accumulate before emitting an array of values
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `count`
	func window(count: UInt) -> Signal<Signal<OutputValue>> {
		return window(count: count, skip: count)
	}
	
	/// Implementation of [Reactive X operator "Window"](http://reactivex.io/documentation/operators/window.html) for periodic buffer start times and fixed duration buffers.
	///
	/// - Note: this is just a convenience wrapper around `buffer(windows:behaviors)` where the `windows` signal contains `timerSignal` signals contained in a `Signal.interval` signal.
	/// - Note: equivalent to "buffer" method with same parameters
	///
	/// - Parameters:
	///   - interval: the duration of each buffer, in seconds
	///   - timeshift: the number of seconds between the start of each buffer (if smaller than `interval`, buffers will overlap).
	///   - context: context where the timer will run
	/// - Returns: a signal where the values are arrays of values from `self`, accumulated according to `windows`
	func window(interval: DispatchTimeInterval, timeshift: DispatchTimeInterval, context: Exec = .direct) -> Signal<Signal<OutputValue>> {
		return window(windows: Signal.interval(timeshift, initial: .seconds(0), context: context).map { v in Signal<Void>.timer(interval: interval, context: context) })
	}
	
	/// Implementation of [Reactive X operator "Debounce"](http://reactivex.io/documentation/operators/debounce.html)
	///
	/// - Parameters:
	///   - interval: the duration over which to drop values.
	///   - flushOnClose: if true, then any buffered value is sent before closing, if false (default) then the buffered value is discarded when a close occurs
	///   - context: context where the timer will run
	/// - Returns: a signal where values are emitted after a `interval` but only if no another value occurs during that `interval`.
	func debounce(interval: DispatchTimeInterval, flushOnClose: Bool = false, context: Exec = .direct) -> Signal<OutputValue> {
		let serialContext = context.serialized()
		let (mergedInput, signal) = Signal<OutputValue>.createMergedInput()
		let intermediate = transform(initialState: nil, context: serialContext) { (timer: inout Signal<OutputValue>?, result: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			switch result {
			case .success(let v):
				if let oldTimer = timer {
					mergedInput.remove(oldTimer)
				}
				let newTimer = Signal<OutputValue>.timer(interval: interval, value: v, context: serialContext)
				mergedInput.add(newTimer, closePropagation: .none, removeOnDeactivate: true)
				timer = newTimer
				return .none
			case .failure(let e):
				return .end(e)
			}
		}
		mergedInput.add(intermediate, closePropagation: .all, removeOnDeactivate: false)
		return signal
	}
	
	/// Implementation of [Reactive X operator "throttleFirst"](http://reactivex.io/documentation/operators/sample.html)
	///
	/// - Note: this is largely the reverse of `debounce`.
	///
	/// - Parameters:
	///   - interval: the duration over which to drop values.
	///   - context: context where the timer will run
	/// - Returns: a signal where a timer is started when a value is received and emitted and further values received within that `interval` will be dropped.
	func throttleFirst(interval: DispatchTimeInterval, context: Exec = .direct) -> Signal<OutputValue> {
		let timerQueue = context.serialized()
		var timer: Lifetime? = nil
		return transform(initialState: nil, context: timerQueue) { (cleanup: inout OnDelete?, r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			cleanup = cleanup ?? OnDelete {
				timer = nil
			}
			
			switch r {
			case .failure(let e):
				return .end(e)
			case .success(let v) where timer == nil:
				timer = timerQueue.singleTimer(interval: interval) {
					timer = nil
				}
				return .value(v)
			case .success: return .none
			}
		}
	}
}

extension SignalInterface where OutputValue: Hashable {
	/// Implementation of [Reactive X operator "distinct"](http://reactivex.io/documentation/operators/distinct.html)
	///
	/// - Returns: a signal where all values received are remembered and only values not previously received are emitted.
	func distinct() -> Signal<OutputValue> {
		return transform(initialState: Set<OutputValue>()) { (previous: inout Set<OutputValue>, r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			switch r {
			case .success(let v):
				if !previous.contains(v) {
					previous.insert(v)
					return .value(v)
				}
				return .none
			case .failure(let e):
				return .end(e)
			}
		}
	}
}

extension SignalInterface where OutputValue: Equatable {
	/// Implementation of [Reactive X operator "distinct"](http://reactivex.io/documentation/operators/distinct.html)
	///
	/// - Returns: a signal that emits the first value but then emits subsequent values only when they are different to the previous value.
	func distinctUntilChanged() -> Signal<OutputValue> {
		return transform(initialState: nil) { (previous: inout OutputValue?, r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			switch r {
			case .success(let v):
				if previous != v {
					previous = v
					return .value(v)
				}
				return .none
			case .failure(let e):
				return .end(e)
			}
		}
	}
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "distinct"](http://reactivex.io/documentation/operators/distinct.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `comparator` will be evaluated (default: .direct).
	///   - comparator: a function taking two parameters (the previous and current value in the signal) which should return `false` to indicate the current value should be emitted.
	/// - Returns: a signal that emits the first value but then emits subsequent values only if the function `comparator` returns `false` when passed the previous and current values.
	func distinctUntilChanged(context: Exec = .direct, compare: @escaping (OutputValue, OutputValue) throws -> Bool) -> Signal<OutputValue> {
		return transform(initialState: nil) { (previous: inout OutputValue?, r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			switch r {
			case .success(let v):
				do {
					if let p = previous, try compare(p, v) {
						previous = v
						return .none
					} else {
						previous = v
						return .value(v)
					}
				} catch {
					return .error(error)
				}
			case .failure(let e):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "elementAt"](http://reactivex.io/documentation/operators/elementat.html)
	///
	/// - Parameter index: identifies the element to be emitted.
	/// - Returns: a signal that emits the zero-indexed element identified by `index` and then closes.
	func elementAt(_ index: UInt) -> Signal<OutputValue> {
		return transform(initialState: 0, context: .direct) { (curr: inout UInt, r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			switch r {
			case .success(let v) where curr == index:
				return .value(v, end: .complete)
			case .success:
				curr += 1
				return .none
			case .failure(let e):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "filter"](http://reactivex.io/documentation/operators/filter.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `matching` will be evaluated (default: .direct).
	///   - matching: a function which is passed the current value and should return `true` to indicate the value should be emitted.
	/// - Returns: a signal that emits received values only if the function `matching` returns `true` when passed the value.
	func filter(context: Exec = .direct, matching: @escaping (OutputValue) throws -> Bool) -> Signal<OutputValue> {
		return transform(context: context) { (r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			do {
				switch r {
				case .success(let v) where try matching(v): return .value(v)
				case .success: return .none
				case .failure(let e): return .end(e)
				}
			} catch {
				return .error(error)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "ofType"](http://reactivex.io/documentation/operators/filter.html)
	///
	/// - Parameters:
	///   - type: values will be filtered to this type (NOTE: only the *static* type of this parameter is considered – if the runtime type is more specific, that will be ignored).
	/// - Returns: a signal that emits received values only if the value can be dynamically cast to the type `U`, specified statically by `type`.
	func ofType<U>(_ type: U.Type) -> Signal<U> {
		return self.transform(initialState: 0) { (curr: inout Int, r: Result<OutputValue, SignalEnd>) -> Signal<U>.Next in
			switch r {
			case .success(let v as U): return .value(v)
			case .success: return .none
			case .failure(let e): return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "first"](http://reactivex.io/documentation/operators/first.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `matching` will be evaluated (default: .direct).
	///   - matching: run for each value until it returns `true`
	/// - Returns: a signal that, when an error is received, emits the first value (if any) in the signal where `matching` returns `true` when invoked with the value, followed by the error.
	func first(context: Exec = .direct, matching: @escaping (OutputValue) throws -> Bool = { _ in true }) -> Signal<OutputValue> {
		return transform(context: context) { (r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			do {
				switch r {
				case .success(let v) where try matching(v): return .value(v, end: .complete)
				case .success: return .none
				case .failure(let e): return .end(e)
				}
			} catch {
				return .error(error)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "single"](http://reactivex.io/documentation/operators/first.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `matching` will be evaluated (default: .direct).
	///   - matching: run for each value
	/// - Returns: a signal that, if a single value in the sequence, when passed to `matching` returns `true`, then that value will be returned, followed by a SignalEnd.complete when the input signal closes (otherwise a SignalEnd.complete will be emitted without emitting any prior values).
	func single(context: Exec = .direct, matching: @escaping (OutputValue) throws -> Bool = { _ in true }) -> Signal<OutputValue> {
		return transform(initialState: nil, context: context) { (state: inout (firstMatch: OutputValue, unique: Bool)?, r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			do {
				switch r {
				case .success(let v) where try matching(v):
					if let s = state {
						state = (firstMatch: s.firstMatch, unique: false)
					} else {
						state = (firstMatch: v, unique: true)
					}
					return .none
				case .success:
					return .none
				case .failure(let e):
					if let s = state, s.unique == true {
						return .value(s.firstMatch, end: e)
					} else {
						return .end(e)
					}
				}
			} catch {
				return .error(error)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "ignoreElements"](http://reactivex.io/documentation/operators/ignoreelements.html)
	///
	/// - Returns: a signal that emits the input error, when received, otherwise ignores all values.
	func ignoreElements<U>(outputType: U.Type = U.self) -> Signal<U> {
		return transform { (r: Result<OutputValue, SignalEnd>) -> Signal<U>.Next in
			if case .failure(let e) = r {
				return .end(e)
			} else {
				return .none
			}
		}
	}
	
	/// Implementation of [Reactive X operator "last"](http://reactivex.io/documentation/operators/last.html)
	///
	/// - Parameters:
	///   - context: the `Exec` where `matching` will be evaluated (default: .direct).
	///   - matching: run for each value
	/// - Returns: a signal that, when an error is received, emits the last value (if any) in the signal where `matching` returns `true` when invoked with the value, followed by the error.
	func last(context: Exec = .direct, matching: @escaping (OutputValue) throws -> Bool = { _ in true }) -> Signal<OutputValue> {
		return transform(initialState: nil, context: context) { (last: inout OutputValue?, r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			do {
				switch r {
				case .success(let v) where try matching(v):
					last = v
					return .none
				case .success:
					return .none
				case .failure(let e):
					if let l = last {
						return .value(l, end: e)
					} else {
						return .end(e)
					}
				}
			} catch {
				return .error(error)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "sample"](http://reactivex.io/documentation/operators/sample.html)
	///
	/// See also: `debounce` is the equivalent where the sampling interval is time based
	/// See also: `withLatestFrom` always emits, even when the sampled signal hasn't emitted another value during the interval
	///
	/// - Parameter trigger: instructs the result to emit the last value from `self`
	/// - Returns: a signal that, when a value is received from `trigger`, emits the last value (if any) received from `self`.
	func sample<Interface: SignalInterface>(_ trigger: Interface) -> Signal<OutputValue> {
		return combine(trigger, initialState: nil, context: .direct) { (last: inout OutputValue?, c: EitherResult2<OutputValue, Interface.OutputValue>) -> Signal<OutputValue>.Next in
			switch (c, last) {
			case (.result1(.success(let v)), _):
				last = v
				return .none
			case (.result1(.failure(let e)), _):
				return .end(e)
			case (.result2(.success), .some(let l)):
				last = nil
				return .value(l)
			case (.result2(.success), _):
				return .none
			case (.result2(.failure(let e)), _):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "sample"](http://reactivex.io/documentation/operators/sample.html)
	///
	/// - Parameter trigger: instructs the result to emit the last value from `self`
	/// - Returns: a signal that, when a value is received from `trigger`, emits the last value (if any) received from `self`.
	func throttleFirst<Interface: SignalInterface>(_ trigger: Interface) -> Signal<OutputValue> {
		return combine(trigger, initialState: nil, context: .direct) { (last: inout OutputValue?, c: EitherResult2<OutputValue, Interface.OutputValue>) -> Signal<OutputValue>.Next in
			switch (c, last) {
			case (.result1(.success(let v)), nil):
				last = v
				return .none
			case (.result1(.success), _):
				return .none
			case (.result1(.failure(let e)), _):
				return .end(e)
			case (.result2(.success), .some(let l)):
				last = nil
				return .value(l)
			case (.result2(.success), _):
				return .none
			case (.result2(.failure(let e)), _):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "skip"](http://reactivex.io/documentation/operators/skip.html)
	///
	/// - Parameter count: the number of values from the start of `self` to drop
	/// - Returns: a signal that drops `count` values from `self` then mirrors `self`.
	func skip(_ count: Int) -> Signal<OutputValue> {
		return transform(initialState: 0) { (progressCount: inout Int, r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			switch r {
			case .success(let v) where progressCount >= count: return .value(v)
			case .success:
				progressCount = progressCount + 1
				return .none
			case .failure(let e): return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "skipLast"](http://reactivex.io/documentation/operators/skiplast.html)
	///
	/// - Parameter count: the number of values from the end of `self` to drop
	/// - Returns: a signal that buffers `count` values from `self` then for each new value received from `self`, emits the oldest value in the buffer. When `self` closes, all remaining values in the buffer are discarded.
	func skipLast(_ count: Int) -> Signal<OutputValue> {
		return transform(initialState: Array<OutputValue>()) { (buffer: inout Array<OutputValue>, r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			switch r {
			case .success(let v):
				buffer.append(v)
				if buffer.count > count {
					return .value(buffer.removeFirst())
				} else {
					return .none
				}
			case .failure(let e):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "skip"](http://reactivex.io/documentation/operators/skip.html)
	///
	/// - Parameter count: the number of values from the start of `self` to emit
	/// - Returns: a signal that emits `count` values from `self` then closes.
	func take(_ count: Int) -> Signal<OutputValue> {
		return transform(initialState: 0) { (progressCount: inout Int, r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			progressCount = progressCount + 1
			switch r {
			case .success(let v) where progressCount >= count: return .value(v, end: .complete)
			case .success(let v): return .value(v)
			case .failure(let e): return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "skipLast"](http://reactivex.io/documentation/operators/skiplast.html)
	///
	/// - Parameter count: the number of values from the end of `self` to emit
	/// - Returns: a signal that buffers `count` values from `self` then for each new value received from `self`, drops the oldest value in the buffer. When `self` closes, all values in the buffer are emitted, followed by the close.
	func takeLast(_ count: Int) -> Signal<OutputValue> {
		return transform(initialState: Array<OutputValue>()) { (buffer: inout Array<OutputValue>, r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			switch r {
			case .success(let v):
				buffer.append(v)
				if buffer.count > count {
					buffer.removeFirst()
				}
				return .none
			case .failure(let e):
				return .values(sequence: buffer, end: e)
			}
		}
	}
}

extension SignalInterface {
	/// - Note: the [Reactive X operators "And", "Then" and "When"](http://reactivex.io/documentation/operators/and-then-when.html) are considered unnecessary, given the slightly different implementation of `CwlSignal.Signal.zip` which produces tuples (rather than producing a non-structural type) and is hence equivalent to `and`+`then`.
}

extension SignalInterface {
	/// Implementation similar to [Reactive X operator "sample"](http://reactivex.io/documentation/operators/sample.html) except that the output is sent every time self emits, not just when sample has changed since self last emitted.
	///
	/// See also: `combineLatest`, `sample` and `throttleFirst` which have similar but slightly different emitting scenarios.
	///
	/// - Parameter sample: the latest value from this signal will be emitted whenever `self` emits
	/// - Returns: a signal that emits the latest value from `sample` each time `self` emits
	func withLatestFrom<Interface: SignalInterface>(_ sample: Interface) -> Signal<Interface.OutputValue> {
		return combine(sample, initialState: nil, context: .direct) { (last: inout Interface.OutputValue?, c: EitherResult2<OutputValue, Interface.OutputValue>) -> Signal<Interface.OutputValue>.Next in
			switch (c, last) {
			case (.result1(.success), .some(let l)): return .value(l)
			case (.result1(.success), _): return .none
			case (.result1(.failure(let e)), _): return .end(e)
			case (.result2(.success(let v)), _):
				last = v
				return .none
			case (.result2(.failure(let e)), _): return .end(e)
			}
		}
	}
	
	/// Implementation similar to [Reactive X operator "sample"](http://reactivex.io/documentation/operators/sample.html) except that a function is run to generate the emitted value each time self emits. The function is passed the value emitted from `self` and the last emitted value from the `sample` signal parameter.
	///
	/// See also: `combineLatest`, `sample` and `throttleFirst` which have similar but slightly different emitting scenarios.
	///
	/// - Parameter sample: a signal whose latest value will be used each time `self` emits
	/// - Parameter processor: produces the outputs values
	/// - Returns: a signal that, when a value is received from `trigger`, emits the result or performing `processor`.
	func withLatestFrom<Interface: SignalInterface, R>(_ sample: Interface, context: Exec = .direct, _ processor: @escaping (OutputValue, Interface.OutputValue) throws -> R) -> Signal<R> {
		return combine(sample, initialState: nil, context: context) { (last: inout Interface.OutputValue?, c: EitherResult2<OutputValue, Interface.OutputValue>) -> Signal<R>.Next in
			switch (c, last) {
			case (.result1(.success(let left)), .some(let right)):
				do {
					return .value(try processor(left, right))
				} catch {
					return .error(error)
				}
			case (.result1(.success), _): return .none
			case (.result1(.failure(let e)), _): return .end(e)
			case (.result2(.success(let v)), _):
				last = v
				return .none
			case (.result2(.failure(let e)), _): return .end(e)
			}
		}
	}

	/// Implementation of [Reactive X operator "combineLatest"](http://reactivex.io/documentation/operators/combinelatest.html) for two observed signals.
	///
	/// - Parameters:
	///   - second: an observed signal.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: invoked with the most recent values of the observed signals (or nil if a signal has not yet emitted a value) when any of the observed signals emits a value
	/// - Returns: a signal that emits the values from the processor and closes when any of the observed signals closes
	func combineLatestWith<U: SignalInterface, V>(_ second: U, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue) throws -> V) -> Signal<V> {
		return combine(second, initialState: (nil, nil), context: context) { (state: inout (OutputValue?, U.OutputValue?), r: EitherResult2<OutputValue, U.OutputValue>) -> Signal<V>.Next in
			switch r {
			case .result1(.success(let v)): state = (v, state.1)
			case .result2(.success(let v)): state = (state.0, v)
			case .result1(.failure(let e)): return .end(e)
			case .result2(.failure(let e)): return .end(e)
			}
			if let v0 = state.0, let v1 = state.1 {
				do {
					return .value(try processor(v0, v1))
				} catch {
					return .error(error)
				}
			} else {
				return .none
			}
		}
	}

	@available(*, deprecated, message:"Renamed to combineLatestWith. Alternately, use static combineLatest function.")
	func combineLatest<U: SignalInterface, V>(_ second: U, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue) throws -> V) -> Signal<V> {
		return combineLatestWith(second, context: context, processor)
	}
	
	static func combineLatest<U: SignalInterface, V>(_ first: Self, _ second: U, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue) throws -> V) -> Signal<V> {
		return first.combineLatestWith(second, context: context, processor)
	}
	
	/// Implementation of [Reactive X operator "combineLatest"](http://reactivex.io/documentation/operators/combinelatest.html) for three observed signals.
	///
	/// - Parameters:
	///   - second: an observed signal.
	///   - third: an observed signal.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: invoked with the most recent values of the observed signals (or nil if a signal has not yet emitted a value) when any of the observed signals emits a value
	/// - Returns: a signal that emits the values from the processor and closes when any of the observed signals closes
	func combineLatestWith<U: SignalInterface, V: SignalInterface, W>(_ second: U, _ third: V, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue, V.OutputValue) throws -> W) -> Signal<W> {
		return combine(second, third, initialState: (nil, nil, nil), context: context) { (state: inout (OutputValue?, U.OutputValue?, V.OutputValue?), r: EitherResult3<OutputValue, U.OutputValue, V.OutputValue>) -> Signal<W>.Next in
			switch r {
			case .result1(.success(let v)): state = (v, state.1, state.2)
			case .result2(.success(let v)): state = (state.0, v, state.2)
			case .result3(.success(let v)): state = (state.0, state.1, v)
			case .result1(.failure(let e)): return .end(e)
			case .result2(.failure(let e)): return .end(e)
			case .result3(.failure(let e)): return .end(e)
			}
			if let v0 = state.0, let v1 = state.1, let v2 = state.2 {
				do {
					return .value(try processor(v0, v1, v2))
				} catch {
					return .error(error)
				}
			} else {
				return .none
			}
		}
	}

	@available(*, deprecated, message:"Renamed to combineLatestWith. Alternately, use static combineLatest function.")
	func combineLatest<U: SignalInterface, V: SignalInterface, W>(_ second: U, _ third: V, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue, V.OutputValue) throws -> W) -> Signal<W> {
		return combineLatestWith(second, third, context: context, processor)
	}
	
	static func combineLatest<U: SignalInterface, V: SignalInterface, W>(_ first: Self, _ second: U, _ third: V, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue, V.OutputValue) throws -> W) -> Signal<W> {
		return first.combineLatestWith(second, third, context: context, processor)
	}
	
	/// Implementation of [Reactive X operator "combineLatest"](http://reactivex.io/documentation/operators/combinelatest.html) for four observed signals.
	///
	/// - Note: support for multiple listeners and reactivation is determined by the specified `behavior`.
	///
	/// - Parameters:
	///   - second: an observed signal.
	///   - third: an observed signal.
	///   - fourth: an observed signal.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: invoked with the most recent values of the observed signals (or nil if a signal has not yet emitted a value) when any of the observed signals emits a value
	/// - Returns: a signal that emits the values from the processor and closes when any of the observed signals closes
	func combineLatestWith<U: SignalInterface, V: SignalInterface, W: SignalInterface, X>(_ second: U, _ third: V, _ fourth: W, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue, V.OutputValue, W.OutputValue) throws -> X) -> Signal<X> {
		return combine(second, third, fourth, initialState: (nil, nil, nil, nil), context: context) { (state: inout (OutputValue?, U.OutputValue?, V.OutputValue?, W.OutputValue?), r: EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>) -> Signal<X>.Next in
			switch r {
			case .result1(.success(let v)): state = (v, state.1, state.2, state.3)
			case .result2(.success(let v)): state = (state.0, v, state.2, state.3)
			case .result3(.success(let v)): state = (state.0, state.1, v, state.3)
			case .result4(.success(let v)): state = (state.0, state.1, state.2, v)
			case .result1(.failure(let e)): return .end(e)
			case .result2(.failure(let e)): return .end(e)
			case .result3(.failure(let e)): return .end(e)
			case .result4(.failure(let e)): return .end(e)
			}
			if let v0 = state.0, let v1 = state.1, let v2 = state.2, let v3 = state.3 {
				do {
					return .value(try processor(v0, v1, v2, v3))
				} catch {
					return .error(error)
				}
			} else {
				return .none
			}
		}
	}

	@available(*, deprecated, message:"Renamed to combineLatestWith. Alternately, use static combineLatest function.")
	func combineLatest<U: SignalInterface, V: SignalInterface, W: SignalInterface, X>(_ second: U, _ third: V, _ fourth: W, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue, V.OutputValue, W.OutputValue) throws -> X) -> Signal<X> {
		return combineLatestWith(second, third, fourth, context: context, processor)
	}

	static func combineLatest<U: SignalInterface, V: SignalInterface, W: SignalInterface, X>(_ first: Self, _ second: U, _ third: V, _ fourth: W, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue, V.OutputValue, W.OutputValue) throws -> X) -> Signal<X> {
		return first.combineLatestWith(second, third, fourth, context: context, processor)
	}
	
	/// Implementation of [Reactive X operator "combineLatest"](http://reactivex.io/documentation/operators/combinelatest.html) for five observed signals.
	///
	/// - Note: support for multiple listeners and reactivation is determined by the specified `behavior`.
	///
	/// - Parameters:
	///   - second: an observed signal.
	///   - third: an observed signal.
	///   - fourth: an observed signal.
	///   - fifth: an observed signal.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: invoked with the most recent values of the observed signals (or nil if a signal has not yet emitted a value) when any of the observed signals emits a value
	/// - Returns: a signal that emits the values from the processor and closes when any of the observed signals closes
	func combineLatestWith<U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y>(_ second: U, _ third: V, _ fourth: W, _ fifth: X, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue) throws -> Y) -> Signal<Y> {
		return combine(second, third, fourth, fifth, initialState: (nil, nil, nil, nil, nil), context: context) { (state: inout (OutputValue?, U.OutputValue?, V.OutputValue?, W.OutputValue?, X.OutputValue?), r: EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>) -> Signal<Y>.Next in
			switch r {
			case .result1(.success(let v)): state = (v, state.1, state.2, state.3, state.4)
			case .result2(.success(let v)): state = (state.0, v, state.2, state.3, state.4)
			case .result3(.success(let v)): state = (state.0, state.1, v, state.3, state.4)
			case .result4(.success(let v)): state = (state.0, state.1, state.2, v, state.4)
			case .result5(.success(let v)): state = (state.0, state.1, state.2, state.3, v)
			case .result1(.failure(let e)): return .end(e)
			case .result2(.failure(let e)): return .end(e)
			case .result3(.failure(let e)): return .end(e)
			case .result4(.failure(let e)): return .end(e)
			case .result5(.failure(let e)): return .end(e)
			}
			if let v0 = state.0, let v1 = state.1, let v2 = state.2, let v3 = state.3, let v4 = state.4 {
				do {
					return .value(try processor(v0, v1, v2, v3, v4))
				} catch {
					return .error(error)
				}
			} else {
				return .none
			}
		}
	}

	@available(*, deprecated, message:"Renamed to combineLatestWith. Alternately, use static combineLatest function.")
	func combineLatest<U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y>(_ second: U, _ third: V, _ fourth: W, _ fifth: X, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue) throws -> Y) -> Signal<Y> {
		return combineLatestWith(second, third, fourth, fifth, context: context, processor)
	}

	static func combineLatest<U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface, Y>(_ first: Self, _ second: U, _ third: V, _ fourth: W, _ fifth: X, context: Exec = .direct, _ processor: @escaping (OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue) throws -> Y) -> Signal<Y> {
		return first.combineLatestWith(second, third, fourth, fifth, context: context, processor)
	}
	
	static func combineLatest<S: Sequence>(sequence: S) -> Signal<[OutputValue]> where S.Element: SignalInterface, OutputValue == S.Element.OutputValue {
		let array = Array(sequence)
		let count = array.count
		let indexed = Signal<OutputValue>.indexed(array)
		return indexed.transform(initialState: Array<OutputValue?>(repeating: nil, count: count)) { buffer, result in
			switch result {
			case .success((let offset, let element)):
				buffer[offset] = element
				let compacted = buffer.compactMap { $0 }
				guard compacted.count == count else { return .none }
				return .value(compacted)
			case .failure(let e): return .end(e)
			}
		}
	}

	static func combineLatest<S: SignalInterface>(_ signals: S...) -> Signal<[OutputValue]> where OutputValue == S.OutputValue {
		return combineLatest(sequence: signals)
	}
	
	/// Implementation of [Reactive X operator "join"](http://reactivex.io/documentation/operators/join.html)
	///
	/// - Parameters:
	///   - withRight: an observed signal
	///   - leftEnd: function invoked when a value is received from `self`. The resulting signal is observed and the time until signal close is treated as a duration "window" that started with the received `self` value.
	///   - rightEnd: function invoked when a value is received from `right`. The resulting signal is observed and the time until signal close is treated as a duration "window" that started with the received `right` value.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: invoked with the corresponding `left` and `right` values when a `left` value is emitted during a `right`->`rightEnd` window or a `right` value is received during a `left`->`leftEnd` window
	/// - Returns: a signal that emits the values from the processor and closes when any of the last of the observed windows closes.
	func intersect<U: SignalInterface, V: SignalInterface, W: SignalInterface, X>(withRight: U, leftEnd: @escaping (OutputValue) -> V, rightEnd: @escaping (U.OutputValue) -> W, context: Exec = .direct, _ processor: @escaping ((OutputValue, U.OutputValue)) -> X) -> Signal<X> {
		let leftDurations = valueDurations({ t in leftEnd(t).takeWhile { _ in false } })
		let rightDurations = withRight.valueDurations({ u in rightEnd(u).takeWhile { _ in false } })
		let a = leftDurations.combine(rightDurations, initialState: ([Int: OutputValue](), [Int: U.OutputValue]())) { (state: inout (activeLeft: [Int: OutputValue], activeRight: [Int: U.OutputValue]), cr: EitherResult2<(Int, OutputValue?), (Int, U.OutputValue?)>) -> Signal<(OutputValue, U.OutputValue)>.Next in
			switch cr {
			case .result1(.success(let leftIndex, .some(let leftValue))):
				state.activeLeft[leftIndex] = leftValue
				return .array(state.activeRight.sorted { $0.0 < $1.0 }.map { tuple in .success((leftValue, tuple.value)) })
			case .result2(.success(let rightIndex, .some(let rightValue))):
				state.activeRight[rightIndex] = rightValue
				return .array(state.activeLeft.sorted { $0.0 < $1.0 }.map { tuple in .success((tuple.value, rightValue)) })
			case .result1(.success(let leftIndex, .none)):
				state.activeLeft.removeValue(forKey: leftIndex)
				return .none
			case .result2(.success(let rightIndex, .none)):
				state.activeRight.removeValue(forKey: rightIndex)
				return .none
			default:
				return .complete()
			}
		}
		return a.map(context: context, processor)
	}
	
	/// Implementation of [Reactive X operator "groupJoin"](http://reactivex.io/documentation/operators/join.html)
	///
	/// - Parameters:
	///   - withRight: an observed signal.
	///   - leftEnd: function invoked when a value is received from `self`. The resulting signal is observed and the time until signal close is treated as a duration "window" that started with the received `self` value.
	///   - rightEnd: function invoked when a value is received from `right`. The resulting signal is observed and the time until signal close is treated as a duration "window" that started with the received `right` value.
	///   - context: the `Exec` where `processor` will be evaluated (default: .direct).
	///   - processor: when a `left` value is received, this function is invoked with the `left` value and a `Signal` that will emit all the `right` values encountered until the `left`->`leftEnd` window closes. The value returned by this function will be emitted as part of the `Signal` returned from `groupIntersect`.
	/// - Returns: a signal that emits the values from the processor and closes when any of the last of the observed windows closes.
	func groupIntersect<U: SignalInterface, V: SignalInterface, W: SignalInterface, X>(withRight: U, leftEnd: @escaping (OutputValue) -> V, rightEnd: @escaping (U.OutputValue) -> W, context: Exec = .direct, _ processor: @escaping ((OutputValue, Signal<U.OutputValue>)) -> X) -> Signal<X> {
		let leftDurations = valueDurations({ u in leftEnd(u).takeWhile { _ in false } })
		let rightDurations = withRight.valueDurations({ u in rightEnd(u).takeWhile { _ in false } })
		return leftDurations.combine(rightDurations, initialState: ([Int: SignalInput<U.OutputValue>](), [Int: U.OutputValue]())) { (state: inout (activeLeft: [Int: SignalInput<U.OutputValue>], activeRight: [Int: U.OutputValue]), cr: EitherResult2<(Int, OutputValue?), (Int, U.OutputValue?)>) -> Signal<(OutputValue, Signal<U.OutputValue>)>.Next in
			switch cr {
			case .result1(.success(let leftIndex, .some(let leftValue))):
				let (li, ls) = Signal<U.OutputValue>.create()
				state.activeLeft[leftIndex] = li
				return .value((leftValue, ls.cacheUntilActive(precached: state.activeRight.sorted { $0.0 < $1.0 }.map { $0.value })))
			case .result2(.success(let rightIndex, .some(let rightValue))):
				state.activeRight[rightIndex] = rightValue
				state.activeLeft.sorted { $0.0 < $1.0 }.forEach { tuple in tuple.value.send(value: rightValue) }
				return .none
			case .result1(.success(let leftIndex, .none)):
				_ = state.activeLeft[leftIndex]?.complete()
				state.activeLeft.removeValue(forKey: leftIndex)
				return .none
			case .result2(.success(let rightIndex, .none)):
				state.activeRight.removeValue(forKey: rightIndex)
				return .none
			default:
				return .complete()
			}
		}.map(context: context, processor)
	}
}

extension Signal {	
	/// Implementation of [Reactive X operator "merge"](http://reactivex.io/documentation/operators/merge.html) where the output closes only when the last source closes.
	///
	/// - Parameter sources: a variable parameter list of `Signal<OutputValue>` instances that are merged with `self` to form the result.
	/// - Returns: a signal that emits every value from every `sources` input `signal`.
	func merge<S: Sequence>(sequence: S) -> Signal<OutputValue> where S.Iterator.Element == Signal<OutputValue> {
		let (mergedInput, sig) = Signal<OutputValue>.createMergedInput(onLastInputClosed: .complete)
		mergedInput.add(signal, closePropagation: .errors)
		for s in sequence {
			mergedInput.add(s, closePropagation: .errors)
		}
		return sig
	}
	
	/// Implementation of [Reactive X operator "merge"](http://reactivex.io/documentation/operators/merge.html) where the output closes only when the last source closes.
	///
	/// NOTE: the signal closes as `SignalComplete.cancelled` when the last output closes. For other closing semantics, use `Signal.mergSetAndSignal` instead.
	///
	/// - Parameter sources: an `Array` where `signal` is merged into the result.
	/// - Returns: a signal that emits every value from every `sources` input `signal`.
	static func merge<S: Sequence>(sequence: S) -> Signal<OutputValue> where S.Iterator.Element == Signal<OutputValue> {
		let (mergedInput, sig) = Signal<OutputValue>.createMergedInput(onLastInputClosed: .complete)
		var sequenceEmpty = true
		for s in sequence {
			mergedInput.add(s, closePropagation: .errors)
			sequenceEmpty = false
		}
		if sequenceEmpty {
			return Signal<OutputValue>.preclosed()
		}
		return sig
	}
	
	/// Implementation of [Reactive X operator "merge"](http://reactivex.io/documentation/operators/merge.html) where the output closes only when the last source closes.
	///
	/// - Parameter sources: an `Array` where `signal` is merged into the result.
	/// - Returns: a signal that emits every value from every `sources` input `signal`.
	static func merge(_ sources: Signal<OutputValue>...) -> Signal<OutputValue> {
		return merge(sequence: sources)
	}
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "merge"](http://reactivex.io/documentation/operators/merge.html) where the output closes only when the last source closes.
	///
	/// - Parameter sources: a variable parameter list of `Signal<OutputValue>` instances that are merged with `self` to form the result.
	/// - Returns: a signal that emits every value from every `sources` input `signal`.
	func merge(_ sources: Signal<OutputValue>...) -> Signal<OutputValue> {
		let (mergedInput, sig) = Signal<OutputValue>.createMergedInput(onLastInputClosed: .complete)
		mergedInput.add(signal, closePropagation: .errors)
		for s in sources {
			mergedInput.add(s, closePropagation: .errors)
		}
		return sig
	}
	
	/// Implementation of [Reactive X operator "startWith"](http://reactivex.io/documentation/operators/startwith.html)
	///
	/// - Parameter sequence: a sequence of values.
	/// - Returns: a signal that emits every value from `sequence` immediately before it starts mirroring `self`.
	func startWith<S: Sequence>(sequence: S) -> Signal<OutputValue> where S.Iterator.Element == OutputValue {
		return Signal.from(sequence).combine(signal, initialState: false) { (alreadySent: inout Bool, r: EitherResult2<OutputValue, OutputValue>) -> Signal<OutputValue>.Next in
			switch r {
			case .result1(.success(let v)):
				if !alreadySent {
					return .value(v)
				} else {
					return .none
				}
			case .result1(.failure):
				alreadySent = true
				return .none
			case .result2(.success(let v)):
				if !alreadySent {
					alreadySent = true
					return .values(sequence: Array(sequence).appending(v))
				} else {
					return .value(v)
				}
			case .result2(.failure(let e)):
				if !alreadySent {
					alreadySent = true
					return .values(sequence: sequence, end: e)
				} else {
					return .end(e)
				}
			}
		}
	}
	
	/// Implementation of [Reactive X operator "startWith"](http://reactivex.io/documentation/operators/startwith.html)
	///
	/// - Parameter value: a value.
	/// - Returns: a signal that emits the value immediately before it starts mirroring `self`.
	func startWith(_ values: OutputValue...) -> Signal<OutputValue> {
		return startWith(sequence: values)
	}
	
	/// Implementation of [Reactive X operator "endWith"](http://reactivex.io/documentation/operators/endwith.html)
	///
	/// - Returns: a signal that emits every value from `sequence` on activation and then mirrors `self`.
	func endWith<U: Sequence>(sequence: U, conditional: @escaping (SignalEnd) -> SignalEnd? = { e in e }) -> Signal<OutputValue> where U.Iterator.Element == OutputValue {
		return transform() { (r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			switch r {
			case .success(let v): return .value(v)
			case .failure(let e):
				if let newEnd = conditional(e) {
					return .values(sequence: sequence, end: newEnd)
				} else {
					return .end(e)
				}
			}
		}
	}
	
	/// Implementation of [Reactive X operator "endWith"](http://reactivex.io/documentation/operators/endwith.html)
	///
	/// - Returns: a signal that emits every value from `sequence` on activation and then mirrors `self`.
	func endWith(_ values: OutputValue..., conditional: @escaping (Error) -> Error? = { e in e }) -> Signal<OutputValue> {
		return endWith(sequence: values)
	}

	/// Implementation of [Reactive X operator "switch"](http://reactivex.io/documentation/operators/switch.html)
	///
	/// See also: `flatMapLatest` (emits values from the latest `Signal` to start emitting)
	///
	/// - Parameter signal: each of the inner signals emitted by this outer signal is observed, with the most recent signal emitted from the result
	/// - Returns: a signal that emits the values from the latest `Signal` emitted by `signal`
	func switchLatest<U>() -> Signal<U> where OutputValue: SignalInterface, OutputValue.OutputValue == U {
		return transformFlatten(initialState: nil, closePropagation: .errors) { (latest: inout Signal<U>?, next: OutputValue, mergedInput: SignalMergedInput<U>) in
			if let l = latest {
				mergedInput.remove(l)
			}
			let s = next.signal
			mergedInput.add(s, closePropagation: .errors, removeOnDeactivate: true)
			latest = s
		}
	}

	@available(*, deprecated, message:"Renamed to zipWith. Alternately, use static zip function.")
	func zip<U: SignalInterface>(_ second: U) -> Signal<(OutputValue, U.OutputValue)> {
		return zipWith(second)
	}

	/// Implementation of [Reactive X operator "zip"](http://reactivex.io/documentation/operators/zip.html)
	///
	/// - Parameter second: another `Signal`
	/// - Returns: a signal that emits the values from `self`, paired with corresponding value from `with`.
	static func zip<U: SignalInterface>(_ first: Self, _ second: U) -> Signal<(Self.OutputValue, U.OutputValue)> {
		return first.zipWith(second)
	}
	
	/// Implementation of [Reactive X operator "zip"](http://reactivex.io/documentation/operators/zip.html)
	///
	/// - Parameter second: another `Signal`
	/// - Returns: a signal that emits the values from `self`, paired with corresponding value from `with`.
	func zipWith<U: SignalInterface>(_ second: U) -> Signal<(OutputValue, U.OutputValue)> {
		return combine(second, initialState: (Array<OutputValue>(), Array<U.OutputValue>(), false, false)) { (queues: inout (first: Array<OutputValue>, second: Array<U.OutputValue>, firstClosed: Bool, secondClosed: Bool), r: EitherResult2<OutputValue, U.OutputValue>) -> Signal<(OutputValue, U.OutputValue)>.Next in
			switch (r, queues.first.first, queues.second.first) {
			case (.result1(.success(let first)), _, .some(let second)):
				queues.second.removeFirst()
				if (queues.second.isEmpty && queues.secondClosed) {
					return .value((first, second), end: .complete)
				} else {
					return .value((first, second))
				}
			case (.result1(.success(let first)), _, _):
				queues.first.append(first)
				return .none
			case (.result1(.failure(let e)), _, _):
				if queues.first.isEmpty || (queues.second.isEmpty && queues.secondClosed) {
					return .end(e)
				} else {
					queues.firstClosed = true
				}
				return .none
			case (.result2(.success(let second)), .some(let first), _):
				queues.first.removeFirst()
				if (queues.first.isEmpty && queues.firstClosed) {
					return .value((first, second), end: .complete)
				} else {
					return .value((first, second))
				}
			case (.result2(.success(let second)), _, _):
				queues.second.append(second)
				return .none
			case (.result2(.failure(let e)), _, _):
				if queues.second.isEmpty || (queues.first.isEmpty && queues.firstClosed) {
					return .end(e)
				} else {
					queues.secondClosed = true
					return .none
				}
			}
		}
	}
	
	@available(*, deprecated, message:"Renamed to zipWith. Alternately, use static zip function.")
	func zip<U: SignalInterface, V: SignalInterface>(_ second: U, _ third: V) -> Signal<(OutputValue, U.OutputValue, V.OutputValue)> {
		return zipWith(second, third)
	}
	
	
	/// Implementation of [Reactive X operator "zip"](http://reactivex.io/documentation/operators/zip.html)
	///
	/// - Parameters:
	///   - second: another `Signal`
	///   - third: another `Signal`
	/// - Returns: a signal that emits the values from `self`, paired with corresponding value from `second` and `third`.
	static func zip<U: SignalInterface, V: SignalInterface>(_ first: Self, _ second: U, _ third: V) -> Signal<(Self.OutputValue, U.OutputValue, V.OutputValue)> {
		return first.zipWith(second, third)
	}
	
	/// Implementation of [Reactive X operator "zip"](http://reactivex.io/documentation/operators/zip.html)
	///
	/// - Parameters:
	///   - second: another `Signal`
	///   - third: another `Signal`
	/// - Returns: a signal that emits the values from `self`, paired with corresponding value from `second` and `third`.
	func zipWith<U: SignalInterface, V: SignalInterface>(_ second: U, _ third: V) -> Signal<(OutputValue, U.OutputValue, V.OutputValue)> {
		return combine(second, third, initialState: (Array<OutputValue>(), Array<U.OutputValue>(), Array<V.OutputValue>(), false, false, false)) { (queues: inout (first: Array<OutputValue>, second: Array<U.OutputValue>, third: Array<V.OutputValue>, firstClosed: Bool, secondClosed: Bool, thirdClosed: Bool), r: EitherResult3<OutputValue, U.OutputValue, V.OutputValue>) -> Signal<(OutputValue, U.OutputValue, V.OutputValue)>.Next in
			switch (r, queues.first.first, queues.second.first, queues.third.first) {
			case (.result1(.success(let first)), _, .some(let second), .some(let third)):
				queues.second.removeFirst()
				queues.third.removeFirst()
				if (queues.second.isEmpty && queues.secondClosed) || (queues.third.isEmpty && queues.thirdClosed) {
					return .value((first, second, third), end: .complete)
				} else {
					return .value((first, second, third))
				}
			case (.result1(.success(let first)), _, _, _):
				queues.first.append(first)
				return .none
			case (.result1(.failure(let e)), _, _, _):
				if queues.first.isEmpty || (queues.second.isEmpty && queues.secondClosed) || (queues.third.isEmpty && queues.thirdClosed) {
					return .end(e)
				} else {
					queues.firstClosed = true
					return .none
				}
			case (.result2(.success(let second)), .some(let first), _, .some(let third)):
				queues.first.removeFirst()
				queues.third.removeFirst()
				if (queues.first.isEmpty && queues.firstClosed) || (queues.third.isEmpty && queues.thirdClosed) {
					return .value((first, second, third), end: .complete)
				} else {
					return .value((first, second, third))
				}
			case (.result2(.success(let second)), _, _, _):
				queues.second.append(second)
				return .none
			case (.result2(.failure(let e)), _, _, _):
				if queues.second.isEmpty || (queues.first.isEmpty && queues.firstClosed) || (queues.third.isEmpty && queues.thirdClosed) {
					return .end(e)
				} else {
					queues.secondClosed = true
					return .none
				}
			case (.result3(.success(let third)), .some(let first), .some(let second), _):
				queues.first.removeFirst()
				queues.second.removeFirst()
				if (queues.first.isEmpty && queues.firstClosed) || (queues.second.isEmpty && queues.secondClosed) {
					return .value((first, second, third), end: .complete)
				} else {
					return .value((first, second, third))
				}
			case (.result3(.success(let third)), _, _, _):
				queues.third.append(third)
				return .none
			case (.result3(.failure(let e)), _, _, _):
				if queues.third.isEmpty || (queues.first.isEmpty && queues.firstClosed) || (queues.second.isEmpty && queues.secondClosed) {
					return .end(e)
				} else {
					queues.thirdClosed = true
					return .none
				}
			}
		}
	}
	
	@available(*, deprecated, message:"Renamed to zipWith. Alternately, use static zip function.")
	func zip<U: SignalInterface, V: SignalInterface, W: SignalInterface>(_ second: U, _ third: V, _ fourth: W) -> Signal<(OutputValue, U.OutputValue, V.OutputValue, W.OutputValue)> {
		return zipWith(second, third, fourth)
	}
	
	/// Implementation of [Reactive X operator "zip"](http://reactivex.io/documentation/operators/zip.html)
	///
	/// - Parameters:
	///   - second: another `Signal`
	///   - third: another `Signal`
	///   - fourth: another `Signal`
	/// - Returns: a signal that emits the values from `self`, paired with corresponding value from `second`,`third` and `fourth`.
	static func zip<U: SignalInterface, V: SignalInterface, W: SignalInterface>(_ first: Self, _ second: U, _ third: V, _ fourth: W) -> Signal<(Self.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue)> {
		return first.zipWith(second, third, fourth)
	}
	
	/// Implementation of [Reactive X operator "zip"](http://reactivex.io/documentation/operators/zip.html)
	///
	/// - Parameters:
	///   - second: another `Signal`
	///   - third: another `Signal`
	///   - fourth: another `Signal`
	/// - Returns: a signal that emits the values from `self`, paired with corresponding value from `second`,`third` and `fourth`.
	func zipWith<U: SignalInterface, V: SignalInterface, W: SignalInterface>(_ second: U, _ third: V, _ fourth: W) -> Signal<(OutputValue, U.OutputValue, V.OutputValue, W.OutputValue)> {
		return combine(second, third, fourth, initialState: (Array<OutputValue>(), Array<U.OutputValue>(), Array<V.OutputValue>(), Array<W.OutputValue>(), false, false, false, false)) { (queues: inout (first: Array<OutputValue>, second: Array<U.OutputValue>, third: Array<V.OutputValue>, fourth: Array<W.OutputValue>, firstClosed: Bool, secondClosed: Bool, thirdClosed: Bool, fourthClosed: Bool), r: EitherResult4<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue>) -> Signal<(OutputValue, U.OutputValue, V.OutputValue, W.OutputValue)>.Next in
			switch (r, queues.first.first, queues.second.first, queues.third.first, queues.fourth.first) {
			case (.result1(.success(let first)), _, .some(let second), .some(let third), .some(let fourth)):
				queues.second.removeFirst()
				queues.third.removeFirst()
				queues.fourth.removeFirst()
				if (queues.second.isEmpty && queues.secondClosed) || (queues.third.isEmpty && queues.thirdClosed) || (queues.fourth.isEmpty && queues.fourthClosed) {
					return .value((first, second, third, fourth), end: .complete)
				} else {
					return .value((first, second, third, fourth))
				}
			case (.result1(.success(let first)), _, _, _, _):
				queues.first.append(first)
				return .none
			case (.result1(.failure(let e)), _, _, _, _):
				if queues.first.isEmpty || (queues.second.isEmpty && queues.secondClosed) || (queues.third.isEmpty && queues.thirdClosed) || (queues.fourth.isEmpty && queues.fourthClosed) {
					return .end(e)
				} else {
					queues.firstClosed = true
					return .none
				}
			case (.result2(.success(let second)), .some(let first), _, .some(let third), .some(let fourth)):
				queues.first.removeFirst()
				queues.third.removeFirst()
				queues.fourth.removeFirst()
				if (queues.first.isEmpty && queues.firstClosed) || (queues.third.isEmpty && queues.thirdClosed) || (queues.fourth.isEmpty && queues.fourthClosed) {
					return .value((first, second, third, fourth), end: .complete)
				} else {
					return .value((first, second, third, fourth))
				}
			case (.result2(.success(let second)), _, _, _, _):
				queues.second.append(second)
				return .none
			case (.result2(.failure(let e)), _, _, _, _):
				if queues.second.isEmpty || (queues.first.isEmpty && queues.firstClosed) || (queues.third.isEmpty && queues.thirdClosed) || (queues.fourth.isEmpty && queues.fourthClosed) {
					return .end(e)
				} else {
					queues.secondClosed = true
					return .none
				}
				
			case (.result3(.success(let third)), .some(let first), .some(let second), _, .some(let fourth)):
				queues.first.removeFirst()
				queues.second.removeFirst()
				queues.fourth.removeFirst()
				if (queues.first.isEmpty && queues.firstClosed) || (queues.second.isEmpty && queues.secondClosed) || (queues.fourth.isEmpty && queues.fourthClosed) {
					return .value((first, second, third, fourth), end: .complete)
				} else {
					return .value((first, second, third, fourth))
				}
			case (.result3(.success(let third)), _, _, _, _):
				queues.third.append(third)
				return .none
			case (.result3(.failure(let e)), _, _, _, _):
				if queues.third.isEmpty || (queues.first.isEmpty && queues.firstClosed) || (queues.second.isEmpty && queues.secondClosed) || (queues.fourth.isEmpty && queues.fourthClosed) {
					return .end(e)
				} else {
					queues.thirdClosed = true
					return .none
				}
			case (.result4(.success(let fourth)), .some(let first), .some(let second), .some(let third), _):
				queues.first.removeFirst()
				queues.second.removeFirst()
				queues.third.removeFirst()
				if (queues.first.isEmpty && queues.firstClosed) || (queues.second.isEmpty && queues.secondClosed) || (queues.third.isEmpty && queues.thirdClosed) {
					return .value((first, second, third, fourth), end: .complete)
				} else {
					return .value((first, second, third, fourth))
				}
			case (.result4(.success(let fourth)), _, _, _, _):
				queues.fourth.append(fourth)
				return .none
			case (.result4(.failure(let e)), _, _, _, _):
				if queues.fourth.isEmpty || (queues.first.isEmpty && queues.firstClosed) || (queues.second.isEmpty && queues.secondClosed) || (queues.third.isEmpty && queues.thirdClosed) {
					return .end(e)
				} else {
					queues.fourthClosed = true
					return .none
				}
			}
		}
	}
	
	@available(*, deprecated, message:"Renamed to zipWith. Alternately, use static zip function.")
	func zip<U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface>(_ second: U, _ third: V, _ fourth: W, _ fifth: X) -> Signal<(OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue)> {
		return zipWith(second, third, fourth, fifth)
	}
	
	/// Implementation of [Reactive X operator "zip"](http://reactivex.io/documentation/operators/zip.html)
	///
	/// - Parameters:
	///   - second: another `Signal`
	///   - third: another `Signal`
	///   - fourth: another `Signal`
	///   - fifth: another `Signal`
	/// - Returns: a signal that emits the values from `self`, paired with corresponding value from `second`,`third`, `fourth` and `fifth`.
	static func zip<U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface>(_ first: Self, _ second: U, _ third: V, _ fourth: W, _ fifth: X) -> Signal<(Self.OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue)> {
		return first.zipWith(second, third, fourth, fifth)
	}
	
	/// Implementation of [Reactive X operator "zip"](http://reactivex.io/documentation/operators/zip.html)
	///
	/// - Parameters:
	///   - second: another `Signal`
	///   - third: another `Signal`
	///   - fourth: another `Signal`
	///   - fifth: another `Signal`
	/// - Returns: a signal that emits the values from `self`, paired with corresponding value from `second`,`third`, `fourth` and `fifth`.
	func zipWith<U: SignalInterface, V: SignalInterface, W: SignalInterface, X: SignalInterface>(_ second: U, _ third: V, _ fourth: W, _ fifth: X) -> Signal<(OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue)> {
		return combine(second, third, fourth, fifth, initialState: (Array<OutputValue>(), Array<U.OutputValue>(), Array<V.OutputValue>(), Array<W.OutputValue>(), Array<X.OutputValue>(), false, false, false, false, false)) { (queues: inout (first: Array<OutputValue>, second: Array<U.OutputValue>, third: Array<V.OutputValue>, fourth: Array<W.OutputValue>, fifth: Array<X.OutputValue>, firstClosed: Bool, secondClosed: Bool, thirdClosed: Bool, fourthClosed: Bool, fifthClosed: Bool), r: EitherResult5<OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue>) -> Signal<(OutputValue, U.OutputValue, V.OutputValue, W.OutputValue, X.OutputValue)>.Next in
			switch (r, queues.first.first, queues.second.first, queues.third.first, queues.fourth.first, queues.fifth.first) {
			case (.result1(.success(let first)), _, .some(let second), .some(let third), .some(let fourth), .some(let fifth)):
				queues.second.removeFirst()
				queues.third.removeFirst()
				queues.fourth.removeFirst()
				queues.fifth.removeFirst()
				if (queues.second.isEmpty && queues.secondClosed) || (queues.third.isEmpty && queues.thirdClosed) || (queues.fourth.isEmpty && queues.fourthClosed) || (queues.fifth.isEmpty && queues.fifthClosed) {
					return .value((first, second, third, fourth, fifth), end: .complete)
				} else {
					return .value((first, second, third, fourth, fifth))
				}
			case (.result1(.success(let first)), _, _, _, _, _):
				queues.first.append(first)
				return .none
			case (.result1(.failure(let e)), _, _, _, _, _):
				if queues.first.isEmpty || (queues.second.isEmpty && queues.secondClosed) || (queues.third.isEmpty && queues.thirdClosed) || (queues.fourth.isEmpty && queues.fourthClosed) || (queues.fifth.isEmpty && queues.fifthClosed) {
					return .end(e)
				} else {
					queues.firstClosed = true
					return .none
				}
			case (.result2(.success(let second)), .some(let first), _, .some(let third), .some(let fourth), .some(let fifth)):
				queues.first.removeFirst()
				queues.third.removeFirst()
				queues.fourth.removeFirst()
				queues.fifth.removeFirst()
				if (queues.first.isEmpty && queues.firstClosed) || (queues.third.isEmpty && queues.thirdClosed) || (queues.fourth.isEmpty && queues.fourthClosed) || (queues.fifth.isEmpty && queues.fifthClosed) {
					return .value((first, second, third, fourth, fifth), end: .complete)
				} else {
					return .value((first, second, third, fourth, fifth))
				}
			case (.result2(.success(let second)), _, _, _, _, _):
				queues.second.append(second)
				return .none
			case (.result2(.failure(let e)), _, _, _, _, _):
				if queues.second.isEmpty || (queues.first.isEmpty && queues.firstClosed) || (queues.third.isEmpty && queues.thirdClosed) || (queues.fourth.isEmpty && queues.fourthClosed) || (queues.fifth.isEmpty && queues.fifthClosed) {
					return .end(e)
				} else {
					queues.secondClosed = true
					return .none
				}
			case (.result3(.success(let third)), .some(let first), .some(let second), _, .some(let fourth), .some(let fifth)):
				queues.first.removeFirst()
				queues.second.removeFirst()
				queues.fourth.removeFirst()
				queues.fifth.removeFirst()
				if (queues.first.isEmpty && queues.firstClosed) || (queues.second.isEmpty && queues.secondClosed) || (queues.fourth.isEmpty && queues.fourthClosed) || (queues.fifth.isEmpty && queues.fifthClosed) {
					return .value((first, second, third, fourth, fifth), end: .complete)
				} else {
					return .value((first, second, third, fourth, fifth))
				}
			case (.result3(.success(let third)), _, _, _, _, _):
				queues.third.append(third)
				return .none
			case (.result3(.failure(let e)), _, _, _, _, _):
				if queues.third.isEmpty || (queues.first.isEmpty && queues.firstClosed) || (queues.second.isEmpty && queues.secondClosed) || (queues.fourth.isEmpty && queues.fourthClosed) || (queues.fifth.isEmpty && queues.fifthClosed) {
					return .end(e)
				} else {
					queues.thirdClosed = true
					return .none
				}
			case (.result4(.success(let fourth)), .some(let first), .some(let second), .some(let third), _, .some(let fifth)):
				queues.first.removeFirst()
				queues.second.removeFirst()
				queues.third.removeFirst()
				queues.fifth.removeFirst()
				if (queues.first.isEmpty && queues.firstClosed) || (queues.second.isEmpty && queues.secondClosed) || (queues.third.isEmpty && queues.thirdClosed) || (queues.fifth.isEmpty && queues.fifthClosed) {
					return .value((first, second, third, fourth, fifth), end: .complete)
				} else {
					return .value((first, second, third, fourth, fifth))
				}
			case (.result4(.success(let fourth)), _, _, _, _, _):
				queues.fourth.append(fourth)
				return .none
			case (.result4(.failure(let e)), _, _, _, _, _):
				if queues.fourth.isEmpty || (queues.first.isEmpty && queues.firstClosed) || (queues.second.isEmpty && queues.secondClosed) || (queues.third.isEmpty && queues.thirdClosed) || (queues.fifth.isEmpty && queues.fifthClosed) {
					return .end(e)
				} else {
					queues.fourthClosed = true
					return .none
				}
			case (.result5(.success(let fifth)), .some(let first), .some(let second), .some(let third), .some(let fourth), _):
				queues.first.removeFirst()
				queues.second.removeFirst()
				queues.third.removeFirst()
				queues.fourth.removeFirst()
				if (queues.first.isEmpty && queues.firstClosed) || (queues.second.isEmpty && queues.secondClosed) || (queues.third.isEmpty && queues.thirdClosed) || (queues.fourth.isEmpty && queues.fourthClosed) {
					return .value((first, second, third, fourth, fifth), end: .complete)
				} else {
					return .value((first, second, third, fourth, fifth))
				}
			case (.result5(.success(let fifth)), _, _, _, _, _):
				queues.fifth.append(fifth)
				return .none
			case (.result5(.failure(let e)), _, _, _, _, _):
				if queues.fifth.isEmpty || (queues.first.isEmpty && queues.firstClosed) || (queues.second.isEmpty && queues.secondClosed) || (queues.third.isEmpty && queues.thirdClosed) || (queues.fourth.isEmpty && queues.fourthClosed) {
					return .end(e)
				} else {
					queues.fifthClosed = true
					return .none
				}
			}
		}
	}
}

// Essentially a closure type used by `catchError`, defined as a separate class so the function can reference itself
fileprivate class CatchErrorRecovery<OutputValue> {
	let recover: (SignalEnd) -> Signal<OutputValue>
	let catchTypes: SignalEndPropagation
	init(recover: @escaping (SignalEnd) -> Signal<OutputValue>, catchTypes: SignalEndPropagation) {
		self.recover = recover
		self.catchTypes = catchTypes
	}
	func catchErrorRejoin(j: SignalJunction<OutputValue>, e: SignalEnd, i: SignalInput<OutputValue>) {
		if catchTypes.shouldPropagateEnd(e) {
			do {
				let f: SignalJunction<OutputValue>.Handler = self.catchErrorRejoin
				try recover(e).junction().bind(to: i, onEnd: f)
			} catch {
				i.send(end: .other(error))
			}
		} else {
			i.send(end: e)
		}
	}
}

// Essentially a closure type used by `retry`, defined as a separate class so the function can reference itself
fileprivate class RetryRecovery<U> {
	let shouldRetry: (inout U, SignalEnd) -> DispatchTimeInterval?
	let catchTypes: SignalEndPropagation
	var state: U
	let context: Exec
	var timer: Lifetime? = nil
	init(shouldRetry: @escaping (inout U, SignalEnd) -> DispatchTimeInterval?, catchTypes: SignalEndPropagation, state: U, context: Exec) {
		self.shouldRetry = shouldRetry
		self.catchTypes = catchTypes
		self.state = state
		self.context = context
	}
	func retryRejoin<OutputValue>(j: SignalJunction<OutputValue>, e: SignalEnd, i: SignalInput<OutputValue>) {
		if catchTypes.shouldPropagateEnd(e), let t = shouldRetry(&state, e) {
			timer = context.singleTimer(interval: t) {
				do {
					try j.bind(to: i, onEnd: self.retryRejoin)
				} catch {
					i.send(end: .other(error))
				}
			}
		} else {
			i.send(end: e)
		}
	}
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "catch"](http://reactivex.io/documentation/operators/catch.html), returning a `Signal` on error in `self`.
	///
	/// - Parameters:
	///   - context: context where `recover` will run
	///   - catchSignalComplete: by default, the `recover` closure will be invoked only for unexpected errors, i.e. when `Error` is *not* a `SignalComplete`. Set this parameter to `true` to invoke the `recover` closure for *all* errors, including `SignalEnd.complete` and `SignalComplete.cancelled`. 
	///   - recover: a function that, when passed the `Error` that closed `self`, optionally returns a new signal.
	/// - Returns: a signal that emits the values from `self` until an error is received and then, if `recover` returns non-`nil` emits the values from `recover` and then emits the error from `recover`, otherwise if `recover` returns `nil`, emits the `Error` from `self`.
	func catchError(context: Exec = .direct, catchSignalComplete: Bool = false, recover: @escaping (SignalEnd) -> Signal<OutputValue>) -> Signal<OutputValue> {
		let (input, sig) = Signal<OutputValue>.create()
		// Both `junction` and `input` are newly created so this can't be an error
		try! junction().bind(to: input, onEnd: CatchErrorRecovery(recover: recover, catchTypes: catchSignalComplete ? .all : .errors).catchErrorRejoin)
		return sig
	}
	
	/// Implementation of [Reactive X operator "retry"](http://reactivex.io/documentation/operators/retry.html) where the choice to retry and the delay between retries is controlled by a function.
	///
	/// - Note: a ReactiveX "resubscribe" is interpreted as a disconnect and reconnect, which will trigger reactivation iff (if and only if) the preceding nodes have behavior that supports that.
	///
	/// - Parameters:
	///   - initialState:  a mutable state value that will be passed into `shouldRetry`.
	///   - context: the `Exec` where timed reconnection will occcur (default: .global).
	///   - catchSignalComplete: by default, the `shouldRetry` closure will be invoked only for unexpected errors, i.e. when `Error` is *not* a `SignalComplete`. Set this parameter to `true` to invoke the `recover` closure for *all* errors, including `SignalEnd.complete` and `SignalComplete.cancelled`. 
	///   - shouldRetry: a function that, when passed the current state value and the `Error` that closed `self`, returns an `Optional<Double>`.
	/// - Returns: a signal that emits the values from `self` until an error is received and then, if `shouldRetry` returns non-`nil`, disconnects from `self`, delays by the number of seconds returned from `shouldRetry`, and reconnects to `self` (triggering re-activation), otherwise if `shouldRetry` returns `nil`, emits the `Error` from `self`. If the number of seconds is `0`, the reconnect is synchronous, otherwise it will occur in `context` using `invokeAsync`.
	func retry<U>(_ initialState: U, context: Exec = .direct, catchSignalComplete: Bool = false, shouldRetry: @escaping (inout U, SignalEnd) -> DispatchTimeInterval?) -> Signal<OutputValue> {
		let (input, sig) = Signal<OutputValue>.create()
		// Both `junction` and `input` are newly created so this can't be an error
		try! junction().bind(to: input, onEnd: RetryRecovery(shouldRetry: shouldRetry, catchTypes: catchSignalComplete ? .all : .errors, state: initialState, context: context).retryRejoin)
		return sig
	}
	
	/// Implementation of [Reactive X operator "retry"](http://reactivex.io/documentation/operators/retry.html) where retries occur until the error is not `isSignalComplete` or `count` number of retries has occurred.
	///
	/// - Note: a ReactiveX "resubscribe" is interpreted as a disconnect and reconnect, which will trigger reactivation iff the preceding nodes have behavior that supports that.
	///
	/// - Parameters:
	///   - count: the maximum number of retries
	///   - delayInterval: the number of seconds between retries
	///   - context: the `Exec` where timed reconnection will occcur (default: .global).
	///   - catchSignalComplete: by default, retry attempts will occur only for unexpected errors, i.e. when `Error` is *not* a `SignalComplete`. Set this parameter to `true` to invoke the `recover` closure for *all* errors, including `SignalEnd.complete` and `SignalComplete.cancelled`. 
	/// - Returns: a signal that emits the values from `self` until an error is received and then, if fewer than `count` retries have occurred, disconnects from `self`, delays by `delaySeconds` and reconnects to `self` (triggering re-activation), otherwise if `count` retries have occurred, emits the `Error` from `self`. If the number of seconds is `0`, the reconnect is synchronous, otherwise it will occur in `context` using `invokeAsync`.
	func retry(count: Int, delayInterval: DispatchTimeInterval, context: Exec = .direct, catchSignalComplete: Bool = false) -> Signal<OutputValue> {
		return retry(0, context: context) { (retryCount: inout Int, e: SignalEnd) -> DispatchTimeInterval? in
			if !catchSignalComplete && e.isComplete {
				return nil
			} else if retryCount < count {
				retryCount += 1
				return delayInterval
			} else {
				return nil
			}
		}
	}
	
	/// Implementation of [Reactive X operator "delay"](http://reactivex.io/documentation/operators/delay.html) where delay for each value is determined by running an `offset` function.
	///
	/// - Parameters:
	///   - initialState: a user state value passed into the `offset` function
	///   - closePropagation: determines how errors and closure in `offset` affects the resulting signal
	///   - context: the `Exec` where `offset` will run (default: .global).
	///   - offset: a function that, when passed the current state value and the latest value from `self`, returns the number of seconds that the value should be delayed (values less or equal to 0 are sent immediately).
	/// - Returns: a mirror of `self` where values are offset according to `offset` – closing occurs when `self` closes or when the last delayed value is sent (whichever occurs last).
	func delay<U>(initialState: U, closePropagation: SignalEndPropagation = .none, context: Exec = .direct, offset: @escaping (inout U, OutputValue) -> DispatchTimeInterval) -> Signal<OutputValue> {
		return delay(initialState: initialState, closePropagation: closePropagation, context: context) { (state: inout U, value: OutputValue) -> Signal<Void> in
			return Signal<Void>.timer(interval: offset(&state, value), context: context)
		}
	}
	
	/// Implementation of [Reactive X operator "delay"](http://reactivex.io/documentation/operators/delay.html) where delay for each value is constant.
	///
	/// - Parameters:
	///   - interval: the delay for each value
	///   - context: the `Exec` where timed reconnection will occcur (default: .global).
	/// - Returns: a mirror of `self` where values are delayed by `seconds` – closing occurs when `self` closes or when the last delayed value is sent (whichever occurs last).
	func delay(interval: DispatchTimeInterval, context: Exec = .direct) -> Signal<OutputValue> {
		return delay(initialState: interval, context: context) { (s: inout DispatchTimeInterval, v: OutputValue) -> DispatchTimeInterval in s }
	}
	
	/// Implementation of [Reactive X operator "delay"](http://reactivex.io/documentation/operators/delay.html) where delay for each value is determined by the duration of a signal returned from `offset`.
	///
	/// - Parameters:
	///   - closePropagation: determines how errors and closure in `offset` affects the resulting signal
	///   - context: the `Exec` where `offset` will run (default: .global).
	///   - offset: a function that, when passed the current state value emits a signal, the first value of which will trigger the end of the delay
	/// - Returns: a mirror of `self` where values are offset according to `offset` – closing occurs when `self` closes or when the last delayed value is sent (whichever occurs last).
	func delay<U>(closePropagation: SignalEndPropagation = .none, context: Exec = .direct, offset: @escaping (OutputValue) -> Signal<U>) -> Signal<OutputValue> {
		return delay(initialState: (), closePropagation: closePropagation, context: context) { (state: inout (), value: OutputValue) -> Signal<U> in return offset(value) }
	}
	
	/// Implementation of [Reactive X operator "delay"](http://reactivex.io/documentation/operators/delay.html) where delay for each value is determined by the duration of a signal returned from `offset`.
	///
	/// - Parameters:
	///   - initialState: a user state value passed into the `offset` function
	///   - closePropagation: determines how errors and closure in `offset` affects the resulting signal
	///   - context: the `Exec` where `offset` will run (default: .global).
	///   - offset: a function that, when passed the current state value emits a signal, the first value of which will trigger the end of the delay
	/// - Returns: a mirror of `self` where values are offset according to `offset` – closing occurs when `self` closes or when the last delayed value is sent (whichever occurs last).
	func delay<U, V>(initialState: V, closePropagation: SignalEndPropagation = .none, context: Exec = .direct, offset: @escaping (inout V, OutputValue) -> Signal<U>) -> Signal<OutputValue> {
		return valueDurations(initialState: initialState, closePropagation: closePropagation, context: context, offset).transform(initialState: [Int: OutputValue]()) { (values: inout [Int: OutputValue], r: Result<(Int, OutputValue?), SignalEnd>) -> Signal<OutputValue>.Next in
			switch r {
			case .success(let index, .some(let t)):
				values[index] = t
				return .none
			case .success(let index, .none):
				return values[index].map { .value($0) } ?? .none
			case .failure(let e):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "do"](http://reactivex.io/documentation/operators/do.html) for "activation" (not a concept that directly exists in ReactiveX but similar to doOnSubscribe).
	///
	/// - Parameters:
	///   - context: where the handler will be invoked
	///   - handler: invoked when self is activated
	/// - Returns: a signal that emits the same outputs as self
	func onActivate(context: Exec = .direct, _ handler: @escaping () -> ()) -> Signal<OutputValue> {
		let j = junction()
		let s = Signal<OutputValue>.generate { input in
			if let i = input {
				handler()
				_ = try? j.bind(to: i)
			} else {
				_ = j.disconnect()
			}
		}
		return s
	}
	
	/// Implementation of [Reactive X operator "do"](http://reactivex.io/documentation/operators/do.html) for "deactivation" (not a concept that directly exists in ReactiveX but similar to doOnUnsubscribe).
	///
	/// - Parameters:
	///   - context: where the handler will be invoked
	///   - handler: invoked when self is deactivated
	/// - Returns: a signal that emits the same outputs as self
	func onDeactivate(context: Exec = .direct, _ handler: @escaping () -> ()) -> Signal<OutputValue> {
		let j = junction()
		let s = Signal<OutputValue>.generate { input in
			if let i = input {
				_ = try? j.bind(to: i)
			} else {
				handler()
				_ = j.disconnect()
			}
		}
		return s
	}
	
	/// Implementation of [Reactive X operator "do"](http://reactivex.io/documentation/operators/do.html) for "result" (equivalent to doOnEach).
	///
	/// - Parameters:
	///   - context: where the handler will be invoked
	///   - handler: invoked for each `Result` in the signal
	/// - Returns: a signal that emits the same outputs as self
	func onResult(context: Exec = .direct, _ handler: @escaping (Result<OutputValue, SignalEnd>) -> ()) -> Signal<OutputValue> {
		return transform(context: context) { (r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			handler(r)
			return .single(r)
		}
	}
	
	/// Implementation of [Reactive X operator "do"](http://reactivex.io/documentation/operators/do.html) for "values" (equivalent to doOnNext).
	///
	/// - Parameters:
	///   - context: where the handler will be invoked
	///   - handler: invoked for each value (Result.success) in the signal
	/// - Returns: a signal that emits the same outputs as self
	func onValue(context: Exec = .direct, _ handler: @escaping (OutputValue) -> ()) -> Signal<OutputValue> {
		return transform(context: context) { (r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			switch r {
			case .success(let v):
				handler(v)
				return .value(v)
			case .failure(let e):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "do"](http://reactivex.io/documentation/operators/do.html) for "errors" (equivalent to doOnTerminate).
	///
	/// - Parameters:
	///   - context: where the handler will be invoked
	///   - handler: invoked for each error (Result.failure) in the signal
	/// - Returns: a signal that emits the same outputs as self
	func onError(context: Exec = .direct, catchSignalComplete: Bool = false, _ handler: @escaping (SignalEnd) -> ()) -> Signal<OutputValue> {
		return transform(context: context) { (r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			switch r {
			case .success(let v):
				return .value(v)
			case .failure(let e):
				if catchSignalComplete || !e.isComplete {
					handler(e)
				}
				return .end(e)
			}
		}
	}
	
	/// Appends an onActivate, onValue, onError and onDeactivate operator to monitor behavior and inspect lifecycle events.
	///
	/// - Parameters:
	///   - logPrefix: Prepended to the front of log statements. If non-empty, ": " is *also* prepended.
	///   - file: suffixed to the log statement (defaults to #file)
	///   - line: suffixed to the log statement (defaults to #line)
	/// - Returns: the otherwise untransformed signal
	func debug(logPrefix: String = "", file: String = #file, line: Int = #line) -> Signal<OutputValue> {
		let prefix = logPrefix + (logPrefix.isEmpty ? "" : ": ")
		return onActivate { print("\(prefix)Activated at   \(file):\(line)") }
			.onValue { print("\(prefix)Value at       \(file):\(line) - \($0)") }
			.onError { print("\(prefix)Error at       \(file):\(line) - \($0)") }
			.onDeactivate { print("\(prefix)Deactivated at \(file):\(line)") }
	}
	
	/// Implementation of [Reactive X operator "materialize"](http://reactivex.io/documentation/operators/materialize-dematerialize.html)
	///
	/// WARNING: in CwlSignal, this operator will emit a `SignalEnd.complete` into the output signal immediately after emitting the first wrapped error. Within the "first error closes signal" behavior of CwlSignal, this is the only behavior that makes sense (since no further upstream values will be received), however, it does limit the usefulness of `materialize` to constructions where the `materialize` signal immediately outputs into a `SignalMultiInput` (including abstractions built on top, like `switchLatest` or child signals of a `flatMap`) that ignore non-error close conditions from the source signal.
	///
	/// - Returns: a signal where each `Result` emitted from self is further wrapped in a Result.success.
	func materialize() -> Signal<Result<OutputValue, SignalEnd>> {
		return transform { r in
			if r.isFailure {
				return .value(r, end: .complete)
			} else {
				return .value(r)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "dematerialize"](http://reactivex.io/documentation/operators/materialize-dematerialize.html)
	///
	/// NOTE: ideally, this would not be a static function but a "same type" conditional extension. In a future Swift release this will probably change.
	///
	/// - Parameter signal: a signal whose OutputValue is a `Result` wrapped version of an underlying type
	/// - Returns: a signal whose OutputValue is the unwrapped value from the input, with unwrapped errors sent as errors.
	static func dematerialize<OutputValue>(_ signal: Signal<Result<OutputValue, SignalEnd>>) -> Signal<OutputValue> {
		return signal.transform { (r: Result<Result<OutputValue, SignalEnd>, SignalEnd>) -> Signal<OutputValue>.Next in
			switch r {
			case .success(.success(let v)): return .value(v)
			case .success(.failure(let e)): return .end(e)
			case .failure(let e): return .end(e)
			}
		}
	}
}

extension SignalInterface {
	/// - Note: the [Reactive X operator "ObserveOn"](http://reactivex.io/documentation/operators/observeon.html) doesn't apply to CwlSignal.Signal since any CwlSignal.Signal that runs work can specify their own execution context and control scheduling in that way.
	
	/// - Note: the [Reactive X operator "Serialize"](http://reactivex.io/documentation/operators/serialize.html) doesn't apply to CwlSignal.Signal since all CwlSignal.Signal instances are always serialized and well-behaved under multi-threaded access.
	
	/// - Note: the [Reactive X operator "Subscribe" and "SubscribeOn"](http://reactivex.io/documentation/operators/subscribe.html) are implemented as `subscribe`.
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "TimeInterval"](http://reactivex.io/documentation/operators/timeinterval.html)
	///
	/// - Parameter context: time between emissions will be calculated based on the timestamps from this context
	/// - Returns: a signal where the values are seconds between emissions from self
	func timeInterval(context: Exec = .direct) -> Signal<Double> {
		let junction = self.map { v in () }.junction()
		
		// This `generate` transform is used to capture the start of the stream
		let s = Signal<Void>.generate { input in
			if let i = input {
				i.send(value: ())
				
				// Then after sending the initial value, connect to upstream
				try! junction.bind(to: i)
			} else {
				_ = junction.disconnect()
			}
		}.transform(initialState: nil, context: context) { (lastTime: inout DispatchTime?, r: Result<Void, SignalEnd>) -> Signal<Double>.Next in
			switch r {
			case .success:
				let currentTime = context.timestamp()
				if let l = lastTime {
					lastTime = currentTime
					return .value(currentTime.since(l).seconds)
				} else {
					lastTime = currentTime
					return .none
				}
			case .failure(let e):
				return .end(e)
			}
		}
		return s
	}
	
	/// Implementation of [Reactive X operator "Timeout"](http://reactivex.io/documentation/operators/timeout.html)
	///
	/// - Parameters:
	///   - interval: the duration before a SignalReactiveError.timeout will be emitted
	///   - resetOnValue: if `true`, each value sent through the signal will reset the timer (making the timeout an "idle" timeout). If `false`, the timeout duration is measured from the start of the signal and is unaffected by whether values are received.
	///   - context: timestamps will be added based on the time in this context
	/// - Returns: a mirror of self unless a timeout occurs, in which case it will closed by a SignalReactiveError.timeout
	func timeout(interval: DispatchTimeInterval, resetOnValue: Bool = true, context: Exec = .direct) -> Signal<OutputValue> {
		let (input, s) = Signal<Void>.create()
		let junction = Signal<Void>.timer(interval: interval, context: context).junction()
		// Both `junction` and `input` are newly created so this can't be an error
		try! junction.bind(to: input)
		return combine(s, context: context) { (cr: EitherResult2<OutputValue, ()>) -> Signal<OutputValue>.Next in
			switch cr {
			case .result1(let r):
				if resetOnValue {
					junction.rebind()
				}
				return .single(r)
			case .result2:
				return .end(.other(SignalReactiveError.timeout))
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Timestamp"](http://reactivex.io/documentation/operators/timestamp.html)
	///
	/// - Parameter context: used as the source of time
	/// - Returns: a signal where the values are a two element tuple, first element is self.OutputValue, second element is the `DispatchTime` timestamp that this element was emitted from self.
	func timestamp(context: Exec = .direct) -> Signal<(OutputValue, DispatchTime)> {
		return transform(context: context) { (r: Result<OutputValue, SignalEnd>) -> Signal<(OutputValue, DispatchTime)>.Next in
			switch r {
			case .success(let v): return .value((v, context.timestamp()))
			case .failure(let e): return .end(e)
			}
		}
	}
}

extension SignalInterface {
	/// - Note: the [Reactive X operator "Using"](http://reactivex.io/documentation/operators/using.html) doesn't apply to CwlSignal.Signal which uses standard Swift reference counted lifetimes. Resources should be captured by closures or `transform(initialState:...)`.
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "All"](http://reactivex.io/documentation/operators/all.html)
	///
	/// - Parameters:
	///   - context: the `test` function will be run in this context
	///   - test: will be invoked for every value
	/// - Returns: a signal that emits true and then closes if every value emitted by self returned true from the `test` function and self closed normally, otherwise emits false and then closes
	func all(context: Exec = .direct, test: @escaping (OutputValue) -> Bool) -> Signal<Bool> {
		return transform(context: context) { (r: Result<OutputValue, SignalEnd>) -> Signal<Bool>.Next in
			switch r {
			case .success(let v) where !test(v): return .value(false, end: .complete)
			case .failure(.complete): return .value(true, end: .complete)
			case .failure(let e): return .end(e)
			case .success: return .none
			}
		}
	}
}

extension Signal {
	/// Implementation of [Reactive X operator "Amb"](http://reactivex.io/documentation/operators/amb.html) using the alternate name `race`, since it better conveys the purpose.
	///
	/// - Parameter inputs: a set of inputs
	/// - Returns: connects to all inputs then emits the full set of values from the first of these to emit a value
	static func race<S: Sequence>(sequence: S) -> Signal<OutputValue> where S.Iterator.Element == Signal<OutputValue> {
		let (mergedInput, sig) = Signal<(Int, Result)>.createMergedInput()
		sequence.enumerated().forEach { s in
			mergedInput.add(s.element.transform { r in
				return .value((s.offset, r))
			}, closePropagation: .errors)
		}
		return sig.transform(initialState: -1) { (first: inout Int, r: Signal<(Int, Result)>.Result) -> Signal<OutputValue>.Next in
			switch r {
			case .success(let index, let underlying) where first < 0:
				first = index
				return .single(underlying)
			case .success(let index, let underlying) where first < 0 || first == index:
				return .single(underlying)
			case .failure(let e):
				return .end(e)
			case .success:
				return .none
			}
		}
	}

	static func race(_ signals: Signal<OutputValue>...) -> Signal<OutputValue> {
		return race(sequence: signals)
	}
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "Some"](http://reactivex.io/documentation/operators/some.html)
	///
	/// - Parameters:
	///   - context: the `test` function will be run in this context
	///   - test: will be invoked for every value
	/// - Returns: a signal that emits true and then closes when a value emitted by self returns true from the `test` function, otherwise if no values from self return true, emits false and then closes
	func find(context: Exec = .direct, test: @escaping (OutputValue) -> Bool) -> Signal<Bool> {
		return transform(context: context) { (r: Result<OutputValue, SignalEnd>) -> Signal<Bool>.Next in
			switch r {
			case .success(let v) where test(v):
				return .value(true, end: .complete)
			case .success:
				return .none
			case .failure(let e):
				return .value(false, end: e)
			}
		}
	}

	/// Implementation of [Reactive X operator "Some"](http://reactivex.io/documentation/operators/some.html)
	///
	/// - Parameters:
	///   - context: the `test` function will be run in this context
	///   - test: will be invoked for every value
	/// - Returns: a signal that emits true and then closes when a value emitted by self returns true from the `test` function, otherwise if no values from self return true, emits false and then closes
	func findIndex(context: Exec = .direct, test: @escaping (OutputValue) -> Bool) -> Signal<Int?> {
		return transform(initialState: 0, context: context) { (index: inout Int, r: Result<OutputValue, SignalEnd>) -> Signal<Int?>.Next in
			switch r {
			case .success(let v) where test(v):
				return .value(index, end: .complete)
			case .success:
				index += 1
				return .none
			case .failure(let e):
				return .value(nil, end: e)
			}
		}
	}
}

extension SignalInterface where OutputValue: Equatable {
	/// Implementation of [Reactive X operator "Some"](http://reactivex.io/documentation/operators/some.html)
	///
	/// - Parameter value: every value emitted by self is tested for equality with this value
	/// - Returns: a signal that emits true and then closes when a value emitted by self tests as `==` to `value`, otherwise if no values from self test as equal, emits false and then closes
	func find(value: OutputValue) -> Signal<Bool> {
		return find { value == $0 }
	}
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "DefaultIfEmpty"](http://reactivex.io/documentation/operators/defaultifempty.html)
	///
	/// - Parameter value: value to emit if self closes without a value
	/// - Returns: a signal that emits the same values as self or `value` if self closes without emitting a value
	func defaultIfEmpty(value: OutputValue) -> Signal<OutputValue> {
		return transform(initialState: false) { (started: inout Bool, r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			switch r {
			case .success(let v):
				started = true
				return .value(v)
			case .failure(let e) where !started:
				return .value(value, end: e)
			case .failure(let e):
				return .end(e)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "SwitchIfEmpty"](http://reactivex.io/documentation/operators/switchifempty.html)
	///
	/// - Parameter alternate: content will be used if self closes without emitting a value
	/// - Returns: a signal that emits the same values as self or mirrors `alternate` if self closes without emitting a value
	func switchIfEmpty(alternate: Signal<OutputValue>) -> Signal<OutputValue> {
		var fallback: Signal<OutputValue>? = alternate
		let (input, preMappedSignal) = Signal<OutputValue>.create()
		let s = preMappedSignal.map { (t: OutputValue) -> OutputValue in
			fallback = nil
			return t
		}
		
		// Both `junction` and `input` are newly created so this can't be an error
		try! junction().bind(to: input) { (j: SignalJunction<OutputValue>, e: SignalEnd, i: SignalInput<OutputValue>) in
			if let f = fallback {
				f.bind(to: i)
			} else {
				i.send(end: e)
			}
		}
		return s
	}
}

extension SignalInterface where OutputValue: Equatable {
	/// Implementation of [Reactive X operator "SequenceEqual"](http://reactivex.io/documentation/operators/sequenceequal.html)
	///
	/// - Parameter to: another signal whose contents will be compared to this signal
	/// - Returns: a signal that emits `true` if `self` and `to` are equal, `false` otherwise
	func sequenceEqual(to: Signal<OutputValue>) -> Signal<Bool> {
		return combine(to, initialState: (Array<OutputValue>(), Array<OutputValue>(), false, false)) { (state: inout (lq: Array<OutputValue>, rq: Array<OutputValue>, lc: Bool, rc: Bool), r: EitherResult2<OutputValue, OutputValue>) -> Signal<Bool>.Next in
			// state consists of lq (left queue), rq (right queue), lc (left closed), rc (right closed)
			switch (r, state.lq.first, state.rq.first) {
			case (.result1(.success(let left)), _, .some(let right)):
				if left != right {
					return .value(false, end: .complete)
				}
				state.rq.removeFirst()
				return .none
			case (.result1(.success(let left)), _, _):
				state.lq.append(left)
				return .none
			case (.result2(.success(let right)), .some(let left), _):
				if left != right {
					return .value(false, end: .complete)
				}
				state.lq.removeFirst()
				return .none
			case (.result2(.success(let right)), _, _):
				state.rq.append(right)
				return .none
			case (.result1(.failure(let e)), _, _):
				state.lc = true
				if state.rc {
					if state.lq.count == state.rq.count {
						return .value(true, end: e)
					} else {
						return .value(false, end: e)
					}
				}
				return .none
			case (.result2(.failure(let e)), _, _):
				state.rc = true
				if state.lc {
					if state.lq.count == state.rq.count {
						return .value(true, end: e)
					} else {
						return .value(false, end: e)
					}
				}
				return .none
			}
		}
	}
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "SkipUntil"](http://reactivex.io/documentation/operators/skipuntil.html)
	///
	/// - Parameter other: until this signal emits a value, all values from self will be dropped
	/// - Returns: a signal that mirrors `self` after `other` emits a value (but won't emit anything prior)
	func skipUntil<U: SignalInterface>(_ other: U) -> Signal<OutputValue> {
		return combine(other, initialState: false) { (started: inout Bool, cr: EitherResult2<OutputValue, U.OutputValue>) -> Signal<OutputValue>.Next in
			switch cr {
			case .result1(.success(let v)) where started:
				return .value(v)
			case .result1(.success):
				return .none
			case .result1(.failure(let e)):
				return .end(e)
			case .result2(.success):
				started = true
				return .none
			case .result2(.failure):
				return .none
			}
		}
	}
	
	/// Implementation of [Reactive X operator "SkipWhile"](http://reactivex.io/documentation/operators/skipwhile.html)
	///
	/// - Parameters:
	///   - context: execution context where `condition` will be run
	///   - condition: will be run for every value emitted from `self` until `condition` returns `true`
	/// - Returns: a signal that mirrors `self` dropping values until `condition` returns `true` for one of the values
	func skipWhile(context: Exec = .direct, condition: @escaping (OutputValue) throws -> Bool) -> Signal<OutputValue> {
		return transform(initialState: false, context: context) { (started: inout Bool, r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			do {
				switch r {
				case .success(let v) where try !started && condition(v):
					return .none
				case .success(let v):
					started = true
					return .value(v)
				case .failure(let e):
					return .end(e)
				}
			} catch {
				return .error(error)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "SkipWhile"](http://reactivex.io/documentation/operators/skipwhile.html)
	///
	/// - Parameters:
	///   - initialState: intial value for a state parameter that will be passed to `condition` on each invocation
	///   - context: execution context where `condition` will be run
	///   - condition: will be run for every value emitted from `self` until `condition` returns `true`
	/// - Returns: a signal that mirrors `self` dropping values until `condition` returns `true` for one of the values
	func skipWhile<U>(initialState initial: U, context: Exec = .direct, condition: @escaping (inout U, OutputValue) throws -> Bool) -> Signal<OutputValue> {
		return transform(initialState: (initial, false), context: context) { (started: inout (U, Bool), r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			do {
				switch r {
				case .success(let v) where try !started.1 && condition(&started.0, v):
					return .none
				case .success(let v):
					started.1 = true
					return .value(v)
				case .failure(let e):
					return .end(e)
				}
			} catch {
				return .error(error)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "TakeUntil"](http://reactivex.io/documentation/operators/takeuntil.html)
	///
	/// - Parameter other: after this signal emits a value, all values from self will be dropped
	/// - Returns: a signal that mirrors `self` until `other` emits a value (but won't emit anything after)
	func takeUntil<U: SignalInterface>(_ other: U) -> Signal<OutputValue> {
		return combine(other, initialState: false) { (started: inout Bool, cr: EitherResult2<OutputValue, U.OutputValue>) -> Signal<OutputValue>.Next in
			switch cr {
			case .result1(.success(let v)) where !started: return .value(v)
			case .result1(.success): return .none
			case .result1(.failure(let e)): return .end(e)
			case .result2(.success):
				started = true
				return .none
			case .result2(.failure): return .none
			}
		}
	}
	
	/// Implementation of [Reactive X operator "TakeWhile"](http://reactivex.io/documentation/operators/takewhile.html)
	///
	/// - Parameters:
	///   - context: execution context where `condition` will be run
	///   - condition: will be run for every value emitted from `self` until `condition` returns `true`
	/// - Returns: a signal that mirrors `self` dropping values after `condition` returns `true` for one of the values
	func takeWhile(context: Exec = .direct, condition: @escaping (OutputValue) throws -> Bool) -> Signal<OutputValue> {
		return transform(context: context) { (r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			do {
				switch r {
				case .success(let v) where try condition(v): return .value(v)
				case .success: return .complete()
				case .failure(let e): return .end(e)
				}
			} catch {
				return .error(error)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "TakeWhile"](http://reactivex.io/documentation/operators/takewhile.html)
	///
	/// - Parameters:
	///   - initialState: intial value for a state parameter that will be passed to `condition` on each invocation
	///   - context: execution context where `condition` will be run
	///   - condition: will be run for every value emitted from `self` until `condition` returns `true`
	/// - Returns: a signal that mirrors `self` dropping values after `condition` returns `true` for one of the values
	func takeWhile<U>(initialState initial: U, context: Exec = .direct, condition: @escaping (inout U, OutputValue) throws -> Bool) -> Signal<OutputValue> {
		return transform(initialState: initial, context: context) { (i: inout U, r: Result<OutputValue, SignalEnd>) -> Signal<OutputValue>.Next in
			do {
				switch r {
				case .success(let v) where try condition(&i, v): return .value(v)
				case .success: return .complete()
				case .failure(let e): return .end(e)
				}
			} catch {
				return .error(error)
			}
		}
	}
	
	/// A helper method used for mathematical operators. Performs a basic `fold` over the values emitted by `self` then passes the final result through another `finalize` function before emitting the result as a value in the returned signal.
	///
	/// - Parameters:
	///   - initial: used to initialize the fold state
	///   - context: all functions will be invoked in this context
	///   - finalize: invoked when `self` closes, with the current fold state value
	///   - fold: invoked for each value emitted by `self` along with the current fold state value
	/// - Returns: a signal which emits the `finalize` result
	func foldAndFinalize<U, V>(_ initial: V, context: Exec = .direct, finalize: @escaping (V) throws -> U?, fold: @escaping (V, OutputValue) throws -> V) -> Signal<U> {
		return transform(initialState: initial, context: context) { (state: inout V, r: Result<OutputValue, SignalEnd>) -> Signal<U>.Next in
			do {
				switch r {
				case .success(let v):
					state = try fold(state, v)
					return .none
				case .failure(let e):
					if let v = try finalize(state) {
						return .value(v, end: e)
					} else {
						return .end(e)
					}
				}
			} catch {
				return .error(error)
			}
		}
	}
}

extension SignalInterface where OutputValue: BinaryInteger {
	/// Implementation of [Reactive X operator "Average"](http://reactivex.io/documentation/operators/average.html)
	///
	/// - Returns: a signal that emits a single value... the sum of all values emitted by `self`
	func average() -> Signal<OutputValue> {
		return foldAndFinalize((0, 0), finalize: { (fold: (OutputValue, OutputValue)) -> OutputValue? in fold.0 > 0 ? fold.1 / fold.0 : nil }) { (fold: (OutputValue, OutputValue), value: OutputValue) -> (OutputValue, OutputValue) in
			return (fold.0 + 1, fold.1 + value)
		}
	}
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "Concat"](http://reactivex.io/documentation/operators/concat.html)
	///
	/// - Parameter other: a second signal
	/// - Returns: a signal that emits all the values from `self` followed by all the values from `other` (including those emitted while `self` was still active)
	func concat(_ other: Signal<OutputValue>) -> Signal<OutputValue> {
		return combine(other, initialState: ([OutputValue](), nil, nil)) { (state: inout (secondValues: [OutputValue], firstError: SignalEnd?, secondError: SignalEnd?), cr: EitherResult2<OutputValue, OutputValue>) -> Signal<OutputValue>.Next in
			switch (cr, state.firstError) {
			case (.result1(.success(let v)), _):
				return .value(v)
			case (.result1(.failure(.complete)), _):
				if let e2 = state.secondError {
					return .values(sequence: state.secondValues, end: e2)
				} else {
					state.firstError = .complete
					return .values(sequence: state.secondValues)
				}
			case (.result1(.failure(let e1)), _):
				// In the event of an "unexpected" error, don't emit the second signal.
				return .end(e1)
			case (.result2(.success(let v)), .none):
				state.secondValues.append(v)
				return .none
			case (.result2(.success(let v)), .some):
				return .value(v)
			case (.result2(.failure(let e2)), .none):
				state.secondError = e2
				return .none
			case (.result2(.failure(let e2)), .some):
				return .end(e2)
			}
		}
	}
	
	/// Implementation of [Reactive X operator "Count"](http://reactivex.io/documentation/operators/count.html)
	///
	/// - Returns: a signal that emits the number of values emitted by `self`
	func count() -> Signal<Int> {
		return aggregate(0) { (fold: (Int), value: OutputValue) -> Int in
			return fold + 1
		}
	}
}

extension SignalInterface where OutputValue: Comparable {
	/// Implementation of [Reactive X operator "Min"](http://reactivex.io/documentation/operators/min.html)
	///
	/// - Returns: the smallest value emitted by self
	func min() -> Signal<OutputValue> {
		return foldAndFinalize(nil, finalize: { $0 }) { (fold: OutputValue?, value: OutputValue) -> OutputValue? in
			return fold.map { value < $0 ? value : $0 } ?? value
		}
	}
	
	/// Implementation of [Reactive X operator "Max"](http://reactivex.io/documentation/operators/max.html)
	///
	/// - Returns: the largest value emitted by self
	func max() -> Signal<OutputValue> {
		return foldAndFinalize(nil, finalize: { $0 }) { (fold: OutputValue?, value: OutputValue) -> OutputValue? in
			return fold.map { value > $0 ? value : $0 } ?? value
		}
	}
}

extension SignalInterface {
	/// Implementation of [Reactive X operator "Reduce"](http://reactivex.io/documentation/operators/reduce.html). The .NET/alternate name of `aggregate` is used to avoid conflict with the Signal.reduce function.
	///
	/// See also: `scan` which applies the same logic but emits the `fold` value on *every* invocation.
	///
	/// - Parameters:
	///   - initial: initialize the state value
	///   - context: the `fold` function will be invoked on this context
	///   - fold: invoked for every value emitted from self
	/// - Returns: emits the last emitted `fold` state value
	func aggregate<U>(_ initial: U, context: Exec = .direct, fold: @escaping (U, OutputValue) -> U) -> Signal<U> {
		return foldAndFinalize(initial, context: context, finalize: { $0 }) { (state: U, value: OutputValue) in
			return fold(state, value)
		}
	}
}

extension SignalInterface where OutputValue: Numeric {
	/// Implementation of [Reactive X operator "Sum"](http://reactivex.io/documentation/operators/sum.html)
	///
	/// - Returns: a signal that emits the sum of all values emitted by self
	func sum() -> Signal<OutputValue> {
		return aggregate(0) { (fold: OutputValue, value: OutputValue) -> OutputValue in
			return fold + value
		}
	}
}
